<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以梦为马</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://smartliby.github.io/"/>
  <updated>2020-04-04T16:23:34.151Z</updated>
  <id>https://smartliby.github.io/</id>
  
  <author>
    <name>James Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kubeflow1.0 安装教程</title>
    <link href="https://smartliby.github.io/2020/04/04/kubeflow%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://smartliby.github.io/2020/04/04/kubeflow安装教程/</id>
    <published>2020-04-04T12:21:11.000Z</published>
    <updated>2020-04-04T16:23:34.151Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.kubeflow.org/docs" target="_blank" rel="noopener">Kubeflow</a>是Google推出的基于kubernetes环境下的机器学习组件，通过Kubeflow可以实现对TFJob等资源类型定义，可以像部署应用一样完成在TFJob分布式训练模型的过程。最初的设计是将Kubernetes和Tensorflow结合实现对Tensorflow分布式训练的支持。但是仅仅实现对Tensorflow的支持还是远远不够的，<code>Kubeflow</code>社区又陆续对各种深度学习框架进行支持,例如:<code>MXNet</code>, <code>Caffee</code>, <code>PyTorch</code>等。使得机器学习算法同学只需关心算法实现，而后续的模型训练和服务上线都交给平台来做,解放算法同学使其专做自己擅长的事儿。</p><a id="more"></a><p>目前Kubeflow仅支持在v1.15.11及以下版本的k8s上部署，v1.16及以上存在兼容性问题，具体情况可参考<a href="https://www.kubeflow.org/docs/started/k8s/overview/" target="_blank" rel="noopener">这篇文章</a>，接下来我们基于<a href="https://microk8s.io/" target="_blank" rel="noopener">Microk8s</a>（版本1.15/stable）部署kubeflow v1.0</p><h4 id="安装-knative-v0-7-1"><a href="#安装-knative-v0-7-1" class="headerlink" title="安装 knative v0.7.1"></a>安装 knative v0.7.1</h4><p>kubeflow安装时依赖knative和istio组件，所以需要先安装knative，istio(microk8s安装时已安装<code>microk8s.enable istio</code>，不需要再安装)，knative 的镜像是用 sha256 方式来 pull的。在本地我们不能通过 docker tag 的方式重新打包，只能修改 yaml 里的所有配置</p><p>默认knative的安装配置文件在<code>/snap/microk8s/current/actions/knative/</code>目录下，没有操作权限无法修改，需要先拷贝出来或者去github下载到本地，并将里面的镜像下载域名由gcr.io改成gcr.azk8s.cn</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 Knative CRD</span></span><br><span class="line">kubectl apply --selector knative.dev/crd-install=true -f serving.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再运行一遍 kubectl apply</span></span><br><span class="line">kubectl apply  -f serving.yaml</span><br></pre></td></tr></table></figure><h4 id="验证-knative-安装"><a href="#验证-knative-安装" class="headerlink" title="验证 knative 安装"></a>验证 knative 安装</h4><p>运行<code>kubectl get pods --namespace knative-serving</code>验证 Knative 所有 pod 是否可以正常启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">activator-55f6c8d9b-2hs77                 2/2     Running   24         2d13h</span><br><span class="line">autoscaler-78d575f875-l7zfj               2/2     Running   18         2d13h</span><br><span class="line">controller-776478fb94-hmmxc               1/1     Running   3          2d13h</span><br><span class="line">networking-certmanager-779cd6f448-xtvrb   1/1     Running   3          2d13h</span><br><span class="line">networking-istio-674bd78b75-688gc         1/1     Running   3          2d13h</span><br><span class="line">webhook-59b575dc79-cs7f4                  1/1     Running   0          13h</span><br></pre></td></tr></table></figure><h4 id="安装kubeflow"><a href="#安装kubeflow" class="headerlink" title="安装kubeflow"></a>安装kubeflow</h4><p>下载 kfctl binary from the <a href="https://github.com/kubeflow/kfctl/releases/" target="_blank" rel="noopener">Kubeflow releases page</a></p><p>解压安装包并添加到执行目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf kfctl_v1.0.1-0-gf3edb9b_linux.tar.gz</span><br><span class="line">sudo cp kfctl /usr/bin</span><br></pre></td></tr></table></figure><p>设置环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export BASE_DIR=/data/</span><br><span class="line">export KF_NAME=my-kubeflow</span><br><span class="line">export KF_DIR=$&#123;BASE_DIR&#125;/$&#123;KF_NAME&#125;</span><br><span class="line">export CONFIG_URI=&quot;https://raw.githubusercontent.com/kubeflow/manifests/v1.0-branch/kfdef/kfctl_k8s_istio.v1.0.1.yaml&quot;</span><br></pre></td></tr></table></figure><p>部署kubeflow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $&#123;KF_DIR&#125;</span><br><span class="line">cd $&#123;KF_DIR&#125;</span><br><span class="line">kfctl apply -V -f $&#123;CONFIG_URI&#125;</span><br><span class="line">kubectl -n kubeflow get all</span><br></pre></td></tr></table></figure><p>输出如下日志即安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO[0259] Applied the configuration Successfully!       filename=&quot;cmd/apply.go:72&quot;</span><br></pre></td></tr></table></figure><p>查看当前 Kubernetes pods 状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --namespace kubeflow</span><br></pre></td></tr></table></figure><p>发现kubeflow的pod大部分没有启动成功，原因还是网络问题，需要访问gcr.io下载镜像</p><p>执行以下脚本将镜像下载到本地并导入到microk8s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">echo ""</span><br><span class="line">echo "=========================================================="</span><br><span class="line">echo "pull kubeflow  v1.0 images from gcr.azk8s.cn ..."</span><br><span class="line">echo "=========================================================="</span><br><span class="line">echo ""</span><br><span class="line"></span><br><span class="line">ORIGINAL_REGISTRY=gcr.io</span><br><span class="line">MY_REGISTRY=gcr.azk8s.cn</span><br><span class="line"></span><br><span class="line">gcr_imgs=(</span><br><span class="line">    "kfserving/kfserving-controller:0.2.2"</span><br><span class="line">    "ml-pipeline/api-server:0.2.0"</span><br><span class="line">    "kubeflow-images-public/kfam:v1.0.0-gf3e09203"</span><br><span class="line">    "kubeflow-images-public/ingress-setup:latest"</span><br><span class="line">    "kubeflow-images-public/kubernetes-sigs/application:1.0-beta"</span><br><span class="line">    "kubeflow-images-public/centraldashboard:v1.0.0-g3ec0de71"</span><br><span class="line">    "kubeflow-images-public/jupyter-web-app:v1.0.0-g2bd63238"</span><br><span class="line">    "kubeflow-images-public/katib/v1alpha3/katib-controller:v0.8.0"</span><br><span class="line">    "kubeflow-images-public/katib/v1alpha3/katib-db-manager:v0.8.0"</span><br><span class="line">    "kubeflow-images-public/katib/v1alpha3/katib-ui:v0.8.0"</span><br><span class="line">    "kubebuilder/kube-rbac-proxy:v0.4.0"</span><br><span class="line">    "metacontroller/metacontroller:v0.3.0"</span><br><span class="line">    "kubeflow-images-public/metadata:v0.1.11"</span><br><span class="line">    "ml-pipeline/envoy:metadata-grpc"</span><br><span class="line">    "tfx-oss-public/ml_metadata_store_server:v0.21.1"</span><br><span class="line">    "kubeflow-images-public/metadata-frontend:v0.1.8"</span><br><span class="line">    "ml-pipeline/visualization-server:0.2.0"</span><br><span class="line">    "ml-pipeline/persistenceagent:0.2.0"</span><br><span class="line">    "ml-pipeline/scheduledworkflow:0.2.0"</span><br><span class="line">    "ml-pipeline/frontend:0.2.0"</span><br><span class="line">    "ml-pipeline/viewer-crd-controller:0.2.0"</span><br><span class="line">    "kubeflow-images-public/notebook-controller:v1.0.0-gcd65ce25"</span><br><span class="line">    "kubeflow-images-public/profile-controller:v1.0.0-ge50a8531"</span><br><span class="line">    "kubeflow-images-public/pytorch-operator:v1.0.0-g047cf0f"</span><br><span class="line">    "spark-operator/spark-operator:v1beta2-1.0.0-2.4.4"</span><br><span class="line">    "spark-operator/spark-operator:v1beta2-1.0.0-2.4.4"</span><br><span class="line">    "google_containers/spartakus-amd64:v1.1.0"</span><br><span class="line">    "kubeflow-images-public/tf_operator:v1.0.0-g92389064"</span><br><span class="line">    "kubeflow-images-public/admission-webhook:v1.0.0-gaf96e4e3"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for img in $&#123;gcr_imgs[@]&#125;</span><br><span class="line">do</span><br><span class="line">    # 拉取镜像</span><br><span class="line">    docker pull $&#123;MY_REGISTRY&#125;/$&#123;img&#125;</span><br><span class="line">    # 添加Tag</span><br><span class="line">    docker tag $&#123;MY_REGISTRY&#125;/$&#123;img&#125; $&#123;ORIGINAL_REGISTRY&#125;/$&#123;img&#125;</span><br><span class="line">    # 输出</span><br><span class="line">    docker save $&#123;ORIGINAL_REGISTRY&#125;/$&#123;img&#125; &gt; $&#123;img##*/&#125;.tar</span><br><span class="line">    # 输入</span><br><span class="line">    microk8s.ctr -n k8s.io image import $&#123;img##*/&#125;.tar</span><br><span class="line">    # 删除Tag</span><br><span class="line">    docker rmi $&#123;MY_REGISTRY&#125;/$&#123;img&#125; $&#123;ORIGINAL_REGISTRY&#125;/$&#123;img&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo ""</span><br><span class="line">echo "=========================================================="</span><br><span class="line">echo "pull kubeflow  v1.0 images from gcr.azk8s.cn finished."</span><br><span class="line">echo "=========================================================="</span><br><span class="line">echo ""</span><br></pre></td></tr></table></figure><p>如果还是有pod无法启动，可通过<code>kubectl describe pod 未启动pod的名称 -n kubeflow</code>查看原因</p><p>如果是因为镜像无法下载，可以将依赖的镜像加到上面的脚本里下载镜像</p><p>如果是因为镜像拉取策略导致每次都重新下载问题，可通过下面命令或者kubernetes-dashboard修改，将<code>Always</code> 改为 <code>IfNotPresent</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit pod 未启动pod的名称 -n kubeflow</span><br></pre></td></tr></table></figure><p>执行 <code>kubectl get pods --namespace kubeflow</code>查看kubeflow的pod都已运行起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">NAME                                                           READY   STATUS      RESTARTS   AGE</span><br><span class="line">admission-webhook-bootstrap-stateful-set-0                     1/1     Running     6          2d4h</span><br><span class="line">admission-webhook-deployment-569558c8b6-n8b7k                  1/1     Running     0          13h</span><br><span class="line">application-controller-stateful-set-0                          1/1     Running     3          2d4h</span><br><span class="line">argo-ui-7ffb9b6577-w8pb7                                       1/1     Running     7          3d7h</span><br><span class="line">centraldashboard-659bd78c-fxgqd                                1/1     Running     3          3d7h</span><br><span class="line">jupyter-web-app-deployment-878f9c988-xgh82                     1/1     Running     3          2d5h</span><br><span class="line">katib-controller-7f58569f7d-8bw7z                              1/1     Running     4          3d7h</span><br><span class="line">katib-db-manager-54b66f9f9d-ngqw9                              1/1     Running     3          3d7h</span><br><span class="line">katib-mysql-dcf7dcbd5-7wbck                                    1/1     Running     12         4d1h</span><br><span class="line">katib-ui-6f97756598-4mtjs                                      1/1     Running     3          3d7h</span><br><span class="line">kfserving-controller-manager-0                                 2/2     Running     7          2d5h</span><br><span class="line">metacontroller-0                                               1/1     Running     5          3d7h</span><br><span class="line">metadata-db-65fb5b695d-wq8vh                                   1/1     Running     12         4d1h</span><br><span class="line">metadata-deployment-65ccddfd4c-vwfd2                           1/1     Running     3          3d7h</span><br><span class="line">metadata-envoy-deployment-7754f56bff-svtz2                     1/1     Running     3          3d7h</span><br><span class="line">metadata-grpc-deployment-75f9888cbf-zj4sn                      1/1     Running     5          3d7h</span><br><span class="line">metadata-ui-7c85545947-v68l7                                   1/1     Running     3          3d7h</span><br><span class="line">minio-69b4676bb7-w96xk                                         1/1     Running     12         4d1h</span><br><span class="line">ml-pipeline-5cddb75848-bsc48                                   1/1     Running     3          2d6h</span><br><span class="line">ml-pipeline-ml-pipeline-visualizationserver-7f6fcb68c8-vxjj7   1/1     Running     3          2d7h</span><br><span class="line">ml-pipeline-persistenceagent-6ff9fb86dc-dvxx4                  1/1     Running     5          2d6h</span><br><span class="line">ml-pipeline-scheduledworkflow-7f84b54646-ndxcb                 1/1     Running     3          2d7h</span><br><span class="line">ml-pipeline-ui-6758f58868-gqvlp                                1/1     Running     3          2d6h</span><br><span class="line">ml-pipeline-viewer-controller-deployment-685874bc58-jljw8      1/1     Running     3          2d5h</span><br><span class="line">mysql-6bcbfbb6b8-xmphz                                         1/1     Running     12         4d1h</span><br><span class="line">notebook-controller-deployment-7db7c8589d-mlgb4                1/1     Running     3          2d5h</span><br><span class="line">profiles-deployment-56b7c6788f-kk8kh                           2/2     Running     6          2d7h</span><br><span class="line">pytorch-operator-cf8c5c497-nmfnv                               1/1     Running     7          3d7h</span><br><span class="line">seldon-controller-manager-6b4b969447-qp7l4                     1/1     Running     20         4d1h</span><br><span class="line">spark-operatorcrd-cleanup-rrpxd                                0/2     Completed   0          3d7h</span><br><span class="line">spark-operatorsparkoperator-76dd5f5688-kn28n                   1/1     Running     3          3d7h</span><br><span class="line">spartakus-volunteer-5dc96f4447-xjclm                           1/1     Running     3          3d7h</span><br><span class="line">tensorboard-5f685f9d79-9x549                                   1/1     Running     12         4d1h</span><br><span class="line">tf-job-operator-5fb85c5fb7-lqvrg                               1/1     Running     6          3d7h</span><br><span class="line">workflow-controller-689d6c8846-znvt9                           1/1     Running     12         4d1h</span><br></pre></td></tr></table></figure><p>执行如下命令进行端口映射访问Kubeflow UI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup kubectl port-forward -n istio-system svc/istio-ingressgateway 8088:80 &amp;</span><br></pre></td></tr></table></figure><p>访问<a href="http://127.0.0.1:8088/" target="_blank" rel="noopener">http://127.0.0.1:8088/</a></p><p><img src="/images/media/选区_053.png" alt></p><h4 id="创建Jupyter-notebook-server"><a href="#创建Jupyter-notebook-server" class="headerlink" title="创建Jupyter notebook server"></a>创建Jupyter notebook server</h4><p><img src="/images/media/选区_054.png" alt></p><p><img src="/images/media/选区_055.png" alt></p><p><img src="/images/media/选区_056.png" alt></p><p>点击连接之后就可以跑模型训练了</p><h4 id="测试Jupyter"><a href="#测试Jupyter" class="headerlink" title="测试Jupyter"></a>测试Jupyter</h4><p>创建Python 3 notebook，执行如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line">mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;, one_hot=True)</span><br><span class="line"></span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">x = tf.placeholder(tf.float32, [None, 784])</span><br><span class="line"></span><br><span class="line">W = tf.Variable(tf.zeros([784, 10]))</span><br><span class="line">b = tf.Variable(tf.zeros([10]))</span><br><span class="line"></span><br><span class="line">y = tf.nn.softmax(tf.matmul(x, W) + b)</span><br><span class="line"></span><br><span class="line">y_ = tf.placeholder(tf.float32, [None, 10])</span><br><span class="line">cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))</span><br><span class="line"></span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(0.05).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">tf.global_variables_initializer().run()</span><br><span class="line"></span><br><span class="line">for _ in range(1000):</span><br><span class="line">  batch_xs, batch_ys = mnist.train.next_batch(100)</span><br><span class="line">  sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)</span><br><span class="line"></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">print(&quot;Accuracy: &quot;, sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;))</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accuracy:  0.9012</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.kubeflow.org/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kubeflow&lt;/a&gt;是Google推出的基于kubernetes环境下的机器学习组件，通过Kubeflow可以实现对TFJob等资源类型定义，可以像部署应用一样完成在TFJob分布式训练模型的过程。最初的设计是将Kubernetes和Tensorflow结合实现对Tensorflow分布式训练的支持。但是仅仅实现对Tensorflow的支持还是远远不够的，&lt;code&gt;Kubeflow&lt;/code&gt;社区又陆续对各种深度学习框架进行支持,例如:&lt;code&gt;MXNet&lt;/code&gt;, &lt;code&gt;Caffee&lt;/code&gt;, &lt;code&gt;PyTorch&lt;/code&gt;等。使得机器学习算法同学只需关心算法实现，而后续的模型训练和服务上线都交给平台来做,解放算法同学使其专做自己擅长的事儿。&lt;/p&gt;
    
    </summary>
    
      <category term="kubeflow" scheme="https://smartliby.github.io/categories/kubeflow/"/>
    
    
      <category term="k8s" scheme="https://smartliby.github.io/tags/k8s/"/>
    
      <category term="microk8s" scheme="https://smartliby.github.io/tags/microk8s/"/>
    
      <category term="kubeflow" scheme="https://smartliby.github.io/tags/kubeflow/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 18.04安装microk8s教程</title>
    <link href="https://smartliby.github.io/2020/04/03/microk8s%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://smartliby.github.io/2020/04/03/microk8s安装教程/</id>
    <published>2020-04-03T12:21:11.000Z</published>
    <updated>2020-04-04T16:24:05.246Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://microk8s.io/" target="_blank" rel="noopener">Microk8s</a>是一个集成化的容器管理平台，与Kubernetes完全兼容，主要面向工作站、边缘计算和IoT等领域建立容器计算平台。</p><a id="more"></a><h4 id="安装-microk8s"><a href="#安装-microk8s" class="headerlink" title="安装 microk8s"></a>安装 microk8s</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap install microk8s --classic --channel=1.15/stable</span><br></pre></td></tr></table></figure><h4 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap alias microk8s.kubectl kubectl</span><br></pre></td></tr></table></figure><h4 id="config配置"><a href="#config配置" class="headerlink" title="config配置"></a>config配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo microk8s.kubectl config view --raw &gt; $HOME/.kube/config</span><br></pre></td></tr></table></figure><h4 id="启用k8s组件"><a href="#启用k8s组件" class="headerlink" title="启用k8s组件"></a>启用k8s组件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">microk8s.enable dashboard dns ingress istio registry storage</span><br></pre></td></tr></table></figure><h4 id="如果有GPU"><a href="#如果有GPU" class="headerlink" title="如果有GPU"></a>如果有GPU</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">microk8s.enable gpu</span><br></pre></td></tr></table></figure><h4 id="执行-microk8s-enable-顺利的话，你将看到类似下面的日志"><a href="#执行-microk8s-enable-顺利的话，你将看到类似下面的日志" class="headerlink" title="执行 microk8s.enable 顺利的话，你将看到类似下面的日志"></a>执行 <code>microk8s.enable</code> 顺利的话，你将看到类似下面的日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">logentry.config.istio.io/accesslog created</span><br><span class="line">logentry.config.istio.io/tcpaccesslog created</span><br><span class="line">rule.config.istio.io/stdio created</span><br><span class="line">rule.config.istio.io/stdiotcp created</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Istio is starting</span><br><span class="line">Enabling the private registry</span><br><span class="line">Enabling default storage class</span><br><span class="line">deployment.extensions/hostpath-provisioner created</span><br><span class="line">storageclass.storage.k8s.io/microk8s-hostpath created</span><br><span class="line">Storage will be available soon</span><br><span class="line">Applying registry manifest</span><br><span class="line">namespace/container-registry created</span><br><span class="line">persistentvolumeclaim/registry-claim created</span><br><span class="line">deployment.extensions/registry created</span><br><span class="line">service/registry created</span><br><span class="line">The registry is enabled</span><br><span class="line">Enabling default storage class</span><br><span class="line">deployment.extensions/hostpath-provisioner unchanged</span><br><span class="line">storageclass.storage.k8s.io/microk8s-hostpath unchanged</span><br><span class="line">Storage will be available soon</span><br></pre></td></tr></table></figure><h4 id="使用-microk8s-status-检查各个组件的状态"><a href="#使用-microk8s-status-检查各个组件的状态" class="headerlink" title="使用 microk8s.status 检查各个组件的状态"></a>使用 <code>microk8s.status</code> 检查各个组件的状态</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">microk8s is running</span><br><span class="line">addons:</span><br><span class="line">knative: disabled</span><br><span class="line">jaeger: disabled</span><br><span class="line">fluentd: disabled</span><br><span class="line">gpu: enabled</span><br><span class="line">cilium: disabled</span><br><span class="line">storage: enabled</span><br><span class="line">registry: enabled</span><br><span class="line">rbac: disabled</span><br><span class="line">ingress: enabled</span><br><span class="line">dns: enabled</span><br><span class="line">metrics-server: disabled</span><br><span class="line">linkerd: disabled</span><br><span class="line">prometheus: disabled</span><br><span class="line">istio: enabled</span><br><span class="line">dashboard: enabled</span><br></pre></td></tr></table></figure><h4 id="使用-microk8s-inspect-排查下安装部署结果"><a href="#使用-microk8s-inspect-排查下安装部署结果" class="headerlink" title="使用 microk8s.inspect 排查下安装部署结果"></a>使用 <code>microk8s.inspect</code> 排查下安装部署结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Inspecting services</span><br><span class="line">  Service snap.microk8s.daemon-containerd is running</span><br><span class="line">  Service snap.microk8s.daemon-docker is running</span><br><span class="line">  Service snap.microk8s.daemon-apiserver is running</span><br><span class="line">  Service snap.microk8s.daemon-proxy is running</span><br><span class="line">  Service snap.microk8s.daemon-kubelet is running</span><br><span class="line">  Service snap.microk8s.daemon-scheduler is running</span><br><span class="line">  Service snap.microk8s.daemon-controller-manager is running</span><br><span class="line">  Service snap.microk8s.daemon-etcd is running</span><br><span class="line">  Copy service arguments to the final report tarball</span><br><span class="line">Inspecting AppArmor configuration</span><br><span class="line">Gathering system info</span><br><span class="line">  Copy network configuration to the final report tarball</span><br><span class="line">  Copy processes list to the final report tarball</span><br><span class="line">  Copy snap list to the final report tarball</span><br><span class="line">  Inspect kubernetes cluster</span><br><span class="line"></span><br><span class="line"> WARNING:  IPtables FORWARD policy is DROP. Consider enabling traffic forwarding with: sudo iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><p>执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw default allow routed</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><p>再次使用 <code>microk8s.inspect</code> 命令检查，会发现 WARNING消失了</p><h4 id="使用-microk8s-kubectl-get-pods-all-namespaces-查看当前-Kubernetes-pods-状态"><a href="#使用-microk8s-kubectl-get-pods-all-namespaces-查看当前-Kubernetes-pods-状态" class="headerlink" title="使用 microk8s.kubectl get pods --all-namespaces 查看当前 Kubernetes pods 状态"></a>使用 <code>microk8s.kubectl get pods --all-namespaces</code> 查看当前 Kubernetes pods 状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAMESPACE            NAME                                              READY   STATUS              RESTARTS   AGE</span><br><span class="line">container-registry   registry-7fc4594d64-rrgs9                         0/1     Pending             0          15m</span><br><span class="line">default              default-http-backend-855bc7bc45-t4st8             0/1     ContainerCreating   0          16m</span><br><span class="line">default              nginx-ingress-microk8s-controller-kgjtl           0/1     ContainerCreating   0          16m</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>大部分pod都没有启动起来，什么原因呢？</p><h4 id="使用-describe-命令查看-pod"><a href="#使用-describe-命令查看-pod" class="headerlink" title="使用 describe 命令查看 pod"></a>使用 describe 命令查看 pod</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod default-http-backend -n container-registry</span><br></pre></td></tr></table></figure><p>日志如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type     Reason                  Age                   From                              Message</span><br><span class="line">  ----     ------                  ----                  ----                              -------</span><br><span class="line">  Warning  FailedCreatePodSandBox  22m (x33 over 69m)    kubelet, izwz9h8m2chowowqckbcy0z  Failed create pod sandbox: rpc error: code = Unknown desc = failed to get sandbox image &quot;k8s.gcr.io/pause:3.1&quot;: failed to pull image &quot;k8s.gcr.io/pause:3.1&quot;: failed to resolve image &quot;k8s.gcr.io/pause:3.1&quot;: no available registry endpoint: failed to do request: Head https://k8s.gcr.io/v2/pause/manifests/3.1: dial tcp 108.177.97.82:443: i/o timeout</span><br></pre></td></tr></table></figure><p>这是 pod 的 sandbox 镜像拉取失败。 </p><p>网上查资料，k8s.gcr.io/pause:3.1 是存放在 google cloud 上的镜像，由于众所周知的原因，访问失败了。</p><p>解决的方法有：</p><ol><li>科学上网</li><li>手动下载镜像</li></ol><h4 id="方法1操作流程"><a href="#方法1操作流程" class="headerlink" title="方法1操作流程"></a>方法1操作流程</h4><p>编辑 MicroK8s 使用的 docker 环境变量配置文件，<code>vim /var/snap/microk8s/current/args/containerd-env</code>在其中添加代理配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPS_PROXY=https://127.0.0.1:8123</span><br></pre></td></tr></table></figure><p>重启 docker </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart snap.microk8s.daemon-docker.service</span><br></pre></td></tr></table></figure><p>重置 MicroK8s 并再次尝试安装各种组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">microk8s.reset</span><br><span class="line">microk8s.enable dashboard dns ingress istio registry storage</span><br></pre></td></tr></table></figure><h4 id="方法2操作流程"><a href="#方法2操作流程" class="headerlink" title="方法2操作流程"></a>方法2操作流程</h4><p>安装 docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>感谢微软 azure 提供 gcr 镜像下载：<a href="http://mirror.azure.cn/help/gcr-proxy-cache.html" target="_blank" rel="noopener">地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull gcr.azk8s.cn/google_containers/pause:3.1</span><br><span class="line">docker tag gcr.azk8s.cn/google_containers/pause:3.1 k8s.gcr.io/pause:3.1</span><br></pre></td></tr></table></figure><p><strong>v1.14 之后 microk8s 使用 containerd 代替 dockerd</strong>，具体可见这个<a href="https://github.com/ubuntu/microk8s/issues/382" target="_blank" rel="noopener">issue</a></p><blockquote><p>Indeed in the 1.14 release contanerd replaced dockerd.</p></blockquote><p>要么使用私有仓库 registry，要么手动把 docker 镜像导入到 containerd。microk8s 官网提供了例子：<a href="https://microk8s.io/docs/working" target="_blank" rel="noopener">Working with locally built images without a registry</a>。 这里先使用手动操作，以后再建立私有仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save k8s.gcr.io/pause:3.1 &gt; pause.tar</span><br><span class="line">microk8s.ctr -n k8s.io image import pause.tar</span><br></pre></td></tr></table></figure><p><code>-n</code> 是指定 namespace。<code>microk8s.ctr -n k8s.io image ls</code>，看到导入的镜像了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k8s.gcr.io/pause:3.1                                                                             application/vnd.oci.image.manifest.v1+json                sha256:3efe4ff64c93123e1217b0ad6d23b4c87a1fc2109afeff55d2f27d70c55d8f73 728.9 KiB linux/amd64 io.cri-containerd.image=managed</span><br></pre></td></tr></table></figure><p>其他组件如果遇到gcr.io无法访问的情况也可使用如上的方法，这里特别写了个脚本来自动下载并导入这些镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">echo ""</span><br><span class="line">echo "=========================================================="</span><br><span class="line">echo "pull microk8s v1.15.11 images from gcr.azk8s.cn ..."</span><br><span class="line">echo "=========================================================="</span><br><span class="line">echo ""</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gcr_imgs=(</span><br><span class="line">    "gcr.azk8s.cn/google_containers/pause:3.1,k8s.gcr.io/pause:3.1"</span><br><span class="line">    "gcr.azk8s.cn/google_containers/heapster-influxdb-amd64:v1.3.3,k8s.gcr.io/heapster-influxdb-amd64:v1.3.3"</span><br><span class="line">    "gcr.azk8s.cn/google_containers/heapster-grafana-amd64:v4.4.3,k8s.gcr.io/heapster-grafana-amd64:v4.4.3"</span><br><span class="line">    "gcr.azk8s.cn/google_containers/kubernetes-dashboard-amd64:v1.10.1,k8s.gcr.io/google_containers/kubernetes-dashboard-amd64:v1.10.1"</span><br><span class="line">    "gcr.azk8s.cn/google_containers/heapster-amd64:v1.5.2,k8s.gcr.io/heapster-amd64:v1.5.2"</span><br><span class="line">    "gcr.azk8s.cn/google_containers/defaultbackend-amd64:1.4,gcr.io/google_containers/defaultbackend-amd64:1.4"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for img in $&#123;gcr_imgs[@]&#125;</span><br><span class="line">do</span><br><span class="line">    img_array=($&#123;img//,/ &#125;)</span><br><span class="line">    # 拉取镜像</span><br><span class="line">    docker pull $&#123;img_array[0]&#125;</span><br><span class="line">    # 添加Tag</span><br><span class="line">    docker tag $&#123;img_array[0]&#125; $&#123;img_array[1]&#125;</span><br><span class="line">    # 输出</span><br><span class="line">    docker save $&#123;img_array[1]&#125; &gt; $&#123;img_array[1]##*/&#125;.tar</span><br><span class="line">    # 输入</span><br><span class="line">    microk8s.ctr -n k8s.io image import $&#123;img_array[1]##*/&#125;.tar</span><br><span class="line">    # 删除Tag</span><br><span class="line">    docker rmi $&#123;img_array[0]&#125; $&#123;img_array[1]&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo ""</span><br><span class="line">echo "=========================================================="</span><br><span class="line">echo "pull microk8s  v1.15.11 images from gcr.azk8s.cn finished."</span><br><span class="line">echo "=========================================================="</span><br><span class="line">echo ""</span><br></pre></td></tr></table></figure><p>使用 <code>microk8s.kubectl get pods --all-namespaces</code> 继续进行验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NAMESPACE            NAME                                                           READY   STATUS             RESTARTS   AGE</span><br><span class="line">cert-manager         cert-manager-5d849b9888-8nh9j                                  1/1     Running            12         3d18h</span><br><span class="line">cert-manager         cert-manager-cainjector-dccb4d7f-7rrkf                         1/1     Running            15         3d</span><br><span class="line">cert-manager         cert-manager-webhook-695df7dbb-gpsqs                           1/1     Running            12         3d18h</span><br><span class="line">container-registry   registry-6c99589dc-gttcq                                       1/1     Running            15         4d4h</span><br><span class="line">default              default-http-backend-5d5ff5d4f5-g9h8h                          1/1     Running            15         4d4h</span><br><span class="line">default              nginx-ingress-microk8s-controller-td2mz                        1/1     Running   59         3h26m</span><br><span class="line">istio-system         cluster-local-gateway-7bf56777fb-rbjjn                         1/1     Running            12         3d18h</span><br><span class="line">istio-system         grafana-6575997f54-j77rc                                       1/1     Running            6          3d</span><br><span class="line">istio-system         istio-citadel-894d98c85-xr8qm                                  1/1     Running            12         3d19h</span><br><span class="line">istio-system         istio-cleanup-secrets-1.2.2-l4djr                              0/1     Completed          0          3d19h</span><br><span class="line">istio-system         istio-egressgateway-9b7866bf5-h8ltc                            1/1     Running            10         3d</span><br><span class="line">istio-system         istio-galley-5b984f89b-w26n9                                   1/1     Running            0          6h43m</span><br><span class="line">istio-system         istio-grafana-post-install-1.2.2-v5sfg                         0/1     Completed          0          3d19h</span><br><span class="line">istio-system         istio-ingressgateway-75ddf64567-glfkm                          1/1     Running            12         3d19h</span><br><span class="line">istio-system         istio-pilot-5d77c559d4-nhc7d                                   2/2     Running            14         3d</span><br><span class="line">istio-system         istio-policy-86478df5d4-w2lgb                                  2/2     Running            46         3d</span><br><span class="line">istio-system         istio-security-post-install-1.2.2-sczrc                        0/1     Completed          0          3d19h</span><br><span class="line">istio-system         istio-sidecar-injector-7b98dd6bcc-g597g                        1/1     Running            8          3d</span><br><span class="line">istio-system         istio-telemetry-786747687f-t8k6k                               2/2     Running            35         3d</span><br><span class="line">istio-system         istio-tracing-555cf644d-4d9f4                                  1/1     Running            13         3d19h</span><br><span class="line">istio-system         kfserving-ingressgateway-64c7bd9b76-2rcxt                      1/1     Running            12         3d18h</span><br><span class="line">istio-system         kiali-6cd6f9dfb5-tlwzq                                         1/1     Running            13         3d19h</span><br><span class="line">istio-system         prometheus-7d7b9f7844-swqf8                                    1/1     Running            19         3d19h</span><br><span class="line">kube-system          coredns-f7867546d-wkv76                                        1/1     Running            15         4d4h</span><br><span class="line">kube-system          heapster-v1.5.2-844b564688-kr9t8                               4/4     Running            60         4d4h</span><br><span class="line">kube-system          hostpath-provisioner-65cfd8595b-rjlhz                          1/1     Running            5          3d</span><br><span class="line">kube-system          kubernetes-dashboard-7d75c474bb-s7n2t                          1/1     Running            15         4d4h</span><br><span class="line">kube-system          monitoring-influxdb-grafana-v4-6b6954958c-spcqb                2/2     Running            32         4d4h</span><br><span class="line">kube-system          nvidia-device-plugin-daemonset-jv96f                           1/1     Running            14         3d23h</span><br></pre></td></tr></table></figure><p>如果你看到的结果类似上面这样，说明 Kubernetes 是真的就绪了。</p><h4 id="查看-Dashboard"><a href="#查看-Dashboard" class="headerlink" title="查看 Dashboard"></a>查看 Dashboard</h4><p><code>microk8s.kubectl describe service kubernetes-dashboard -n kube-system</code>获取访问ip和端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Name:              kubernetes-dashboard</span><br><span class="line">Namespace:         kube-system</span><br><span class="line">Labels:            k8s-app=kubernetes-dashboard</span><br><span class="line">Annotations:       kubectl.kubernetes.io/last-applied-configuration:</span><br><span class="line">                     &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;labels&quot;:&#123;&quot;k8s-app&quot;:&quot;kubernetes-dashboard&quot;&#125;,&quot;name&quot;:&quot;kubernetes-dashboard&quot;...</span><br><span class="line">Selector:          k8s-app=kubernetes-dashboard</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.152.183.151</span><br><span class="line">Port:              &lt;unset&gt;  443/TCP</span><br></pre></td></tr></table></figure><p>接着访问下面的地址，就能看到我们熟悉的 Dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://10.152.183.151/</span><br></pre></td></tr></table></figure><p><img src="/images/media/选区_051.png" alt></p><h4 id="使用令牌登录"><a href="#使用令牌登录" class="headerlink" title="使用令牌登录"></a>使用令牌登录</h4><p>获取token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">token=$(microk8s kubectl -n kube-system get secret | grep default-token | cut -d " " -f1)</span><br><span class="line"> echo $token</span><br><span class="line">microk8s kubectl -n kube-system describe secret $token</span><br></pre></td></tr></table></figure><p>输入token后就进入管理页面了</p><p><img src="/images/media/选区_052.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://microk8s.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Microk8s&lt;/a&gt;是一个集成化的容器管理平台，与Kubernetes完全兼容，主要面向工作站、边缘计算和IoT等领域建立容器计算平台。&lt;/p&gt;
    
    </summary>
    
      <category term="k8s" scheme="https://smartliby.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="https://smartliby.github.io/tags/k8s/"/>
    
      <category term="microk8s" scheme="https://smartliby.github.io/tags/microk8s/"/>
    
  </entry>
  
  <entry>
    <title>Mac、Ubuntu系统的下载神器aria2</title>
    <link href="https://smartliby.github.io/2019/05/12/Mac%E3%80%81Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%A5%9E%E5%99%A8aria2/"/>
    <id>https://smartliby.github.io/2019/05/12/Mac、Ubuntu系统的下载神器aria2/</id>
    <published>2019-05-12T10:21:11.000Z</published>
    <updated>2019-05-16T13:48:00.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Mac 用户肯定都受够了百度网盘在自己电脑上的糟糕体验，至少我是如此：安装官方的 App，经常下载时中断，有时甚至 Bug 般连续中断，无奈使用浏览器下载，速度却是令人挠头。花点时间来配置 aria2，结合 Chrome，一定让你舒心</p><a id="more"></a><blockquote><p>aria2 是什么？</p></blockquote><p>aria2 是一款支持多种协议的轻量级命令行下载工具。有以下特性：</p><ul><li>多线程连线：aria2 会自动从多个线程下载文件，并充分利用你的带宽；</li><li>轻量：运行时不会占用过多资源，根据官方介绍，内存占用通常在 4MB~9MB，使用 BitTorrent 协议，下行速度 2.8MB/s 时 CPU 占用率约 6%；</li><li>全功能 BitTorrent 客户端；</li><li>支持 RPC 界面远程控制（下文重点介绍）。</li></ul><blockquote><p>开始吧</p></blockquote><h1 id="1-安装-aria2"><a href="#1-安装-aria2" class="headerlink" title="1.安装 aria2"></a>1.安装 aria2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install aria2</span><br></pre></td></tr></table></figure><h1 id="2-设置配置文件"><a href="#2-设置配置文件" class="headerlink" title="2.设置配置文件"></a>2.设置配置文件</h1><p>aria2 提供两种方式使用，一种是直接命令行模式下载，不推荐使用这种方法，推荐使用另外一种 RPC 模式，这种方式 aria 启动之后只会安静的等待下载请求，下载完成后也只会安静的驻留后台不会自动退出。而使用RPC模式推荐做一个配置文件方便使用。我们把配置文件放在 ~/.aria2 下，依次输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .aria2</span><br><span class="line">cd .aria2</span><br><span class="line">vim aria2.conf</span><br></pre></td></tr></table></figure><p>复制以下内容到aria2.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#用户名</span><br><span class="line">#rpc-user=user</span><br><span class="line">#密码</span><br><span class="line">#rpc-passwd=passwd</span><br><span class="line">#上面的认证方式不建议使用,建议使用下面的token方式</span><br><span class="line">#设置加密的密钥</span><br><span class="line">#rpc-secret=token</span><br><span class="line">#允许rpc</span><br><span class="line">enable-rpc=true</span><br><span class="line">#允许所有来源, web界面跨域权限需要</span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line">#允许外部访问，false的话只监听本地端口</span><br><span class="line">rpc-listen-all=true</span><br><span class="line">#RPC端口, 仅当默认端口被占用时修改</span><br><span class="line">#rpc-listen-port=6800</span><br><span class="line">#最大同时下载数(任务数), 路由建议值: 3</span><br><span class="line">max-concurrent-downloads=5</span><br><span class="line">#断点续传</span><br><span class="line">continue=true</span><br><span class="line">#同服务器连接数</span><br><span class="line">max-connection-per-server=5</span><br><span class="line">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span><br><span class="line">min-split-size=10M</span><br><span class="line">#单文件最大线程数, 路由建议值: 5</span><br><span class="line">split=10</span><br><span class="line">#下载速度限制</span><br><span class="line">max-overall-download-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-download-limit=0</span><br><span class="line">#上传速度限制</span><br><span class="line">max-overall-upload-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-upload-limit=0</span><br><span class="line">#断开速度过慢的连接</span><br><span class="line">#lowest-speed-limit=0</span><br><span class="line">#验证用，需要1.16.1之后的release版本</span><br><span class="line">#referer=*</span><br><span class="line">#文件保存路径, 默认为当前启动位置</span><br><span class="line">dir=/Users/xxx/Downloads</span><br><span class="line">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span><br><span class="line">#disk-cache=0</span><br><span class="line">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span><br><span class="line">#enable-mmap=true</span><br><span class="line">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span><br><span class="line">#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持</span><br><span class="line">file-allocation=prealloc</span><br></pre></td></tr></table></figure><p>默认下载路径的「/Users/xxx/Downloads」可以改为任何你想要的绝对路径。此处写为 Downloads 目录，xxx 请自行替换成你的 Mac 用户名，然后保存，退出编辑器。</p><h1 id="3-启动-RPC-模式"><a href="#3-启动-RPC-模式" class="headerlink" title="3.启动 RPC 模式"></a>3.启动 RPC 模式</h1><p>在终端输入aria2c –conf-path=”/Users/xxxxxx/.aria2/aria2.conf” -D，然后 aria2 就启动了，但是如何搞定百度网盘？还需要在Chrome网上应用商店下载百度网盘助手插件。</p><h1 id="4-访问webUI"><a href="#4-访问webUI" class="headerlink" title="4.访问webUI"></a>4.访问webUI</h1><p>首先从github中克隆webui-aria2项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ziahamza/webui-aria2</span><br></pre></td></tr></table></figure><ul><li>方法一：不需创建任何 web 服务器，只需直接双击运行 index.html</li><li><p>方法二：在终端执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 6801</span><br></pre></td></tr></table></figure></li></ul><p>  在浏览器中访问<a href="http://localhost:6801" target="_blank" rel="noopener">http://localhost:6801</a> 即可</p><h1 id="5-如何进行下载操作"><a href="#5-如何进行下载操作" class="headerlink" title="5.如何进行下载操作"></a>5.如何进行下载操作</h1><p>随便打开一个百度网盘的链接，会发现网页上多出一个「导出下载」按钮，点击它弹出的「ARIA2 RPC」就自动添加到你的下载队列里了，然后利用 这里 提供的网页界面管理你的下载任务，如下图所示，你可以利用图形界面进行许多操作：<br><img src="/images/media/aria2.png" alt="aria2"></p><h1 id="6-关闭-aria2"><a href="#6-关闭-aria2" class="headerlink" title="6.关闭 aria2"></a>6.关闭 aria2</h1><p>如果你想关掉后台的 aria2，可以到活动监视器中找到 aria2c 杀掉</p><h1 id="7-设置aria2开机自动启动"><a href="#7-设置aria2开机自动启动" class="headerlink" title="7.设置aria2开机自动启动"></a>7.设置aria2开机自动启动</h1><p>在家目录 <code>/Users/liby/</code> 执行 <code>vim aria2-starter</code>,然后添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">aria2c --conf-path=&quot;/Users/liby/.aria2/aria2.conf&quot; -D</span><br><span class="line">nohup python -m SimpleHTTPServer 6801 &amp;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>设置该脚本为可执行文件<br>最后在 <code>系统偏好设置</code>-&gt;<code>用户与组群</code>-&gt;<code>登录项</code> 添加该执行脚本</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h1><p>通过 Aria2 下载后，速度一般可达300KB以上，如果不用，同一个文件可能才只有几十或者100K左右的速度，这个差别真是非常大啊！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Mac 用户肯定都受够了百度网盘在自己电脑上的糟糕体验，至少我是如此：安装官方的 App，经常下载时中断，有时甚至 Bug 般连续中断，无奈使用浏览器下载，速度却是令人挠头。花点时间来配置 aria2，结合 Chrome，一定让你舒心&lt;/p&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="https://smartliby.github.io/categories/Ubuntu/"/>
    
    
      <category term="aria2" scheme="https://smartliby.github.io/tags/aria2/"/>
    
      <category term="系统设置" scheme="https://smartliby.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04系统工作环境设置</title>
    <link href="https://smartliby.github.io/2017/03/11/Ubuntu16-04%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
    <id>https://smartliby.github.io/2017/03/11/Ubuntu16-04系统工作环境设置/</id>
    <published>2017-03-11T14:06:39.000Z</published>
    <updated>2019-04-22T15:23:58.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h1><p>1.执行以下命令安装Flatabulous主题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install unity-tweak-tool</span><br><span class="line">sudo add-apt-repository ppa:noobslab/themes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install flatabulous-theme</span><br></pre></td></tr></table></figure><a id="more"></a><p>2.该主题有配套的图标，安装方式如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/icons</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ultra-flat-icons</span><br></pre></td></tr></table></figure><p>3.安装完成后，打开unity-tweak-tool软件，修改主题和图标<br><img src="/images/media/选区_026.png" alt="选区_026"></p><p>4.进入Theme，修改为Flatabulous<br><img src="/images/media/Unity Tweak Tool_027.png" alt="Unity Tweak Tool_027"></p><p>5.在此界面下进入Icons栏，修改为Ultra-flat<br><img src="/images/media/Unity Tweak Tool_028.png" alt="Unity Tweak Tool_028"></p><p>6.安装字体YaHei Consolas Hybrid</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要想安装这款字体，首先需要安装 Font Manager (字体管理)软件。</span><br><span class="line">sudo apt-get install font-manager</span><br><span class="line">google搜索 YaHei.Consolas 下载这款字体。</span><br><span class="line">在 Font Manager 中点击 Manager Fonts - Install Fonts ，就可以安装 ttf 字体了。</span><br></pre></td></tr></table></figure><h1 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><h1 id="安装-maximum-awesome-linux"><a href="#安装-maximum-awesome-linux" class="headerlink" title="安装 maximum-awesome-linux"></a>安装 maximum-awesome-linux</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/smartliby/maximum-awesome-linux.git</span><br><span class="line">cd maximum-awesome-linux &amp;&amp; rake</span><br></pre></td></tr></table></figure><p><img src="/images/media/工作区 1_040.png" alt="工作区 1_040"></p><h1 id="安装zsh、oh-my-zsh"><a href="#安装zsh、oh-my-zsh" class="headerlink" title="安装zsh、oh-my-zsh"></a>安装zsh、oh-my-zsh</h1><p>安装zsh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><p>via curl download Oh My Zsh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>切换到zsh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /usr/bin/zsh</span><br></pre></td></tr></table></figure><p><img src="/images/media/liby@kingsoft:%20~_031.png" alt="liby@kingsoft: ~_031"></p><h1 id="安装terminator"><a href="#安装terminator" class="headerlink" title="安装terminator"></a>安装terminator</h1><p>Ubuntu自带的终端是gnome-terminal，虽然也还不错，但是不能支持屏幕分割、选择复制等功能让我很不爽，于是我换用terminator作为终端，terminator可以支持屏幕分割，并且默认快捷键和gnome-terminal无异，熟悉gnome-terminal的话可以快速上手。</p><p>Ubuntu下可以这样安装terminator</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install terminator</span><br></pre></td></tr></table></figure><p>terminator常用快捷键</p><ul><li>Ctrl-Shift-c 拷贝</li><li>Ctrl-Shift-v 粘贴</li><li>Ctrl-Shift-t 开新Tab窗口</li><li>Ctrl-Shift-o 上下拆分屏幕</li><li>Ctrl-Shift-e 左右拆分屏幕</li><li>Ctrl-Shift-w 关闭当前窗口</li><li>Ctrl-Shift-q 关闭整个终端</li></ul><p>配置terminator使用solarized配色</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/terminator/</span><br><span class="line">curl https://raw.github.com/ghuntley/terminator-solarized/master/config &gt; ~/.config/terminator/config</span><br></pre></td></tr></table></figure><p>然后重新打开terminator就已经是solarized配色了。</p><p>对terminator更多的配置</p><p>接下来，可以在terminator-solarized配置文件的基础上进行更多的配置，例如背景透明、启用选择复制等。</p><p>关于terminator的详细配置选项可以参考<a href="http://manpages.ubuntu.com/manpages/zesty/en/man5/terminator_config.5.html" target="_blank" rel="noopener">terminator manpage</a>，下面贴出我的~/.config/terminator/config供参考：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[global_config]</span><br><span class="line">    title_transmit_bg_color = <span class="string">"#d30102"</span></span><br><span class="line">    focus = system</span><br><span class="line">    suppress_multiple_term_dialog = True</span><br><span class="line">[keybindings]</span><br><span class="line">[profiles]</span><br><span class="line">    [[default]]</span><br><span class="line">        palette = <span class="string">"#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3"</span></span><br><span class="line">        copy_on_selection = True</span><br><span class="line">        background_image = None</span><br><span class="line">        background_darkness = 0.95</span><br><span class="line">        background_type = transparent</span><br><span class="line">        use_system_font = False</span><br><span class="line">        cursor_color = <span class="string">"#eee8d5"</span></span><br><span class="line">        foreground_color = <span class="string">"#839496"</span></span><br><span class="line">        show_titlebar = False</span><br><span class="line">        font = Monospace 11</span><br><span class="line">        background_color = <span class="string">"#002b36"</span></span><br><span class="line">    [[solarized-dark]]</span><br><span class="line">        palette = <span class="string">"#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3"</span></span><br><span class="line">        background_color = <span class="string">"#002b36"</span></span><br><span class="line">        background_image = None</span><br><span class="line">        cursor_color = <span class="string">"#eee8d5"</span></span><br><span class="line">        foreground_color = <span class="string">"#839496"</span></span><br><span class="line">    [[solarized-light]]</span><br><span class="line">        palette = <span class="string">"#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3"</span></span><br><span class="line">        background_color = <span class="string">"#fdf6e3"</span></span><br><span class="line">        background_image = None</span><br><span class="line">        cursor_color = <span class="string">"#002b36"</span></span><br><span class="line">        foreground_color = <span class="string">"#657b83"</span></span><br><span class="line">[layouts]</span><br><span class="line">    [[default]]</span><br><span class="line">        [[[child1]]]</span><br><span class="line">            <span class="built_in">type</span> = Terminal</span><br><span class="line">            parent = window0</span><br><span class="line">            profile = default</span><br><span class="line">        [[[window0]]]</span><br><span class="line">            <span class="built_in">type</span> = Window</span><br><span class="line">            parent = <span class="string">""</span></span><br><span class="line">[plugins]</span><br></pre></td></tr></table></figure><p>配置dircolors</p><p>完成上述配置后，你会发现用ls命令查看目录和文件时是一片灰色。这是因为默认情况下solarized各种bright方案基本都是灰色，而系统默认显示目录和文件时多用bright色，此时需要配置dircolors才能显示出彩色的文件和目录。</p><p><a href="https://github.com/seebi/dircolors-solarized" target="_blank" rel="noopener">dircolors-solarized</a>项目提供了适合于solarized的dircolors配色方案，只要选择合适的方案使用就可以了。例如我是用的solarized dark配色，所以可以选择适合这个配色的dircolors.ansi-dark</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.github.com/seebi/dircolors-solarized/master/dircolors.ansi-dark &gt; ~/.dircolors</span><br></pre></td></tr></table></figure><p>然后在~/.zshrc中加入如下配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enable color support of ls and also add handy aliases</span></span><br><span class="line"><span class="keyword">if</span> [ -x /usr/bin/dircolors ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">test</span> -r ~/.dircolors &amp;&amp; <span class="built_in">eval</span> <span class="string">"<span class="variable">$(dircolors -b ~/.dircolors)</span>"</span> || <span class="built_in">eval</span> <span class="string">"<span class="variable">$(dircolors -b)</span>"</span></span><br><span class="line">    <span class="built_in">alias</span> ls=<span class="string">'ls --color=auto'</span></span><br><span class="line">    <span class="comment">#alias dir='dir --color=auto'</span></span><br><span class="line">    <span class="comment">#alias vdir='vdir --color=auto'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alias</span> grep=<span class="string">'grep --color=auto'</span></span><br><span class="line">    <span class="built_in">alias</span> fgrep=<span class="string">'fgrep --color=auto'</span></span><br><span class="line">    <span class="built_in">alias</span> egrep=<span class="string">'egrep --color=auto'</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># some more ls aliases</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -alF'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -A'</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">'ls -CF'</span></span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>后，再执行ls或ll就可以看到彩色的目录或文件了。</p><p>配置完的terminator效果如下：<br><img src="/images/media/工作区 1_045.png" alt="工作区 1_045"></p><h1 id="安装jdk1-8"><a href="#安装jdk1-8" class="headerlink" title="安装jdk1.8"></a>安装jdk1.8</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.下载jdk，因为oracle现在要同意协议才能下载，直接使用wget加链接下载不到，所以要加上前面的那些代码</span><br><span class="line">wget --no-check-certificate --no-cookie --header <span class="string">"Cookie: oraclelicense=accept-securebackup-cookie;"</span> http://download.oracle.com/otn-pub/java/jdk/8u121-b13/jdk-8u121-linux-x64.tar.gz</span><br><span class="line">2.安装jdk</span><br><span class="line">tar -zxvf jdk-8u121-linux-x64.tar.gz</span><br><span class="line">3.设置环境变量 vim /home/liby/.zshrc,添加如下内容</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/liby/<span class="built_in">local</span>/jdk1.8.0_121/</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> MAVEN_HOME=/home/liby/<span class="built_in">local</span>/apache-maven-3.3.9</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">4.刷新配置文件</span><br><span class="line"><span class="built_in">source</span> /home/liby/.zshrc</span><br></pre></td></tr></table></figure><h1 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.下载maven</span><br><span class="line">wget http://mirror.cc.columbia.edu/pub/software/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz</span><br><span class="line">2.安装maven</span><br><span class="line">tar -zxvf apache-maven-3.3.9-bin.tar.gz</span><br><span class="line">3.设置环境变量 vim /home/liby/.zshrc,添加如下内容</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/liby/<span class="built_in">local</span>/jdk1.8.0_121/</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> MAVEN_HOME=/home/liby/<span class="built_in">local</span>/apache-maven-3.3.9</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">4.刷新配置文件</span><br><span class="line"><span class="built_in">source</span> /home/liby/.zshrc</span><br></pre></td></tr></table></figure><h1 id="下载chrome"><a href="#下载chrome" class="headerlink" title="下载chrome"></a>下载chrome</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">sudo dpkg -i google-chrome-stable_current_amd64.deb</span><br><span class="line">登录账号并同步数据</span><br></pre></td></tr></table></figure><h1 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://cdn2.ime.sogou.com/dl/index/1475147394/sogoupinyin_2.1.0.0082_amd64.deb?st=_vb5fHHeRyUHCwduavC5Qw&amp;e=1489585347&amp;fn=sogoupinyin_2.1.0.0082_amd64.deb</span><br><span class="line">sudo dpkg -i sogoupinyin_2.1.0.0082_amd64.deb</span><br></pre></td></tr></table></figure><h1 id="安装virtualbox"><a href="#安装virtualbox" class="headerlink" title="安装virtualbox"></a>安装virtualbox</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.virtualbox.org/virtualbox/5.1.16/virtualbox-5.1_5.1.16-113841~Ubuntu~xenial_amd64.deb</span><br><span class="line">sudo dpkg -i virtualbox-5.1_5.1.16-113841~Ubuntu~xenial_amd64.deb</span><br></pre></td></tr></table></figure><h1 id="安装idea"><a href="#安装idea" class="headerlink" title="安装idea"></a>安装idea</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.jetbrains.8686c.com/idea/ideaIU-2016.3.5.tar.gz</span><br><span class="line">tar -zxvf ideaIU-2016.3.5.tar.gz</span><br><span class="line">安装插件：scala,.ignore,python,Markdown Navigator2.3.2破解版,VisualVM Launcher</span><br></pre></td></tr></table></figure><h1 id="安装pycharm"><a href="#安装pycharm" class="headerlink" title="安装pycharm"></a>安装pycharm</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.jetbrains.8686c.com/python/pycharm-professional-2016.3.2.tar.gz</span><br><span class="line">tar -zxvf pycharm-professional-2016.3.2.tar.gz</span><br><span class="line">安装插件：.ignore,Markdown Navigator2.3.2破解版</span><br></pre></td></tr></table></figure><h1 id="修复idea和pycharm字体模糊锯齿和乱码等现象"><a href="#修复idea和pycharm字体模糊锯齿和乱码等现象" class="headerlink" title="修复idea和pycharm字体模糊锯齿和乱码等现象"></a>修复idea和pycharm字体模糊锯齿和乱码等现象</h1><p>设置字体为YaHei Consolas Hybrid，同时支持中英文<br><img src="/images/media/Settings_033.png" alt="Settings_033"><br><img src="/images/media/Settings_034.png" alt="Settings_034"></p><h1 id="idea与系统冲突的快捷键设置"><a href="#idea与系统冲突的快捷键设置" class="headerlink" title="idea与系统冲突的快捷键设置"></a>idea与系统冲突的快捷键设置</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Change or <span class="built_in">disable</span> the Lock Screen action, assigned to Ctrl + Alt + L (Reformat code)</span><br><span class="line">2.Change or <span class="built_in">disable</span> the Launch terminal action, assigned to Ctrl + Alt + T (Surround with)</span><br><span class="line">3.Change or <span class="built_in">disable</span> the Switch to workspace action, assigned to Ctrl + Alt + Arrow Keys(Navigation)</span><br><span class="line">4.Disable the Move window action, assigned to Alt + F7 (Find usages)</span><br><span class="line">5.Change or <span class="built_in">disable</span> the Resize window action, assigned to Alt + F8 (Evaluate expression)</span><br><span class="line">6.Fcitx输入法激活快捷键，assigned to Ctrl + 空格 (code completion basic)</span><br></pre></td></tr></table></figure><p>解决办法是打开系统设置中的键盘，修改冲突的快捷键，将系统的快捷键禁用或者修改idea快捷键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.修改idea快捷键为Ctrl + L</span><br><span class="line">2.用的地方不多，先不修改了</span><br><span class="line">3.窗口中的移动窗口禁用</span><br><span class="line">4.导航中的切换至左侧工作区/切换至右侧工作区/切换至侧上工作区/切换至下侧工作区禁用</span><br><span class="line">5.窗口中的调整窗口大小禁用</span><br><span class="line">6.禁用Fcitx输入法激活快捷键</span><br></pre></td></tr></table></figure><h1 id="安装atom"><a href="#安装atom" class="headerlink" title="安装atom"></a>安装atom</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://atom-installer.github.com/v1.15.0/atom-amd64.deb?s=1489019656&amp;ext=.deb</span><br><span class="line">sudo dpkg -i atom-amd64.deb</span><br></pre></td></tr></table></figure><p>安装插件：markdown-writer、autocomplete-python、ile-icons、git-control、language-hql、markdown-pdf、pdf-view、activate-power-mode</p><h1 id="安装markdown神器"><a href="#安装markdown神器" class="headerlink" title="安装markdown神器"></a>安装markdown神器</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># optional, but recommended</span></span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line"><span class="comment"># add Typora's repository</span></span><br><span class="line">sudo add-apt-repository <span class="string">'deb https://typora.io ./linux/'</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># install typora</span></span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure><h1 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install shutter</span><br></pre></td></tr></table></figure><h1 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://s1.music.126.net/download/pc/netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb</span><br><span class="line">sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb</span><br><span class="line">登录账号并同步数据</span><br></pre></td></tr></table></figure><h1 id="开启ssh服务，允许远程连接"><a href="#开启ssh服务，允许远程连接" class="headerlink" title="开启ssh服务，允许远程连接"></a>开启ssh服务，允许远程连接</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">这样其他的电脑就可以ssh登录公司的这台电脑了</span><br></pre></td></tr></table></figure><h1 id="开启远程桌面服务"><a href="#开启远程桌面服务" class="headerlink" title="开启远程桌面服务"></a>开启远程桌面服务</h1><p> 1.Dash中打开桌面共享<br> <img src="/images/media/桌面共享首选项_029.png" alt="桌面共享首选项_029"></p><p> 2.安装并运行dconf-editor，把加密选项去掉</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dconf-editor</span><br><span class="line">dconf-editor</span><br></pre></td></tr></table></figure><p>依次展开org-&gt;gnome-&gt;desktop-&gt;remote-access<br>这里也可以直接设置远程控制选项，但重要的是将“requre-encryption”去掉。<br><img src="/images/media/dconf 系统配置编辑器_030.png" alt="dconf 系统配置编辑器_030"></p><p>之后就可以在其他的电脑上使用远程桌面登录了</p><h1 id="16-04默认没有打开工作区切换功能需要手动打开，使用起来方便多了。"><a href="#16-04默认没有打开工作区切换功能需要手动打开，使用起来方便多了。" class="headerlink" title="16.04默认没有打开工作区切换功能需要手动打开，使用起来方便多了。"></a>16.04默认没有打开工作区切换功能需要手动打开，使用起来方便多了。</h1><p><img src="/images/media/Unity Tweak Tool_039.png" alt="Unity Tweak Tool_039"><br><img src="/images/media/工作区_041.png" alt="工作区_041"></p><h1 id="最终的效果图"><a href="#最终的效果图" class="headerlink" title="最终的效果图"></a>最终的效果图</h1><p><img src="/images/media/工作区 1_076.png" alt="工作区 1_043"><br><img src="/images/media/工作区 1_077.png" alt="工作区 1_044"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;主题美化&quot;&gt;&lt;a href=&quot;#主题美化&quot; class=&quot;headerlink&quot; title=&quot;主题美化&quot;&gt;&lt;/a&gt;主题美化&lt;/h1&gt;&lt;p&gt;1.执行以下命令安装Flatabulous主题&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install unity-tweak-tool&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo add-apt-repository ppa:noobslab/themes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install flatabulous-theme&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="https://smartliby.github.io/categories/Ubuntu/"/>
    
    
      <category term="系统设置" scheme="https://smartliby.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE/"/>
    
      <category term="Linux" scheme="https://smartliby.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Flume1.7源码调试</title>
    <link href="https://smartliby.github.io/2017/02/14/Flume1-7%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/"/>
    <id>https://smartliby.github.io/2017/02/14/Flume1-7源码调试/</id>
    <published>2017-02-14T11:02:40.000Z</published>
    <updated>2019-04-22T15:23:58.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p>git clone <a href="https://github.com/apache/flume.git" target="_blank" rel="noopener">https://github.com/apache/flume.git</a></p><a id="more"></a><h1 id="将源码导入Idea"><a href="#将源码导入Idea" class="headerlink" title="将源码导入Idea"></a>将源码导入Idea</h1><p><img src="/images/media/选区_021.png" alt="选区_021"></p><h1 id="编译时会有以下jar仓库中无法找到并下载，需要手动下载到本地仓库"><a href="#编译时会有以下jar仓库中无法找到并下载，需要手动下载到本地仓库" class="headerlink" title="编译时会有以下jar仓库中无法找到并下载，需要手动下载到本地仓库"></a>编译时会有以下jar仓库中无法找到并下载，需要手动下载到本地仓库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linq4j-0.4.jar  pentaho-aggdesigner-algorithm-5.1.3-jhyde.jar  quidem-0.1.1.jar</span><br></pre></td></tr></table></figure><p>以上jar文件可以在下面的网站中找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://conjars.org/repo/</span><br><span class="line">http://repository.pentaho.org/artifactory/repo/</span><br></pre></td></tr></table></figure><p>执行下面的命令将jar下载到本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=pentaho-aggdesigner-algorithm-5.1.3-jhyde.jar -DgroupId=org.pentaho -DartifactId=pentaho-aggdesigner-algorithm -Dversion=5.1.3-jhyde -Dpackaging=jar</span><br><span class="line">mvn install:install-file -Dfile=linq4j-0.4.jar -DgroupId=net.hydromatic -DartifactId=linq4j -Dversion=0.4 -Dpackaging=jar</span><br><span class="line">mvn install:install-file -Dfile=quidem-0.1.1.jar -DgroupId=net.hydromatic -DartifactId=quidem -Dversion=0.1.1 -Dpackaging=jar</span><br></pre></td></tr></table></figure><h1 id="执行编译命令"><a href="#执行编译命令" class="headerlink" title="执行编译命令"></a>执行编译命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests</span><br></pre></td></tr></table></figure><p><img src="/images/media/选区_022.png" alt="选区_022"></p><h1 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主类：org.apache.flume.node.Application</span><br><span class="line">参数：-n agent -f /home/liby/local/apache-flume-1.7.0-bin/conf/flume-conf.properties</span><br></pre></td></tr></table></figure><p>flume-conf.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Name the components on this agent</span></span><br><span class="line">agent.sources = r1</span><br><span class="line">agent.sinks = k1</span><br><span class="line">agent.channels = c1</span><br><span class="line"><span class="comment"># Describe/configure the source</span></span><br><span class="line">agent.sources.r1.type = netcat</span><br><span class="line">agent.sources.r1.bind = localhost</span><br><span class="line">agent.sources.r1.port = 44445</span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line"><span class="comment"># 将数据输出至日志中</span></span><br><span class="line">agent.sinks.k1.type = logger</span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line">agent.channels.c1.type = memory</span><br><span class="line">agent.channels.c1.capacity = 1000</span><br><span class="line">agent.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">agent.sources.r1.channels = c1</span><br><span class="line">agent.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><p><img src="/images/media/选区_023.png" alt="选区_023"></p><p>运行效果<br><img src="/images/media/选区_024.png" alt="选区_024"></p><h1 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h1><p>在conf/flume-env.properties增加以下配置，然后启动flume</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure><p>在idea中启动远程调试<br><img src="/images/media/选区_025.png" alt="选区_025"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;下载源码&quot;&gt;&lt;a href=&quot;#下载源码&quot; class=&quot;headerlink&quot; title=&quot;下载源码&quot;&gt;&lt;/a&gt;下载源码&lt;/h1&gt;&lt;p&gt;git clone &lt;a href=&quot;https://github.com/apache/flume.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/apache/flume.git&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flume" scheme="https://smartliby.github.io/categories/Flume/"/>
    
    
      <category term="Flume" scheme="https://smartliby.github.io/tags/Flume/"/>
    
  </entry>
  
  <entry>
    <title>java字符编码浅析</title>
    <link href="https://smartliby.github.io/2016/07/14/java%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://smartliby.github.io/2016/07/14/java字符编码浅析/</id>
    <published>2016-07-14T11:24:13.000Z</published>
    <updated>2019-04-22T15:23:58.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java字符编码浅析"><a href="#java字符编码浅析" class="headerlink" title="java字符编码浅析"></a>java字符编码浅析</h1><blockquote><p>关于这篇文章其实是从一个问题开始的：java中char类型能存储汉字吗？</p></blockquote><h2 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h2><p>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>UTF-8的编码规则很简单，只有二条：</p><a id="more"></a><p>1.对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2.对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。<br>下表总结了编码规则，字母x表示可用编码的位。</p><table><thead><tr><th>Unicode符号范围(十六进制)</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>0000 0000-0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080-0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800-0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000-0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。<br>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。<br>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</p><h2 id="UTF-16编码"><a href="#UTF-16编码" class="headerlink" title="UTF-16编码"></a>UTF-16编码</h2><p>UTF-16是Unicode的其中一个使用方式。 UTF是 Unicode TransferFormat，即把Unicode转做某种格式的意思。UTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节 (2字节) 储存，但UTF-16却无法兼容于ASCII编码。UTF-16的大端和小端储存形式都在用。为了弄清楚UTF-16文件的大小端，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。</p><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;I&apos;m 李博玉&quot;;</span><br><span class="line">byte[] charArr = s.getBytes(Charset.forName(&quot;UTF-16&quot;));</span><br><span class="line">for (byte b : charArr) &#123;</span><br><span class="line">System.out.printf(&quot;%X &quot;, b);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s.getBytes(Charset.forName(&quot;UTF-16&quot;)).length);</span><br><span class="line"></span><br><span class="line">charArr = s.getBytes(Charset.forName(&quot;UTF-8&quot;));</span><br><span class="line">for (byte b : charArr) &#123;</span><br><span class="line">System.out.printf(&quot;%X &quot;, b);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s.getBytes(Charset.forName(&quot;UTF-8&quot;)).length);</span><br></pre></td></tr></table></figure><p>输出的结果是什么呢？<br>FE FF 0 49 0 27 0 6D 0 20 67 4E 53 5A 73 89<br>16<br>49 27 6D 20 E6 9D 8E E5 8D 9A E7 8E 89<br>13</p><p>1.UTF-16的编码为什么是16？<br>对于大部分字符来讲，UTF-16都使用两个字节来存储。但是UTF-16是支持大小端的，所以需要在字符的开头使用两个字节的额外空间指定好它的字节序，FE FF 表示使用大端存储。<br>7 x 2 + 2 = 16<br>2.UTF-8的编码为什么是13？<br>UTF-8是完全兼容ASCII编码的，所以英文是占一个字节，中文大部分占3个字节，不常用的占4个字节<br>4 + 3 x 3 = 13</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>String s1 = “李”;<br>String s2 = “<img src="/images/media/14707129240405.jpg" alt>“<br>System.out.println(s1.length());<br>System.out.println(s2.length());</p><p>输出的结果是什么呢？<br>1<br>2<br>看到这个结果是不是崩溃了，到底怎么回事？</p><p>1.首先要明白.length指的是什么，String内部是以char数组的形式存储的，.length是指char数组的长度，char是以UTF-16编码的，李是常用字，UTF-16编码后占两个字节，一个char就能够存储，所以是长度是1，而<img src="/images/media/14707129334632.jpg" alt>UTF-16编码后占四个字节，两个char来存储，所以长度是2</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java字符编码浅析&quot;&gt;&lt;a href=&quot;#java字符编码浅析&quot; class=&quot;headerlink&quot; title=&quot;java字符编码浅析&quot;&gt;&lt;/a&gt;java字符编码浅析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;关于这篇文章其实是从一个问题开始的：java中char类型能存储汉字吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;UTF-8编码&quot;&gt;&lt;a href=&quot;#UTF-8编码&quot; class=&quot;headerlink&quot; title=&quot;UTF-8编码&quot;&gt;&lt;/a&gt;UTF-8编码&lt;/h2&gt;&lt;p&gt;UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。&lt;br&gt;UTF-8的编码规则很简单，只有二条：&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://smartliby.github.io/categories/java/"/>
    
    
      <category term="字符编码" scheme="https://smartliby.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>设计模式19之 迭代器(Iterator)模式(行为模式)</title>
    <link href="https://smartliby.github.io/2014/06/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19%E4%B9%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/06/03/设计模式19之-迭代器-Iterator-模式-行为模式/</id>
    <published>2014-06-03T03:11:08.000Z</published>
    <updated>2019-04-22T15:23:58.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器模式简介"><a href="#迭代器模式简介" class="headerlink" title="迭代器模式简介"></a>迭代器模式简介</h1><p>　　迭代器模式又叫游标(Cursor)模式，是对象的行为模式。迭代器模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation）。</p><p>　　迭代器模式是设计模式中最常见的几个模式之一。在Java的集合(Collection)框架中，广泛的使用迭代器(Iterator和Enumeration)来遍历集合的元素。</p><a id="more"></a><p>迭代器模式涉及到以下几个角色：<strong>抽象迭代器(Iterator)，具体迭代器(ConcreteIterator)，聚集(Aggregate)，具体聚集(ConcreteAggregate)，客户端(Client)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象迭代器</td><td>此抽象角色定义出遍历元素所需的接口。</td></tr><tr><td>具体迭代器</td><td>此角色实现了抽象迭代器的接口，并保持迭代过程中的游标位置。</td></tr><tr><td>聚集</td><td>此抽象角色给出创建迭代器(Iterator)对象的接口。</td></tr><tr><td>具体聚集</td><td>实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。</td></tr><tr><td>客户端</td><td>持有对聚集及其迭代器对象的引用，调用迭代器对象的迭代接口，也有可能通过迭代器操作聚集元素的增加和删除。</td></tr></tbody></table><p>　　迭代器模式有两种：<strong>外禀迭代器</strong>和<strong>内禀迭代器</strong>。<br>外禀迭代器 – “具体迭代器”是在”具体聚集”之外实现的。<br>内禀迭代器 – “具体迭代器”是在”具体聚集”里面实现的，”具体迭代器”是”具体聚集”的私有内部类。</p><p>　　在外禀迭代器中，”具体聚集”向外提供了访问聚集中各个元素的接口；而在内禀迭代器中，”具体聚集”包含了内部类”具体迭代器”，这就意味着”具体迭代器”可以直接访问”具体聚集”的成员对象，而不需要通过函数接口去访问。</p><h1 id="外禀迭代器"><a href="#外禀迭代器" class="headerlink" title="外禀迭代器"></a>外禀迭代器</h1><p>　　如果迭代器是在聚集结构之外实现的，这样的迭代器被称为外禀迭代器(Extrinsic Iterator)。</p><p>下面看看”外禀迭代器”中各个角色的代码。</p><h2 id="抽象迭代器类"><a href="#抽象迭代器类" class="headerlink" title="抽象迭代器类"></a>抽象迭代器类</h2><pre><code>public interface Iterator {    // 迭代方法：移动到第一个元素    public void first();    // 迭代方法：移动到下一个元素    public void next();    // 迭代方法：是否为最后一个元素    public boolean isDone();    // 迭代方法：返还当前元素    public Object currentItem();}</code></pre><h2 id="具体迭代器类"><a href="#具体迭代器类" class="headerlink" title="具体迭代器类"></a>具体迭代器类</h2><pre><code>public class ConcreteIterator implements Iterator {    private ConcreteAggregate agg;    // 索引位置    private int index = 0;    // 集合大小    private int size = 0;    public ConcreteIterator(ConcreteAggregate agg){        this.agg = agg;        this.size = agg.size();        index = 0;    }    // 迭代方法：移动到第一个元素    @Override    public void first() {        index = 0;    }    // 迭代方法：是否为最后一个元素    @Override    public boolean isDone() {        return (index &gt;= size);    }    // 迭代方法：移动到下一个元素    @Override    public void next() {        if(index &lt; size) {            index ++;        }    }    // 迭代方法：返还当前元素    @Override    public Object currentItem() {        return agg.getElement(index);    }}</code></pre><h2 id="聚集类"><a href="#聚集类" class="headerlink" title="聚集类"></a>聚集类</h2><pre><code>abstract public class Aggregate {    // 工厂方法：返回迭代器对象    public abstract Iterator createIterator();}</code></pre><h2 id="具体聚集类"><a href="#具体聚集类" class="headerlink" title="具体聚集类"></a>具体聚集类</h2><pre><code>public class ConcreteAggregate extends Aggregate {    private Object[] objs = {&quot;Monk Tang&quot;,        &quot;Monkey&quot;, &quot;Pigsy&quot;,        &quot;Sandy&quot;, &quot;Horse&quot;};    @Override    public Iterator createIterator() {        return new ConcreteIterator(this);    }    // 取值方法：向外界提供聚集元素    public Object getElement(int index){        if(index &lt; objs.length){            return objs[index];        }else{            return null;        }    }    // 取值方法：向外界提供聚集的大小    public int size(){        return objs.length;    }}</code></pre><h2 id="客户端类"><a href="#客户端类" class="headerlink" title="客户端类"></a>客户端类</h2><pre><code>public class Client {    private Iterator it;    private Aggregate agg = new ConcreteAggregate();    public void operation() {        it = agg.createIterator();        while(!it.isDone()) {            System.out.println(it.currentItem());            it.next();        }    }3.4    public static void main(String[] args) {        Client client = new Client();        client.operation();    }}</code></pre><p>运行结果：</p><pre><code>Monk TangMonkeyPigsySandyHorse</code></pre><h1 id="内禀迭代器"><a href="#内禀迭代器" class="headerlink" title="内禀迭代器"></a>内禀迭代器</h1><p>　　如果将”外禀迭代器”中的”具体迭代器”改写成”具体聚集类”的一个私有类，即迭代器是在聚集结构之内实现；这样的迭代器，就被称为内禀迭代器(Intrinsic Iterator)。</p><p>下面看看”内禀迭代器”中各个角色的代码。</p><h2 id="抽象迭代器类-1"><a href="#抽象迭代器类-1" class="headerlink" title="抽象迭代器类"></a>抽象迭代器类</h2><pre><code>public interface Iterator {    // 迭代方法：移动到第一个元素    public void first();    // 迭代方法：移动到下一个元素    public void next();    // 迭代方法：是否为最后一个元素    public boolean isDone();    // 迭代方法：返还当前元素    public Object currentItem();}</code></pre><h2 id="聚集类-1"><a href="#聚集类-1" class="headerlink" title="聚集类"></a>聚集类</h2><pre><code>abstract public class Aggregate {    // 工厂方法：返回迭代器对象    public abstract Iterator createIterator();}</code></pre><h2 id="具体聚集类-1"><a href="#具体聚集类-1" class="headerlink" title="具体聚集类"></a>具体聚集类</h2><pre><code>public class ConcreteAggregate extends Aggregate {    private Object[] objs = {&quot;Monk Tang&quot;,        &quot;Monkey&quot;, &quot;Pigsy&quot;,        &quot;Sandy&quot;, &quot;Horse&quot;};    @Override    public Iterator createIterator() {        return new ConcreteIterator();    }    private class ConcreteIterator            implements Iterator {        // 索引位置        private int index = 0;        // 迭代方法：移动到第一个元素        @Override        public void first() {            index = 0;        }        // 迭代方法：是否为最后一个元素        @Override        public boolean isDone() {            return (index == objs.length);        }        // 迭代方法：移动到下一个元素        @Override        public void next() {            if(index &lt; objs.length) {                index ++;            }        }        // 迭代方法：返还当前元素        @Override        public Object currentItem() {            return objs[index];        }    }}</code></pre><h2 id="客户端类-1"><a href="#客户端类-1" class="headerlink" title="客户端类"></a>客户端类</h2><pre><code>public class Client {    private Iterator it;    private Aggregate agg = new ConcreteAggregate();    public void operation() {        it = agg.createIterator();        while(!it.isDone()) {            System.out.println(it.currentItem());            it.next();        }    }    public static void main(String[] args) {        Client client = new Client();        client.operation();    }}</code></pre><p>运行结果：</p><pre><code>Monk TangMonkeyPigsySandyHorse</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;迭代器模式简介&quot;&gt;&lt;a href=&quot;#迭代器模式简介&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式简介&quot;&gt;&lt;/a&gt;迭代器模式简介&lt;/h1&gt;&lt;p&gt;　　迭代器模式又叫游标(Cursor)模式，是对象的行为模式。迭代器模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation）。&lt;/p&gt;
&lt;p&gt;　　迭代器模式是设计模式中最常见的几个模式之一。在Java的集合(Collection)框架中，广泛的使用迭代器(Iterator和Enumeration)来遍历集合的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="迭代器模式" scheme="https://smartliby.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式18之 观察者(Observer)模式(行为模式)</title>
    <link href="https://smartliby.github.io/2014/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18%E4%B9%8B-%E8%A7%82%E5%AF%9F%E8%80%85-Observer-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/06/02/设计模式18之-观察者-Observer-模式-行为模式/</id>
    <published>2014-06-02T03:10:51.000Z</published>
    <updated>2019-04-22T15:23:58.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式简介"><a href="#观察者模式简介" class="headerlink" title="观察者模式简介"></a>观察者模式简介</h1><p>　观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。<br>　<br>　观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><a id="more"></a><p>　例如，马路上的交通指示灯为红灯亮的话，汽车会停止，行人可以通行。在这个场景中，交通指示等就是被观察者，而行人和汽车则是观察者，他们会根据观察到的交通指示灯的状况作出相应的行为。</p><p>　观察者的UML类图如下：<br><img src="/images/media/pattern18_01.jpg" alt="pattern18_01"></p><p>　　观察者模式所涉及的角色有：<strong>抽象主题(Subject)，具体主题(ConcreteSubject)，抽象观察者(Observer)，具体观察者(ConcreteObserver)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象主题</td><td>抽象主题角色把所有对观察者对象的引用保存在一个集合(比如Vector对象)里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色，一般用一个抽象类或者一个接口实现。</td></tr><tr><td>具体主题</td><td>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。具体主题通常用一个具体子类实现。</td></tr><tr><td>抽象观察者</td><td>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。</td></tr><tr><td>具体观察者</td><td>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。它通常用一个具体子类实现。</td></tr></tbody></table><h2 id="示意代码"><a href="#示意代码" class="headerlink" title="示意代码"></a>示意代码</h2><p>抽象主题类</p><pre><code>import java.util.Vector;import java.util.Enumeration;abstract public class Subject {    private Vector observersVector = new Vector();    // 注册观察者对象    public void attach(Observer observer) {        observersVector.addElement(observer);    }    // 注销观察者对象    public void detach(Observer observer) {        observersVector.removeElement(observer);    }    // 通知所有注册的观察者对象    public void notifyObservers() {        Enumeration enu = observers();        while (enu.hasMoreElements()) {            ((Observer)enu.nextElement()).update();        }    }    public Enumeration observers(){        return ((Vector)observersVector.clone()).elements();    }}</code></pre><p>具体主题类</p><pre><code>public class ConcreteSubject extends Subject{    private String state;    // 改变主题的方法。    public void change(String newState){        state = newState;        this.notifyObservers();    }}</code></pre><p>抽象观察者类</p><pre><code>public interface Observer {    //  通知接口    public void update();}</code></pre><p>具体观察者类</p><pre><code>public class ConcreteObserver implements Observer {    @Override    public void update() {        System.out.println(&quot;I am notified.&quot;);    }}</code></pre><p>客户端类</p><pre><code>public class Client {    private static ConcreteSubject subject;    private static Observer observer;    public static void main(String[] args) {        // 创建主题        subject = new ConcreteSubject();        // 创建观察者        observer = new ConcreteObserver();        // 将观察者注册到&quot;主题&quot;上        subject.attach(observer);        // 改变主题对象的状态        subject.change(&quot;new state&quot;);    }}</code></pre><p>运行结果：</p><pre><code>I am notified.</code></pre><h1 id="Java中的观察者模式"><a href="#Java中的观察者模式" class="headerlink" title="Java中的观察者模式"></a>Java中的观察者模式</h1><p>　　Java语言本身支持”观察者模式”，它提供了相应的”抽象主题类(Observable)”和”抽象观察者类(Observer)”。</p><p>　　Observable是个实例类。它提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p><p>　　Observer是一个接口。它只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p><p>　　下面演示Java中Observer和Observable的用法。</p><p>　　以公鸡打鸣来建模：太阳是被观察者，公鸡是观察者；当公鸡观察到太阳升起的时候，就打鸣。</p><h2 id="太阳"><a href="#太阳" class="headerlink" title="太阳"></a>太阳</h2><p>太阳是被观察者，它继承了Observable。</p><pre><code>import java.util.Observable;public class Sun extends Observable {    public void rise() {        System.out.println(&quot;Sun rise.&quot;);        // 设置&quot;被观察者&quot;的状态标记，表示它发生了变化。        this.setChanged();        // 通知&quot;观察者&quot;该变化。        this.notifyObservers();    }}</code></pre><h2 id="公鸡"><a href="#公鸡" class="headerlink" title="公鸡"></a>公鸡</h2><p>公鸡是观察者，它实现了Observer对象。</p><pre><code>import java.util.Observer;import java.util.Observable;public class Cock implements Observer {    private Sun sun;    public Cock(Sun sun) {        this.sun = sun;        // 将观察者Cock注册到&quot;被观察者sun&quot;上。        sun.addObserver(this);    }    // &quot;被观察者&quot;发生变化时，&quot;观察者&quot;对应的响应方法。    @Override    public void update(Observable o, Object arg) {        System.out.println(&quot;Cock gogoda,gogoda,gogoda...&quot;);    }}</code></pre><h2 id="客户端测试程序"><a href="#客户端测试程序" class="headerlink" title="客户端测试程序"></a>客户端测试程序</h2><pre><code>public class Client {    private static Cock cock;    private static Sun sun;    public static void main(String[] args) {        // 新建&quot;太阳&quot;(被观察者)        sun = new Sun();        // 新建&quot;公鸡&quot;(观察者)        cock = new Cock(sun);        // 太阳升起。公鸡观察到太阳升级后，会打鸣！        sun.rise();    }}</code></pre><p>运行结果：</p><pre><code>Sun rise.Cock gogoda,gogoda,gogoda...</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;观察者模式简介&quot;&gt;&lt;a href=&quot;#观察者模式简介&quot; class=&quot;headerlink&quot; title=&quot;观察者模式简介&quot;&gt;&lt;/a&gt;观察者模式简介&lt;/h1&gt;&lt;p&gt;　观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。&lt;br&gt;　&lt;br&gt;　观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="观察者模式" scheme="https://smartliby.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式17之 模板方法(Template Method)模式(行为模式)</title>
    <link href="https://smartliby.github.io/2014/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17%E4%B9%8B-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95-Template-Method-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/06/01/设计模式17之-模板方法-Template-Method-模式-行为模式/</id>
    <published>2014-06-01T03:10:33.000Z</published>
    <updated>2019-04-22T15:23:58.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板模式简介"><a href="#模板模式简介" class="headerlink" title="模板模式简介"></a>模板模式简介</h1><p>　　模板方法(Template Method)模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。<br>　　模板方法模式是所有模式中最为常见的几个模式之一，而且很可能我们自己使用过模板方法模式而没有意识到自己已经使用了这个模式。模板方法模式是基于继承的代码复用的基本技术。<br>　　Java的集合就是一个典型的，利用了模板方法模式的例子。Java集合中的Collection集合包括List和Set两大组成部分。List是队列，而Set是没有重复元素的集合。它们共同的接口都在Collection接口声明；例如，都包含了size()，isEmpty()方法。而AbstractCollection这个抽象类则实现了它们共同的方法，其余未实现的方法定义为抽象方法。List和Set的实例类，就是通过继承AbstractCollection(或它的子类)，省去了许多重复性编码的工作！</p><a id="more"></a><p>模板方法模式的UML类图：<br><img src="/images/media/pattern17_01.jpg" alt="pattern17_01"></p><p>这里涉及到两个角色：<strong>抽象模板(Abstract Template)，具体模板(Concrete Template)</strong>。</p><p>  抽象模板有如下责任：<br>• 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。<br>• 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p><p>  具体模板有如下责任：<br>• 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。<br>• 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p><p>示意代码</p><pre><code>abstract public class AbstractClass {    // 模板方法    public void templateMethod(){        hookMethod(); //调用基本方法(由子类实现)        abstractMethod(); //调用基本方法(由子类实现)        concreteMethod(); //调用基本方法(已经实现)    }    // 基本方法的声明（由子类实现，但抽象模板给出了默认实现）    public void hookMethod() {}    // 基本方法的声明（由子类实现）    public abstract void abstractMethod();    // 基本方法（已经实现）    public final void concreteMethod(){        // do something    }}public class ConcreteClass extends AbstractClass {    // 基本方法的实现    @Override    public void hookMethod() {        // do something    }    // 基本方法的实现    @Override    public void abstractMethod() {        // do something    }}</code></pre><p>　　抽象模板角色AbstractTemplate提供了两个具体方法templateMethod()和concreteMethod()；声明了2个抽象方法hookMethod()和abstractMethod()。</p><p>　　具体模板角色ConcreteTemplate实现了父类声明的基本方法hookMethod()和abstractMethod()。</p><p><br><br>模板方法模式中的方法</p><p>模板方法中的方法可以分为两大类：<strong>模板方法</strong> 和 <strong>基本方法</strong>。</p><p><strong>模板方法</strong></p><p>一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。<br>一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。</p><p><strong>基本方法</strong></p><p>基本方法又可以分为三种：<strong>抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)</strong>。<br>• 抽象方法: 一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。<br>• 具体方法: 一个具体方法由抽象类声明并实现，而子类并不实现或置换。<br>• 钩子方法: 一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。</p><p>　　在前面的UML示例中，AbstractClass是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。</p><p>提示：钩子方法的名字应当以do开始。</p><h1 id="模板方法模式示例"><a href="#模板方法模式示例" class="headerlink" title="模板方法模式示例"></a>模板方法模式示例</h1><p>　　考虑一个计算存款利息的例子。假设系统需要支持两种存款账号，即货币市场(Money Market)账号和定期存款(Certificate of Deposite)账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同的账号类型。</p><p>　　这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤：一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。</p><p>　　显然，系统需要一个抽象角色给出顶级行为的实现，而将两个作为细节步骤的基本方法留给具体子类实现。由于需要考虑的账号有两种：一是货币市场账号，二是定期存款账号。系统的UML类图如下图所示。</p><h2 id="抽象模板类"><a href="#抽象模板类" class="headerlink" title="抽象模板类"></a>抽象模板类</h2><pre><code>abstract public class Account {    protected String accountNumber;    public Account() {        accountNumber = null;    }    public Account(String accountNumber) {        this.accountNumber = accountNumber;    }    // 模板方法，计算利息数额    public final double calculateInterest(){        double interestRate = doCalculateInterestRate();        String accountType = doCalculateAccountType();        double amount = calculateAmount(accountType, accountNumber);        return amount * interestRate;    }    // 基本方法留给子类实现    protected abstract String doCalculateAccountType();    // 基本方法留给子类实现    protected abstract double doCalculateInterestRate();    // 基本方法，已经实现    private double calculateAmount(String accountType, String accountNumber){        // retrive amount from database        return 7243.00D;    }}</code></pre><h2 id="具体模板类"><a href="#具体模板类" class="headerlink" title="具体模板类"></a>具体模板类</h2><p>MoneyMarketAccount</p><pre><code>public class MoneyMarketAccount extends Account {    @Override    protected String doCalculateAccountType() {        return &quot;Money Market&quot;;    }    @Override    protected double doCalculateInterestRate() {        return 0.045D;    }}</code></pre><p>CDAccount</p><pre><code>public class CDAccount extends Account {    @Override    protected String doCalculateAccountType() {        return &quot;Certificate of Deposite&quot;;    }    @Override    protected double doCalculateInterestRate() {        return 0.065D;    }}</code></pre><h2 id="客户端测试程序"><a href="#客户端测试程序" class="headerlink" title="客户端测试程序"></a>客户端测试程序</h2><pre><code>public class Client {    private static Account acct = null;    public static void main(String[] args) {        acct = new MoneyMarketAccount();        System.out.println(&quot;Interest from Money Market account: &quot; + acct.calculateInterest());        acct = new CDAccount();        System.out.println(&quot;Interest from CD account: &quot; + acct.calculateInterest());    }}</code></pre><p>运行结果：</p><pre><code>Interest from Money Market account: 325.935Interest from CD account: 470.795</code></pre><p>结果说明：Account是抽象模板类，calculateInterest()是模板方法。不管是”货币市场帐号”或者”定期存款”，它们的利息计算方式都是通过抽象模板类的calculateInterest()来计算的；只不过涉及到的本金和利率不同而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模板模式简介&quot;&gt;&lt;a href=&quot;#模板模式简介&quot; class=&quot;headerlink&quot; title=&quot;模板模式简介&quot;&gt;&lt;/a&gt;模板模式简介&lt;/h1&gt;&lt;p&gt;　　模板方法(Template Method)模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。&lt;br&gt;　　模板方法模式是所有模式中最为常见的几个模式之一，而且很可能我们自己使用过模板方法模式而没有意识到自己已经使用了这个模式。模板方法模式是基于继承的代码复用的基本技术。&lt;br&gt;　　Java的集合就是一个典型的，利用了模板方法模式的例子。Java集合中的Collection集合包括List和Set两大组成部分。List是队列，而Set是没有重复元素的集合。它们共同的接口都在Collection接口声明；例如，都包含了size()，isEmpty()方法。而AbstractCollection这个抽象类则实现了它们共同的方法，其余未实现的方法定义为抽象方法。List和Set的实例类，就是通过继承AbstractCollection(或它的子类)，省去了许多重复性编码的工作！&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="模板方法模式" scheme="https://smartliby.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式16之 策略(Strategy)模式(行为模式)</title>
    <link href="https://smartliby.github.io/2014/05/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16%E4%B9%8B-%E7%AD%96%E7%95%A5-Strategy-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/29/设计模式16之-策略-Strategy-模式-行为模式/</id>
    <published>2014-05-29T03:10:17.000Z</published>
    <updated>2019-04-22T15:23:58.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式简介"><a href="#策略模式简介" class="headerlink" title="策略模式简介"></a>策略模式简介</h1><p>策略(Strategy)模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><a id="more"></a><p>UML类图<br><img src="/images/media/pattern16_01.jpg" alt="pattern16_01"></p><p>这个模式涉及到三个角色：<strong>环境(Context)，抽象策略(Strategy)，具体策略(ConcreteStrategy)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>环境</td><td>持有一个Strategy的引用。</td></tr><tr><td>抽象策略</td><td>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</td></tr><tr><td>具体策略</td><td>包装了相关的算法或行为。</td></tr></tbody></table><p>示意代码</p><pre><code>public class Context {    // 策略对象    private Strategy strategy;    // 构造函数    public Context(Strategy strategy){        this.strategy = strategy;    }    // 策略方法    public void contextInterface(){        strategy.strategyInterface();    }}abstract public class Strategy {    // 策略方法    public abstract void strategyInterface();}public class ConcreteStrategy extends Strategy {    @Override    public void strategyInterface() {        // write your algorithm code here    }}</code></pre><h1 id="策略模式示例"><a href="#策略模式示例" class="headerlink" title="策略模式示例"></a>策略模式示例</h1><p>假设现在要设计一个贩卖各类书籍的电子商务的购物车系统。下面是图书的三种折扣算法。</p><p>算法一：对图书没有折扣。<br>算法二：对图书提供一个固定值为5元的折扣。<br>算法三：对图书提供一个八折的折扣。</p><p>使用策略模式描述的话，这些不同的算法都是不同的具体策略角色：用一个NoDiscountStrategy对象描述”算法一”；用一个FlatRateStrategy对象描述”算法二”；用一个PercentageStrage对象描述”算法三”。</p><h2 id="抽象策略"><a href="#抽象策略" class="headerlink" title="抽象策略"></a>抽象策略</h2><pre><code>abstract public class DiscountStrategy {    // 价格    protected int price = 0;    // 策略    protected int copies = 0;    public abstract int calculateDiscount();    public DiscountStrategy(int price, int copies) {        this.price = price;        this.copies = copies;    }}</code></pre><h2 id="具体策略"><a href="#具体策略" class="headerlink" title="具体策略"></a>具体策略</h2><p>算法一(无折扣)</p><pre><code>public class NoDiscountStrategy extends DiscountStrategy {    public NoDiscountStrategy(int price, int copies) {        super(price, copies);    }    public int calculateDiscount() {        return copies*price;    }}</code></pre><p>算法二(优惠5元)</p><pre><code>public class FlatRateStrategy extends DiscountStrategy {    private int discard = 5;    public FlatRateStrategy(int price, int copies) {        super(price, copies);    }    public void setDiscard() {        this.discard = discard;    }    public int getDiscard() {        return discard;    }    public int calculateDiscount() {        return copies*(price - discard);    }}</code></pre><p>算法三(打8折)</p><pre><code>public class PercentageStrategy extends DiscountStrategy {    // 折扣比例    private float percent = 0.8f;    public PercentageStrategy(int price, int copies) {        super(price, copies);    }    public void setPercent() {        this.percent = percent;    }    public float getPercent() {        return percent;    }    public int calculateDiscount() {        return (int)(copies*price*percent);    }}</code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre><code>public class Client {    public static void main(String[] args) {        // 第一种策略        DiscountStrategy strategy = new NoDiscountStrategy(60, 5);        System.out.println(&quot;total(60,5)=&quot;+strategy.calculateDiscount());        strategy = new FlatRateStrategy(80, 5);        System.out.println(&quot;total(80,5)=&quot;+strategy.calculateDiscount());        strategy = new PercentageStrategy(100, 3);        System.out.println(&quot;total(100,4)=&quot;+strategy.calculateDiscount());    }}</code></pre><p>运行结果：</p><pre><code>total(60,5)=300total(80,5)=375total(100,4)=240</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;策略模式简介&quot;&gt;&lt;a href=&quot;#策略模式简介&quot; class=&quot;headerlink&quot; title=&quot;策略模式简介&quot;&gt;&lt;/a&gt;策略模式简介&lt;/h1&gt;&lt;p&gt;策略(Strategy)模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="策略模式" scheme="https://smartliby.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式15之 不变(Immutable)模式(行为模式)</title>
    <link href="https://smartliby.github.io/2014/05/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15%E4%B9%8B-%E4%B8%8D%E5%8F%98-Immutable-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/28/设计模式15之-不变-Immutable-模式-行为模式/</id>
    <published>2014-05-28T03:10:00.000Z</published>
    <updated>2019-04-22T15:23:58.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不变模式简介"><a href="#不变模式简介" class="headerlink" title="不变模式简介"></a>不变模式简介</h1><p>一个对象的状态在对象被创建之后就不再变化，这就是所谓的不变(Immutable)模式。</p><a id="more"></a><h2 id="不变模式的结构"><a href="#不变模式的结构" class="headerlink" title="不变模式的结构"></a>不变模式的结构</h2><p>　　不变模式可增强对象的强壮型(robustness)。不变模式允许多个对象共享某一个对象，降低了对该对象进行并发访问时的同步化开销。如果需要修改一个不变对象的状态，那么就需要建立一个新的同类型对象，并在创建时将这个新的状态存储在新对象里。</p><p>　　不变模式只涉及到一个类。一个类的内部状态创建后，在整个生命周期都不会发生变化时，这样的类称作不变类。这种使用不变类的做法叫做不变模式。不变模式有两种形式：一种是弱不变模式，另一种是强不变模式。</p><h2 id="弱不变模式"><a href="#弱不变模式" class="headerlink" title="弱不变模式"></a>弱不变模式</h2><p>　　一个类的实例的状态是不可改变的；但是这个类的子类的实例具有可能会变化的状态。这样的类符合弱不变模式的定义。要实现弱不变模式，一个类必须满足下面条件：</p><p>(01) 所考虑的对象没有任何方法会修改对象的状态；这样一来，当对象的构造函数将对象的状态初始化之后，对象的状态便不再改变。<br>(02) 所有属性都应当是私有的。不要声明任何的公开的属性，以防客户端对象直接修改任何的内部状态。<br>(03) 这个对象所引用到的其他对象如何是可变对象的话，必须设法限制外界对这些可变对象的访问，以防止外界修改这些对象。如何可能，应当尽量在不变对象内部初始化这些被引用的对象，而不要在客户端初始化，然后再传入到不变对象内部来。如果某个可变对象必须在客户端初始化，然后再传入到不变对象里的话，就应当考虑在不变对象初始化的时候，将这个可变对象复制一份，而不要使用原来的拷贝。</p><p>弱不变模式的缺点是：<br>第一, 一个弱不变对象的子对象可以是可变对象；换言之，一个弱不变对象的子对象可能是可变的。<br>第二, 这个可变的子对象可能可以修改父对象的状态，从而可能会允许外界修改父对象的状态。</p><h2 id="强不变模式"><a href="#强不变模式" class="headerlink" title="强不变模式"></a>强不变模式</h2><p>　　一个类的实例不会改变，同时它的子类的实例也具有不可变化的状态。这样的类符合强不变模式。要实现强不变模式，一个类必须首先满足弱不变模式所要求的所有条件，并且还有满足下面条件之一：<br>(01) 所考虑的类所有的方法都应当是final，这样这个类的子类不能够置换掉此类的方法。<br>(02) 这个类本身就是final的，那么这个类就不可能会有子类，从而也就不可能有被子类修改的问题。</p><h1 id="不变模式示例"><a href="#不变模式示例" class="headerlink" title="不变模式示例"></a>不变模式示例</h1><p>通过以下几个示例来看看”弱不变模式”和”强不变模式”。</p><h2 id="可变模式"><a href="#可变模式" class="headerlink" title="可变模式"></a>可变模式</h2><pre><code>class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public void setName(String name) { this.name = name; }    public String getName() { return name; }    public void setAge(int age) { this.age = age; }    public int getAge() { return age; }    public String toString() {        return &quot;name:&quot;+name+&quot;, age:&quot;+age;    }}// Complex不是&quot;弱不变类&quot;。// 因为它包含了可变类对象person，并且person是在外部初始化的。class Complex {    private Person person;    private int id;    public Complex (Person person, int id) {        this.person = person;        this.id = id;    }    public int getId() { return id; }    public Person getPerson() { return person; }    public String toString() {        return &quot;id:&quot;+id+&quot;, person(&quot;+person+&quot;)&quot;;    }}public class MutableDemo {    public static void main(String[] args) {        // 新建Complex对象，在&quot;外部(即，非Complex内部)&quot;初始化person。        Person person = new Person(&quot;张三&quot;, 18);        Complex com = new Complex(person, 1);        System.out.println(com);        // 修改person的名字为&quot;李四&quot;，年龄为20        person.setName(&quot;李四&quot;);        person.setAge(20);        System.out.println(com);    }}</code></pre><p>运行结果：</p><pre><code>id:1, person(name:张三, age:18)id:1, person(name:李四, age:20)</code></pre><p>结果说明：<br>MutableDemo中的Complex类满足”弱不变模式”的前2个条件：<br>(01) Complex中没有方法可以修改对象的状态。Complex包含了person和id两个属性值，但是没有方法修改这两个树形。<br>(02) Complex中的person和id属性都是私有的。<br>　　但是，Complex不满足”若不变模式”的第3个条件。Complex引用了”可变类对象person”，person是Person类的对象，而Person是一个可变类！<br>　　所以，在MutableDemo中，我们初始化了Complex的person值为(“张三”,18)之后；在后面修改了person的名字为”李四”,年龄为18。Complex中的person的值也会相应的改变！所以，Complex是”可变类”。</p><p>　　若想将Complex修改为”不变类”，需要将Complex修改的满足”若不变模式”的第3个条件。方法是，在Complex中初始化person的时候，创建一个person的拷贝即可。详细代码请看”2. 弱不变模式”。</p><h2 id="弱不变模式-1"><a href="#弱不变模式-1" class="headerlink" title="弱不变模式"></a>弱不变模式</h2><pre><code>class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public void setName(String name) { this.name = name; }    public String getName() { return name; }    public void setAge(int age) { this.age = age; }    public int getAge() { return age; }    public String toString() {        return &quot;name:&quot;+name+&quot;, age:&quot;+age;    }}// Complex是&quot;弱不变类&quot;。// 它虽然包含了可变的外部对象person，但是Complex内部的person是不会改变的。因为它保存的是person的拷贝。class Complex {    private Person person;    private int id;    public Complex (Person person, int id) {        // 新建一个person的拷贝。        this.person = new Person(person.getName(), person.getAge());        this.id = id;    }    public int getId() { return id; }    public Person getPerson() { return person; }    public String toString() {        return &quot;id:&quot;+id+&quot;, person(&quot;+person+&quot;)&quot;;    }}public class WeakImmutable {    public static void main(String[] args) {        // 新建Complex对象。        // id是1, person的名字是&quot;张三&quot;，年龄是18        Person person = new Person(&quot;张三&quot;, 18);        Complex com = new Complex(person, 1);        System.out.println(com);        // 修改person的名字为&quot;李四&quot;，年龄为20        person.setName(&quot;李四&quot;);        person.setAge(20);        System.out.println(com);    }}</code></pre><p>运行结果：</p><pre><code>id:1, person(name:张三, age:18)id:1, person(name:张三, age:18)</code></pre><p>结果说明：WeakImmutable相比MutableDemo，只对Complex的构造函数进行了修改。Complex同时满足”弱不变模式”的3个条件，因此，它就是个不变模式。</p><h2 id="强不变模式-1"><a href="#强不变模式-1" class="headerlink" title="强不变模式"></a>强不变模式</h2><pre><code>class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public void setName(String name) { this.name = name; }    public String getName() { return name; }    public void setAge(int age) { this.age = age; }    public int getAge() { return age; }    public String toString() {        return &quot;name:&quot;+name+&quot;, age:&quot;+age;    }}// Complex是&quot;强不变类&quot;。final class Complex {    private final Person person;    private final int id;    public Complex (Person person, int id) {        // 新建一个person的拷贝。        this.person = new Person(person.getName(), person.getAge());        this.id = id;    }    public final int getId() { return id; }    public final Person getPerson() { return person; }    public String toString() {        return &quot;id:&quot;+id+&quot;, person(&quot;+person+&quot;)&quot;;    }}public class StrongImmutable {    public static void main(String[] args) {        // 新建Complex对象。        // id是1, person的名字是&quot;张三&quot;，年龄是18        Person person = new Person(&quot;张三&quot;, 18);        Complex com = new Complex(person, 1);        System.out.println(com);        // 修改person的名字为&quot;李四&quot;，年龄为20        person.setName(&quot;李四&quot;);        person.setAge(20);        System.out.println(com);    }}</code></pre><p>运行结果：</p><pre><code>id:1, person(name:张三, age:18)id:1, person(name:张三, age:18)</code></pre><p>结果说明：<br>StrongImmutable中的Complex满足”强不变模式”的要求。StrongImmutable相比WeakImmutable，进行了两个修改：<br>第一，将Complex中的属性和方法都修改为final类型。<br>第二，将Complex类本身修改为final类型。</p><h1 id="不变模式的优缺点"><a href="#不变模式的优缺点" class="headerlink" title="不变模式的优缺点"></a>不变模式的优缺点</h1><p>不变模式有很明显的优点：<br>(1) 因为不能修改一个不变对象的状态，所以可以避免由此引起的不必要的程序错误；换言之，一个不变的对象要比可变的对象更加容易维护。<br>(2) 因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以自由地被不同的客户端共享。</p><p>不变模式的缺点：<br>不变模式唯一的缺点是：一旦需要修改一个不变对象的状态，就只好创建一个新的同类对象。在需要频繁修改不变对象的环境里，会有大量的不变对象作为中间结果被创建出来，再被JAVA垃圾收集器收集走。这是一种资源上的浪费。</p><p>在设计任何一个类的时候，应当慎重考虑其状态是否有需要变化的可能性。除非其状态有变化的必要，不然应当将它设计成不变类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;不变模式简介&quot;&gt;&lt;a href=&quot;#不变模式简介&quot; class=&quot;headerlink&quot; title=&quot;不变模式简介&quot;&gt;&lt;/a&gt;不变模式简介&lt;/h1&gt;&lt;p&gt;一个对象的状态在对象被创建之后就不再变化，这就是所谓的不变(Immutable)模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="不变模式" scheme="https://smartliby.github.io/tags/%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式14之 桥梁(Bridge)模式(结构模式)</title>
    <link href="https://smartliby.github.io/2014/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14%E4%B9%8B-%E6%A1%A5%E6%A2%81-Bridge-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/27/设计模式14之-桥梁-Bridge-模式-结构模式/</id>
    <published>2014-05-27T03:09:42.000Z</published>
    <updated>2019-04-22T15:23:58.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桥梁模式简介"><a href="#桥梁模式简介" class="headerlink" title="桥梁模式简介"></a>桥梁模式简介</h1><p>　　桥梁模式(Bridge)，又称为柄体(Handle and Body)模式或接口(Interface)模式。它属于对象的结构模式，其用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。</p><p>　　这句话有三个关键词：<strong>“抽象化”、”实现化”和”脱耦”</strong>。</p><a id="more"></a><p>　　• <strong>抽象化</strong></p><p>　　存在于多个实体中的共同的概念联系，就是抽象话。例如，苹果、葡萄、草莓，它们的共同特征就是水果，因此，水果是它们的抽象化存在；圆形、正方形、三角形，它们的共同特征就是形状，因此，形状就是它们的抽象话。</p><p>　　通常情况下，一组对象如果具有相同的特征，那么它们就可以通过一个共同的类来描述。如果一些类具有相同的特征，往往可以通过一个共同的抽象类来描述。</p><p>　　• <strong>实现化</strong></p><p>　　抽象化给出的具体实现，就是实现化。</p><p>　　一个类的实例就是这个类的实例化，一个具体子类是它的抽象超类的实例化。</p><p>　　• <strong>脱耦</strong></p><p>　　所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。</p><p>　　所谓强关联，就是在编译时期已经确定的，无法在运行时期动态改变的关联；所谓弱关联，就是可以动态地确定并且可以在运行时期动态地改变的关联。显然，在Java语言中，继承关系是强关联，而聚合关系是弱关联。</p><p>　　将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联。因此，桥梁模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用聚合关系而不是继承关系，从而使两者可以相对独立地变化。这就是桥梁模式的用意。</p><p>桥梁模式的UML类图<br><img src="/images/media/pattern14_01.jpg" alt="pattern14_01"></p><p>从中可以看出，桥接模式含有两个等级结构：<br>(01) 由抽象化角色和修正抽象化角色组成的抽象化等级结构。<br>(02) 由实现化角色和两个具体实现化角色所组成的实现化等级结构。</p><p>桥梁模式包含四种角色： <strong>抽象化(Abstraction)，修正抽象化(RefinedAbstraction)，实现化(Implementor)，具体实现化(ConcreteImplementor)</strong>。<br>• 抽象化: 抽象化给出的定义，并保存一个对实现化对象的引用。<br>• 修正抽象化: 扩展抽象化角色，改变和修正父类对抽象化的定义。<br>• 实现化: 这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。<br>• 具体实现化: 这个角色给出实现化角色接口的具体实现。</p><p>　　对象是对行为的封装，而行为是由方法实现的。在这个示意性系统里，抽象化等级结构中的类封装了operation()方法；而实现化等级结构中的类封装的是operationImpl()方法。当然，在实际的系统中往往会有多于一个的方法。</p><p>　　抽象化等级结构中的方法通过向对应的实现化对象的委派实现自己的功能，这意味着抽象化角色可以通过向不同的实现化对象委派，来达到动态地转换自己的功能的目的。</p><h2 id="示意代码"><a href="#示意代码" class="headerlink" title="示意代码"></a>示意代码</h2><p>抽象化</p><pre><code>public abstract class Abstraction {    protected Implementor impl;    public Abstraction(Implementor impl){        this.impl = impl;    }    // 商业方法    public void operation(){        impl.operationImpl();    }}</code></pre><p>修正抽象化角色</p><pre><code>public class RefinedAbstraction extends Abstraction {    public RefinedAbstraction(Implementor impl) {        super(impl);    }}</code></pre><p>实现化角色</p><pre><code>public abstract class Implementor {    // 方法的实现化声明    public abstract void operationImpl();}</code></pre><p>具体实现化角色</p><pre><code>public class ConcreteImplementorA extends Implementor {    // 方法的实现化实现    @Override    public void operationImpl() {        // something you want to do    }}public class ConcreteImplementorB extends Implementor {    // 方法的实现化实现    @Override    public void operationImpl() {        // something you want to do    }}</code></pre><h1 id="桥梁模式示例"><a href="#桥梁模式示例" class="headerlink" title="桥梁模式示例"></a>桥梁模式示例</h1><p>　　<strong>问题</strong></p><p>　　空中巴士(Airbus)、波音(Boeing)和麦道(MD)都是飞机制造商，它们都生成载客飞机(PassengerPlane)和载货飞机(CargoPlane)。现在需要设计一个系统，描述这些飞机制造商以及它们所制造的飞机种类。</p><p>　　<strong>设计方案一(不使用桥梁模式)</strong></p><p>　　系统是关于飞机的，因此可以设计一个总的飞机接口，叫做Airplane。其它所有的飞机都是这个总接口的字接口或者具体实现。</p><p>　　下面是这个方案的设计图，可以看出，这是一个不太高明的设计，导致了理不清的关系。<br><img src="/images/media/pattern14_02.jpg" alt="pattern14_02"></p><p>　　在这个设计方案里面，出现了两个子接口，分别代表客户和货机。所有的具体飞机又要继承自Airbus，Boeing和MD等超类。这样一类，每个具体飞机都带有两个超类：飞机制造商类型，客、货机类型。</p><p>　　<strong>设计方案二(使用桥梁模式)</strong></p><p>　　使用桥梁模式的关键在于准确的找出这个系统的抽象化角色和具体化角色。从系统所面对的问题不难看出，代表飞机的抽象化是它的类型，也就是”客户”或者”货机”；而代表飞机的实现化的则是飞机的制造商。</p><p>使用桥梁模式，对应的UML类图如下：<br><img src="/images/media/pattern14_03.jpg" alt="pattern14_03"></p><h2 id="抽象化类"><a href="#抽象化类" class="headerlink" title="抽象化类"></a>抽象化类</h2><pre><code>abstract public class Airplane {    // 飞机制造商    protected AirplaneMaker maker;    // 指定飞机制造商    public Airplane(AirplaneMaker maker) {        this.maker = maker;    }    public void fly() {        // 调用AirplaneMaker的produce()方法        maker.produce();    }}</code></pre><h2 id="修正抽象化"><a href="#修正抽象化" class="headerlink" title="修正抽象化"></a>修正抽象化</h2><p>PassengerPlane代码</p><pre><code>public class PassengerPlane extends Airplane {    public PassengerPlane(AirplaneMaker maker) {        super(maker);    }    public void fly() {        super.fly();        System.out.println(&quot;PassengerPlane fly.&quot;);    }}</code></pre><p>CargoPlane代码</p><pre><code>public class CargoPlane extends Airplane {    public CargoPlane(AirplaneMaker maker) {        super(maker);    }    public void fly() {        super.fly();        System.out.println(&quot;CargoPlane fly.&quot;);    }}</code></pre><h2 id="实现化"><a href="#实现化" class="headerlink" title="实现化"></a>实现化</h2><p>AirplaneMaker代码</p><pre><code>abstract public class AirplaneMaker {    // 生产飞机    public abstract void produce() ;}</code></pre><h2 id="具体实现化"><a href="#具体实现化" class="headerlink" title="具体实现化"></a>具体实现化</h2><p>Airbus代码</p><pre><code>public class Airbus extends AirplaneMaker {    public void produce() {        System.out.println(&quot;Airbus produced.&quot;);    }}</code></pre><p>Boeing代码</p><pre><code>public class Boeing extends AirplaneMaker {    public void produce() {        System.out.println(&quot;Boeing produced.&quot;);    }}</code></pre><p>MD代码</p><pre><code>public class MD extends AirplaneMaker {    public void produce() {        System.out.println(&quot;MD produced.&quot;);    }}</code></pre><h2 id="客户端测试程序"><a href="#客户端测试程序" class="headerlink" title="客户端测试程序"></a>客户端测试程序</h2><pre><code>public class Client {    public static void main(String[] args) {        // &quot;飞机制造商&quot;为Airbus        AirplaneMaker maker = new Airbus();        // &quot;飞机类型&quot;为PassengerPlane        Airplane plane = new PassengerPlane(maker);        // 飞机飞行        plane.fly();        // &quot;飞机制造商&quot;为MD        maker = new MD();        // &quot;飞机类型&quot;为CargoPlane        plane = new CargoPlane(maker);        // 飞机飞行        plane.fly();    }}</code></pre><p>运行结果：</p><pre><code>Airbus produced.PassengerPlane fly.MD produced.CargoPlane fly.</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;桥梁模式简介&quot;&gt;&lt;a href=&quot;#桥梁模式简介&quot; class=&quot;headerlink&quot; title=&quot;桥梁模式简介&quot;&gt;&lt;/a&gt;桥梁模式简介&lt;/h1&gt;&lt;p&gt;　　桥梁模式(Bridge)，又称为柄体(Handle and Body)模式或接口(Interface)模式。它属于对象的结构模式，其用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。&lt;/p&gt;
&lt;p&gt;　　这句话有三个关键词：&lt;strong&gt;“抽象化”、”实现化”和”脱耦”&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="桥梁模式" scheme="https://smartliby.github.io/tags/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式13之 门面(Facade)模式(结构模式)</title>
    <link href="https://smartliby.github.io/2014/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13%E4%B9%8B-%E9%97%A8%E9%9D%A2-Facade-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/26/设计模式13之-门面-Facade-模式-结构模式/</id>
    <published>2014-05-26T03:09:23.000Z</published>
    <updated>2019-04-22T15:23:58.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="门面模式简介"><a href="#门面模式简介" class="headerlink" title="门面模式简介"></a>门面模式简介</h1><p>门面模式是对象的结构模式，外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p><p>举个例子，<br>病人去医院看病，如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情：首先病人必须先挂号，然后门诊；如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验；化验后再回到门诊室。如下图所示：</p><a id="more"></a><p><img src="/images/media/pattern13_01.jpg" alt="pattern13_01"></p><p>而如果引”进门面模式”，在医院中增加一个接待员。由接待员负责代为挂号、划价、缴费、取药等，病人只接触接待员，由接待员与各个部门打交道。这样，对病人来说，就会简单很多。如下图所示：<br><img src="/images/media/pattern13_02.jpg" alt="pattern13_02"></p><p>下面看看门面模式的UML类图：<br><img src="/images/media/pattern13_03.jpg" alt="pattern13_03"></p><p>门面模式包括2个角色：<strong>门面(Facade)，子系统(SubSystem)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>门 面</td><td>客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。</td></tr><tr><td>子系统</td><td>可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。</td></tr></tbody></table><h1 id="门面模式示例"><a href="#门面模式示例" class="headerlink" title="门面模式示例"></a>门面模式示例</h1><p>一个保安系统由两个录像机、三个电灯、一个遥控器和一个警报器组成。保安系统的操作人员在早上上班的时候，将这些仪器打开；晚上下班之后，会将这些仪器关闭。</p><p>我们先演示在不使用”门面模式”的情况下，实现该系统。然后，通过”门面模式”实现该系统。</p><h2 id="未使用”门面模式”"><a href="#未使用”门面模式”" class="headerlink" title="未使用”门面模式”"></a>未使用”门面模式”</h2><p>UML类图如下：<br><img src="/images/media/pattern13_04.jpg" alt="pattern13_04"></p><p>从图中可以看出，客户端Client对象需要引用到录像机(Camera)、电灯(Light)、感应器(Sensor)和报警器(Alarm)所有的对象。</p><p>客户端(Client)源码</p><pre><code>public class Client {    private static Camera camera1, camera2;    private static Light light1, light2, light3;    private static Sensor sensor;    private static Alarm alarm;    public static void main(String[] args) {        camera1 = new Camera();        camera2 = new Camera();        light1 = new Light();        light2 = new Light();        light3 = new Light();        sensor = new Sensor();        alarm = new Alarm();        camera1.turnOn();        camera2.turnOn();        light1.turnOn();        light2.turnOn();        light3.turnOn();        sensor.activate();        alarm.activate();    }}</code></pre><p>录像机(Camera)源码</p><pre><code>public class Camera {    // 打开录像机    public void turnOn() {        System.out.println(&quot;Turning on the camera.&quot;);    }    // 关闭录像机    public void turnOff() {        System.out.println(&quot;Turning off the camera.&quot;);    }    // 转动录像机    public void rotate(int degrees) {        System.out.println(&quot;Rotating the camera by &quot;+degrees+&quot; degrees.&quot;);    }}</code></pre><p>电灯(Light)源码</p><pre><code>public class Light {    // 打开灯    public void turnOn() {        System.out.println(&quot;Turning on the light.&quot;);    }    // 关闭灯    public void turnOff() {        System.out.println(&quot;Turning off the light.&quot;);    }    // 换灯泡    public void changeBulb() {        System.out.println(&quot;Cotating the light-bulb.&quot;);    }}</code></pre><p>感应器(Sensor)源码</p><pre><code>public class Sensor {    // 启动感应器    public void activate() {        System.out.println(&quot;Activating on the sensor.&quot;);    }    // 关闭感应器    public void deactivate() {        System.out.println(&quot;Deactivating the sensor.&quot;);    }    // 触发感应器    public void trigger() {        System.out.println(&quot;The sensor has been triggered.&quot;);    }}</code></pre><p>报警器(Alarm)源码</p><pre><code>public class Alarm {    // 启动警报器    public void activate() {        System.out.println(&quot;Activating on the alarm.&quot;);    }    // 关闭警报器    public void deactivate() {        System.out.println(&quot;Deactivating the alarm.&quot;);    }    // 拉响警报器    public void ring() {        System.out.println(&quot;Ringing the alarm&quot;);    }    // 停掉警报器    public void stopRing() {        System.out.println(&quot;Stop the alarm&quot;);    }}</code></pre><p>运行结果：</p><pre><code>Turning on the camera.Turning on the camera.Turning on the light.Turning on the light.Turning on the light.Activating on the sensor.Activating on the alarm.</code></pre><h2 id="使用”门面模式”"><a href="#使用”门面模式”" class="headerlink" title="使用”门面模式”"></a>使用”门面模式”</h2><p>UML类图如下：<br><img src="/images/media/pattern13_05.jpg" alt="pattern13_05"></p><p>可以看出：门面SecurityFade承担了与保安系统内部各个对象打交道的任务，而客户对象只需要与门面对象打交道即可。SecurityFade是客户端与保安系统之间的一个门户，它使得客户端与子系统之间的关系变得简单和易于管理。</p><p>客户端(Client)源码</p><pre><code>public class Client {    private static SecurityFacade security;    public static void main(String[] args) {        security = new SecurityFacade();        security.activate();    }}</code></pre><p>门面(SecurityFade)源码</p><pre><code>public class SecurityFacade {    private Camera camera1, camera2;    private Light light1, light2, light3;    private Sensor sensor;    private Alarm alarm;    public SecurityFacade() {        camera1 = new Camera();        camera2 = new Camera();        light1 = new Light();        light2 = new Light();        light3 = new Light();        sensor = new Sensor();        alarm = new Alarm();    }    public void activate() {        camera1.turnOn();        camera2.turnOn();        light1.turnOn();        light2.turnOn();        light3.turnOn();        sensor.activate();        alarm.activate();    }    public void deactivate() {        camera1.turnOff();        camera2.turnOff();        light1.turnOff();        light2.turnOff();        light3.turnOff();        sensor.deactivate();        alarm.deactivate();    }}</code></pre><p>录像机(Camera)源码</p><pre><code>public class Camera {    // 打开录像机    public void turnOn() {        System.out.println(&quot;Turning on the camera.&quot;);    }    // 关闭录像机    public void turnOff() {        System.out.println(&quot;Turning off the camera.&quot;);    }    // 转动录像机    public void rotate(int degrees) {        System.out.println(&quot;Rotating the camera by &quot;+degrees+&quot; degrees.&quot;);    }}</code></pre><p>电灯(Light)源码</p><pre><code>public class Light {    // 打开灯    public void turnOn() {        System.out.println(&quot;Turning on the light.&quot;);    }    // 关闭灯    public void turnOff() {        System.out.println(&quot;Turning off the light.&quot;);    }    // 换灯泡    public void changeBulb() {        System.out.println(&quot;Cotating the light-bulb.&quot;);    }}</code></pre><p>感应器(Sensor)源码</p><pre><code>public class Sensor {    // 启动感应器    public void activate() {        System.out.println(&quot;Activating on the sensor.&quot;);    }    // 关闭感应器    public void deactivate() {        System.out.println(&quot;Deactivating the sensor.&quot;);    }    // 触发感应器    public void trigger() {        System.out.println(&quot;The sensor has been triggered.&quot;);    }}</code></pre><p>报警器(Alarm)源码</p><pre><code>public class Alarm {    // 启动警报器    public void activate() {        System.out.println(&quot;Activating on the alarm.&quot;);    }    // 关闭警报器    public void deactivate() {        System.out.println(&quot;Deactivating the alarm.&quot;);    }    // 拉响警报器    public void ring() {        System.out.println(&quot;Ringing the alarm&quot;);    }    // 停掉警报器    public void stopRing() {        System.out.println(&quot;Stop the alarm&quot;);    }}</code></pre><p>运行结果：</p><pre><code>Turning on the camera.Turning on the camera.Turning on the light.Turning on the light.Turning on the light.Activating on the sensor.Activating on the alarm.</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;门面模式简介&quot;&gt;&lt;a href=&quot;#门面模式简介&quot; class=&quot;headerlink&quot; title=&quot;门面模式简介&quot;&gt;&lt;/a&gt;门面模式简介&lt;/h1&gt;&lt;p&gt;门面模式是对象的结构模式，外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。&lt;/p&gt;
&lt;p&gt;举个例子，&lt;br&gt;病人去医院看病，如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情：首先病人必须先挂号，然后门诊；如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验；化验后再回到门诊室。如下图所示：&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="门面模式" scheme="https://smartliby.github.io/tags/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式12之 享元(Flyweight)模式(结构模式)</title>
    <link href="https://smartliby.github.io/2014/05/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12%E4%B9%8B-%E4%BA%AB%E5%85%83-Flyweight-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/25/设计模式12之-享元-Flyweight-模式-结构模式/</id>
    <published>2014-05-25T03:09:05.000Z</published>
    <updated>2019-04-22T15:23:58.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="享元模式简介"><a href="#享元模式简介" class="headerlink" title="享元模式简介"></a>享元模式简介</h1><p>享元模式(Flyweight)是对象的结构模式，它以共享的方式高效地支持大量的细粒度对象。</p><p>它的好处是，通过共享来避免大量拥有相同内容对象的开销。</p><p>享元模式中的对象称为享元对象，享元对象分为内蕴状态和外蕴状态。<br>内蕴对象和外蕴对象是相互独立的：内蕴状态是存储在享元对象内部，并且不会随环境改变而有所不同的；内蕴状态是可以共享。外蕴状态是随环境改变而改变，不可以共享的状态；享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。</p><a id="more"></a><p>一个比较典型的享元模式示例就是：”Java中的String对象”。</p><p>例如，定义一个String常量a和b，它们的值为”hello”，定义如下：</p><pre><code>String a=&quot;hello&quot;;String b=&quot;hello&quot;;</code></pre><p>实际上，a和b都是存在常量池中。由于a和b的值都是”hello”，它们实际上是常量池的同一个对象！</p><p>常量池(constant pool)指的是在编译期就被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。</p><h2 id="String示例1"><a href="#String示例1" class="headerlink" title="String示例1"></a>String示例1</h2><pre><code>public class String1 {    public static void main(String[] args) {        String a = &quot;hello&quot;;        String b = &quot;hello&quot;;        String c = &quot;he&quot;+&quot;llo&quot;;        System.out.println(a==b);        System.out.println(a==c);    }}</code></pre><p>运行结果：</p><pre><code>truetrue</code></pre><p>结果说明：<br>(01) a和b中的”hello”都是字符串常量，它们存储在常量池中，在编译期就被确定了，所以a==b为true。<br>(02) “he”和”llo”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以c也同样在编译期就被解析为一个字符串常量，所以c也是常量池中”hello”的一个引用。</p><h2 id="String示例2"><a href="#String示例2" class="headerlink" title="String示例2"></a>String示例2</h2><pre><code>public class String2 {    public static void main(String[] args) {        String a = &quot;hello&quot;;        String b = new String(&quot;hello&quot;);        String c = &quot;he&quot;+new String(&quot;llo&quot;);        System.out.println(a==b);        System.out.println(a==c);        System.out.println(b==c);    }}</code></pre><p>运行结果：</p><pre><code>falsefalsefalse</code></pre><p>结果说明：a还是常量池中”hello”字符串常量；而b则无法在编译期确定，它是运行时创建”hello”对象的引用；而c因为有后半部分new String(“llo”)，所以c也无法在编译期确定，因此，c也是一个新创建的”hello”对象的应用。</p><p>继续回到享元模式。它分为”<strong>单纯享元模式</strong>“ 和 “<strong>复合享元模式</strong>“。</p><p><a name="anchor2"></a></p><h1 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h1><p>在单纯的享元模式中，所有的享元对象都是可以共享的。它的UML类图如下：<br><img src="/images/media/pattern12_01.jpg" alt="pattern12_01"></p><p>单纯享元模式涉及到的角色：<strong>抽象享元(Flyweight)，具体享元(ConcreteFlyweight)，享元工厂(FlyweightFactory)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象享元</td><td>该角色是所有的具体享元类的超类，它给出了具体享元类需要实现的公共接口。</td></tr><tr><td>具体享元</td><td>实现抽象享元角色所规定出的接口。</td></tr><tr><td>享元工厂</td><td>本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</td></tr></tbody></table><h2 id="抽象享元"><a href="#抽象享元" class="headerlink" title="抽象享元"></a>抽象享元</h2><pre><code>abstract public class Flyweight {    // 示意性方法，参数state是外蕴状态。    public abstract void operation(String state);}</code></pre><h2 id="具体享元"><a href="#具体享元" class="headerlink" title="具体享元"></a>具体享元</h2><pre><code>public class ConcreteFlyweight extends Flyweight {    private Character intrinsicState = null;    // 内蕴状态作为参数传入    public ConcreteFlyweight(Character state) {        this.intrinsicState = state;    }    // 外蕴状态作为参量传入方法中，改变方法的行为。    public void operation(String state) {        System.out.println(&quot;\tIntrisic State=&quot;            + intrinsicState            + &quot;, Extriinsic State=&quot;+state);    }}</code></pre><h2 id="享元工厂"><a href="#享元工厂" class="headerlink" title="享元工厂"></a>享元工厂</h2><pre><code>import java.util.Map;import java.util.HashMap;import java.util.Iterator;public class FlyweightFactory {    private HashMap flies = new HashMap();    public Flyweight factory(Character state) {        if (flies.containsKey(state)) {            System.out.println(state+&quot; exists.&quot;);            return (Flyweight)flies.get(state);        } else {            System.out.println(state+&quot; not exists!&quot;);            Flyweight fly = new ConcreteFlyweight(state);            flies.put(state, fly);            return fly;        }    }}</code></pre><h2 id="客户端测试程序"><a href="#客户端测试程序" class="headerlink" title="客户端测试程序"></a>客户端测试程序</h2><pre><code>public class Client {    public static void main(String[] args) {        FlyweightFactory factory = new FlyweightFactory();        Flyweight fly = factory.factory(new Character(&apos;a&apos;));        fly.operation(&quot;First Call&quot;);        fly = factory.factory(new Character(&apos;b&apos;));        fly.operation(&quot;Second Call&quot;);        fly = factory.factory(new Character(&apos;a&apos;));        fly.operation(&quot;Third Call&quot;);    }}</code></pre><p>运行结果：</p><pre><code>a not exists!Intrisic State=a, Extriinsic State=First Callb not exists!Intrisic State=b, Extriinsic State=Second Calla exists.Intrisic State=a, Extriinsic State=Third Call</code></pre><p>结果说明：</p><p>抽象享元类Flyweight提供了operation()公共接口。<br>具体享元类ConcreteFlyweight实现了抽象享元所给定的接口。<br>享元工厂类FlyweightFactory负责创建和管理享元角色。<br>客户端不能直接将具体享元类实例化，而必须通过调用工厂对象的factory()来获取享元对象。<br>在示例中，虽然客户端申请了三个享元对象，但是实际创建的享元对象只有两个，这就是共享的含义。</p><h1 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h1><p>在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。而还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p><p>复合享元模式的UML类图如下：<br><img src="/images/media/pattern12_02.jpg" alt="pattern12_02"></p><p>复合享元角色所涉及到的角色如下：<strong>抽象享元(Flyweight)，具体享元(ConcreteFlyweight)，复合享元(ConcreteCompositeFlyweight)，享元工厂(FlyweightFactory)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象享元</td><td>该角色是所有的具体享元类的超类，它给出了具体享元类需要实现的公共接口。</td></tr><tr><td>具体享元</td><td>实现抽象享元角色所规定出的接口。</td></tr><tr><td>复合享元</td><td>复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。</td></tr><tr><td>享元工厂</td><td>本角色负责创建和管理享元角色。</td></tr></tbody></table><h2 id="抽象享元-1"><a href="#抽象享元-1" class="headerlink" title="抽象享元"></a>抽象享元</h2><p>抽象享元类是Flyweight，它定义了operation()公共接口，operation()方法接收一个外蕴状态作为参量。</p><pre><code>abstract public class Flyweight {    // 示意性方法，参数state是外蕴状态    public abstract void operation(String state);}</code></pre><h2 id="具体享元-1"><a href="#具体享元-1" class="headerlink" title="具体享元"></a>具体享元</h2><p>具体享元类是ConcreteFlyweight。它主要责任有两个：<br>(01) 实现抽象享元所定义的接口operation()。<br>(02) 为内涵状态提供存储空间，也就是ConcreteFlyweight中的intrinsicState树形。</p><pre><code>public class ConcreteFlyweight extends Flyweight {    private Character intrinsicState = null;    // 构造函数，内蕴状态作为参数传入    public ConcreteFlyweight(Character state){        this.intrinsicState = state;    }    // 外蕴状态作为参数传入方法中，改变方法的行为，    @Override    public void operation(String state) {        System.out.println(&quot;\tIntrisic State=&quot;            + intrinsicState            + &quot;, Extriinsic State=&quot;+state);    }}</code></pre><h2 id="复合享元"><a href="#复合享元" class="headerlink" title="复合享元"></a>复合享元</h2><p>复合享元类是ConcreteCompositeFlyweight。</p><p>复合享元是由”单纯享元”对象通过复合而成，因此，它提供了add()这样的聚集管理方法。由于一个复合享元对象具有不同的聚集元素，这些聚集元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。</p><p>此外，复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法，这个方法有一个参数，代表复合享元对象的外蕴状态。一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的；而一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的，不然就没有使用价值了。</p><pre><code>import java.util.Map;import java.util.HashMap;import java.util.Iterator;// 复合享元：它由若干个&quot;单纯享元对象&quot;组成。public class ConcreteCompositeFlyweight extends Flyweight {    private HashMap flies = new HashMap();    private Flyweight flyweight;    // 增加一个新的单纯享元对象到复合享元中    public void add(Character key , Flyweight fly) {        flies.put(key,fly);    }    // 外蕴状态作为参数传入到方法中    @Override    public void operation(String state) {        Flyweight fly = null;        for (Iterator it = flies.entrySet().iterator();             it.hasNext(); ) {            Map.Entry e = (Map.Entry) it.next();            fly = (Flyweight) e.getValue();            fly.operation(state);        }    }}</code></pre><h2 id="享元工厂-1"><a href="#享元工厂-1" class="headerlink" title="享元工厂"></a>享元工厂</h2><p>享元工厂是FlyweightFactory类。</p><p>享元工厂提供两种不同的”返回抽象享元”的方法，一种用于提供单纯享元对象，另一种用于提供复合享元对象。</p><p>当需要单纯享元的时候，就调用factory()，并传入Character类型的参数。<br>当需要复合享元的时候，就调用factory()，并传入String类型的参数。</p><pre><code>import java.util.Map;import java.util.HashMap;import java.util.Iterator;public class FlyweightFactory {    private HashMap flies = new HashMap();    // 创建&quot;复合享元&quot;的工厂方法    public Flyweight factory(String compositeState){        ConcreteCompositeFlyweight compositeFly = new ConcreteCompositeFlyweight();        int length = compositeState.length();        Character state = null;        for (int i=0; i&lt;length; i++) {            state = new Character(compositeState.charAt(i));            System.out.println(&quot;factory(&quot;+state+&quot;)&quot;);            // 通过 this.factory(state)创建&quot;单纯享元&quot;，            // 然后 将&quot;单纯享元&quot;添加到&quot;复合享元&quot;中。            compositeFly.add(state, this.factory(state));        }        return compositeFly;    }    // 创建&quot;单纯享元&quot;的工厂方法    public Flyweight factory(Character state){        if (flies.containsKey(state)) {            return (Flyweight)flies.get(state);        } else {            Flyweight fly = new ConcreteFlyweight(state);            flies.put(state, fly);            return fly;        }    }}</code></pre><h2 id="客户端测试程序-1"><a href="#客户端测试程序-1" class="headerlink" title="客户端测试程序"></a>客户端测试程序</h2><p>客户端是Client。</p><pre><code>public class Client {    public static void main(String[] args) {        FlyweightFactory factory = new FlyweightFactory();        String str = &quot;abcda&quot;;        Flyweight com1 = factory.factory(str);        Flyweight com2 = factory.factory(str);        com1.operation(&quot;Composite Call&quot;);        com2.operation(&quot;Composite Call&quot;);        System.out.println(&quot;com1==com2:&quot;+(com1==com2));        Character c = &apos;1&apos;;        Flyweight pure1 = factory.factory(c);        Flyweight pure2 = factory.factory(c);        pure1.operation(&quot;pure Call&quot;);        pure2.operation(&quot;pure Call&quot;);        System.out.println(&quot;pure1==pure2:&quot;+(pure1==pure2));    }}</code></pre><p>运行结果：</p><pre><code>factory(a)factory(b)factory(c)factory(d)factory(a)factory(a)factory(b)factory(c)factory(d)factory(a)    Intrisic State=d, Extriinsic State=Composite Call    Intrisic State=b, Extriinsic State=Composite Call    Intrisic State=c, Extriinsic State=Composite Call    Intrisic State=a, Extriinsic State=Composite Call    Intrisic State=d, Extriinsic State=Composite Call    Intrisic State=b, Extriinsic State=Composite Call    Intrisic State=c, Extriinsic State=Composite Call    Intrisic State=a, Extriinsic State=Composite Callcom1==com2:false    Intrisic State=1, Extriinsic State=pure Call    Intrisic State=1, Extriinsic State=pure Call</code></pre><p>结果说明：<br>Client中创建两个复合享元com1和com2，它们的内容都是”abcda”。但是com1==com2:false表明：复合享元是不能够共享的。<br>Client中创建两个单纯享元pure1和pure2，它们的内容都是’1’。pure1==pure2:true表明：单纯享元是可以共享的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;享元模式简介&quot;&gt;&lt;a href=&quot;#享元模式简介&quot; class=&quot;headerlink&quot; title=&quot;享元模式简介&quot;&gt;&lt;/a&gt;享元模式简介&lt;/h1&gt;&lt;p&gt;享元模式(Flyweight)是对象的结构模式，它以共享的方式高效地支持大量的细粒度对象。&lt;/p&gt;
&lt;p&gt;它的好处是，通过共享来避免大量拥有相同内容对象的开销。&lt;/p&gt;
&lt;p&gt;享元模式中的对象称为享元对象，享元对象分为内蕴状态和外蕴状态。&lt;br&gt;内蕴对象和外蕴对象是相互独立的：内蕴状态是存储在享元对象内部，并且不会随环境改变而有所不同的；内蕴状态是可以共享。外蕴状态是随环境改变而改变，不可以共享的状态；享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="享元模式" scheme="https://smartliby.github.io/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式11之 代理(Proxy)模式(结构模式)</title>
    <link href="https://smartliby.github.io/2014/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11%E4%B9%8B-%E4%BB%A3%E7%90%86-Proxy-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/24/设计模式11之-代理-Proxy-模式-结构模式/</id>
    <published>2014-05-24T03:08:47.000Z</published>
    <updated>2019-04-22T15:23:58.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式简介"><a href="#代理模式简介" class="headerlink" title="代理模式简介"></a>代理模式简介</h1><p>代理(Proxy)模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p><p>一个比较典型的例子就是”Windows的快捷方式”。Windows快捷方式，可以使任何对象同时出现在多个地方而不必修改原对象。对快捷方式的调用完全与对原对象的调用一样，换言之，快捷方式对客户端是完全透明的。</p><a id="more"></a><p>代理模式的类图如下：<br><img src="/images/media/pattern11_01.jpg" alt="pattern11_01"></p><p>代理模式中共包含了三个角色: <strong>抽象主体(Subject)，代理主题(ProxySubject)，真实主题(RealSubject)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象主题角色</td><td>声明了真实主题和代理主题的共同接口，这样一来在任何可以使用真实主题的地方都可以使用代理主题。</td></tr><tr><td>代理主题角色</td><td>代理主题内部含有真实主题的引用，从而可以在任何时候操作真实主题；代理主题提供一个与真实主题相同的接口，以便可以在任何时候替代真实主题。代理主题通常在客户端调用传递给真实主题之前或之后，执行某个操作，而不是单纯地将调用传递给真实主题。</td></tr><tr><td>真实主题角色</td><td>定义了代理主题所代表的真实主题。</td></tr></tbody></table><p>示意代码</p><pre><code>abstract public class Subject {    // 声明一个抽象的请求方法    public abstract void request();}public class RealSubject extends Subject {    @Override    public void request() {        System.out.println(&quot;From real subject&quot;);    }}public class ProxySubject extends Subject{    RealSubject realSubject = new RealSubject();    @Override    public void request() {        preRequest();        realSubject.request();                postRequest();    }    // 请求前的操作    private void preRequest() {        // something you want to do before requesting    }    // 请求后的操作    private void postRequest() {        // something you want to do after requesting    }}</code></pre><p>若要使用代理主题，则可以通过以下代码：</p><pre><code>Subject subject = new ProxySubject();subject.request();</code></pre><p>从中可以看出代理模式是怎样工作的。首先，代理模式并不改变主题的接口，因为代理模式的用意是不让客户端感觉到代理的存在；其次，代理使用委派将客户端的调用委派给真实的主题对象；换言之，代理主题起到的是一个传递请求的作用。最后，代理主题在传递请求之前和之后都可以执行特定的操作，而不是单纯的传递请求。</p><p>它的时序图如下：<br><img src="/images/media/pattern11_02.jpg" alt="pattern11_02"></p><h1 id="代理模式示例"><a href="#代理模式示例" class="headerlink" title="代理模式示例"></a>代理模式示例</h1><p>下面，通过”高老庄悟空降八戒”的例子来对代理模式进行说明。</p><p>悟空假扮成高小姐去见猪八戒。通过代理模式去分析，”高小姐的神貌”是抽象主题，高小姐本人是真实主题，而悟空是代理主题，他巧妙的实现了”高小姐的神貌”；猪八戒就是客户端，猪八戒根本分不清”悟空假扮的高小姐”和”高小姐本人”。</p><p>对应的类图如下：<br><img src="/images/media/pattern11_03.jpg" alt="pattern11_03"></p><p>下面是各个角色对应的类。</p><h2 id="抽象主体"><a href="#抽象主体" class="headerlink" title="抽象主体"></a>抽象主体</h2><p>抽象主题是”高小姐的神貌”，它对应的类是AbstractAppearance。</p><pre><code>abstract public class AbstractAppearance {    public abstract void smile();}</code></pre><h2 id="真实主题"><a href="#真实主题" class="headerlink" title="真实主题"></a>真实主题</h2><p>真实主题是”高小姐本人”，它对应的类是MissGao。</p><pre><code>public class MissGao extends AbstractAppearance {    @Override    public void smile() {        System.out.println(&quot;Miss Gao smiles.&quot;);    }}</code></pre><h2 id="代理主题"><a href="#代理主题" class="headerlink" title="代理主题"></a>代理主题</h2><p>代理主题是”悟空”，它对应的类是WuKong。</p><pre><code>public class WuKong extends AbstractAppearance {    AbstractAppearance missGao = new MissGao();    @Override    public void smile() {        missGao.smile();                System.out.println(&quot;Actual, it&apos;s wukong smiles.&quot;);    }}</code></pre><h2 id="客户端测试程序"><a href="#客户端测试程序" class="headerlink" title="客户端测试程序"></a>客户端测试程序</h2><p>客户端是”八戒”，它对应的类是BaJie。</p><pre><code>public class BaJie {    public static void main(String[] args) {        // 八戒只认识&quot;高小姐的样貌&quot;，而该&quot;高小姐的样貌&quot;实际上是悟空假扮的。        AbstractAppearance appearance = new WuKong();        appearance.smile();    }}</code></pre><p>运行结果：</p><pre><code>Miss Gao smiles.Actual, it&apos;s wukong smiles.</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代理模式简介&quot;&gt;&lt;a href=&quot;#代理模式简介&quot; class=&quot;headerlink&quot; title=&quot;代理模式简介&quot;&gt;&lt;/a&gt;代理模式简介&lt;/h1&gt;&lt;p&gt;代理(Proxy)模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。&lt;/p&gt;
&lt;p&gt;一个比较典型的例子就是”Windows的快捷方式”。Windows快捷方式，可以使任何对象同时出现在多个地方而不必修改原对象。对快捷方式的调用完全与对原对象的调用一样，换言之，快捷方式对客户端是完全透明的。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="代理模式" scheme="https://smartliby.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式10之 装饰(Decorator)模式(结构模式)</title>
    <link href="https://smartliby.github.io/2014/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10%E4%B9%8B-%E8%A3%85%E9%A5%B0-Decorator-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/23/设计模式10之-装饰-Decorator-模式-结构模式/</id>
    <published>2014-05-23T03:07:00.000Z</published>
    <updated>2019-04-22T15:23:58.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰模式简介"><a href="#装饰模式简介" class="headerlink" title="装饰模式简介"></a>装饰模式简介</h1><p>装饰(Decorator)模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p><p>它以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。</p><a id="more"></a><p>装饰模式的类图如下：<br><img src="/images/media/pattern10_01.jpg" alt="pattern10_01"></p><p>装饰模式包含了三个角色: <strong>抽象构件(Component)，具体构件(ConcreteComponent) ，装饰(Decorator) 和 具体装饰(ConcreteDecorator)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象构件(Component)</td><td>给出一个抽象接口，以规范准备接收附加责任的对象。</td></tr><tr><td>具体构件(ConcreteComponent)</td><td>定义一个将要接收附加责任的类。</td></tr><tr><td>装饰(Decorator)</td><td>持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</td></tr><tr><td>具体装饰(ConcreteDecorator)</td><td>负责给构件对象“贴上”附加的责任。</td></tr></tbody></table><p>示意代码</p><pre><code>public interface Component {    // 商业方法    public void sampleOperation();}public class ConcreteComponent implements Component {    // 构造函数    public ConcreteComponent() {        // write your code here    }    @Override    public void sampleOperation() {        // 写相关的业务代码    }}public class Decorator implements Component{    private Component component;    // 构造函数    public Decorator(Component component){        // write your code here    }    // 构造函数    public Decorator(Component component){        this.component = component;    }    @Override    public void sampleOperation() {        // 商业方法，委派给构件        component.sampleOperation();    }}public class ConcreteDecorator extends Decorator {    @Override    public void sampleOperation() {        super.sampleOperation();        // write your code here    }}</code></pre><p>需要指出的是：<br>(01) 在装饰类Decorator中，有一个私有树形component，其数据结构是构件(Component)。<br>(02) 装饰类Decorator实现了构件(Component)接口。<br>(03) Decorator类中，接口的每一个实现方法都委派给父类，但并不单纯地委派，而是有功能的增强。</p><h1 id="装饰模式示例"><a href="#装饰模式示例" class="headerlink" title="装饰模式示例"></a>装饰模式示例</h1><p>下面，通过”齐天大圣”的例子来对装饰模式进行说明。</p><p>孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。</p><p>在装饰模式中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是花、鸟、鱼、虫等七十二般变化。它的类图如下：<br><img src="/images/media/pattern10_02.jpg" alt="pattern10_02"></p><p>示例代码</p><h2 id="抽象构件-Component"><a href="#抽象构件-Component" class="headerlink" title="抽象构件(Component)"></a>抽象构件(Component)</h2><p>抽象构件是”齐天大圣”，它包行了move()接口。</p><pre><code>abstract public class GreatSage {    public abstract void move();}</code></pre><h2 id="具体构件-ConcreteComponent"><a href="#具体构件-ConcreteComponent" class="headerlink" title="具体构件(ConcreteComponent)"></a>具体构件(ConcreteComponent)</h2><p>具体构件属于大圣的本尊，就是孙悟空。</p><pre><code>public class Monkey extends GreatSage {    @Override    public void move() {        System.out.println(&quot;Monkey Move&quot;);    }}</code></pre><h2 id="装饰-Decorator"><a href="#装饰-Decorator" class="headerlink" title="装饰(Decorator)"></a>装饰(Decorator)</h2><p>装饰由大圣的七十二变扮演。</p><pre><code>public class Change extends GreatSage {    private GreatSage sage;    public Change(GreatSage sage){        this.sage = sage;    }    @Override    public void move() {        sage.move();    }}</code></pre><h2 id="具体装饰-ConcreteDecorator-。"><a href="#具体装饰-ConcreteDecorator-。" class="headerlink" title="具体装饰(ConcreteDecorator)。"></a>具体装饰(ConcreteDecorator)。</h2><p>花</p><pre><code>public class Flower extends Change {    public Flower(GreatSage sage) {        super(sage);    }    @Override    public void move() {        System.out.println(&quot;Flower Move&quot;);    }}</code></pre><p>鸟</p><pre><code>public class Bird extends Change {    public Bird(GreatSage sage) {        super(sage);    }    @Override    public void move() {        System.out.println(&quot;Bird Move&quot;);    }}</code></pre><p>鱼</p><pre><code>public class Fish extends Change {    public Fish(GreatSage sage) {        super(sage);    }    @Override    public void move() {        System.out.println(&quot;Fish Move&quot;);    }}</code></pre><p>虫</p><pre><code>public class Insect extends Change {    public Insect(GreatSage sage) {        super(sage);    }    @Override    public void move() {        System.out.println(&quot;Insect Move&quot;);    }}</code></pre><h2 id="客户端测试程序"><a href="#客户端测试程序" class="headerlink" title="客户端测试程序"></a>客户端测试程序</h2><pre><code>public class Client {    public static void main(String[] args) {        GreatSage sage = new Monkey();        // 1. &quot;齐天大圣&quot;        sage.move();        // 2. &quot;齐天大圣&quot;变成&quot;鸟&quot;之后，再变成&quot;鱼&quot;        GreatSage bird = new Bird(sage);        GreatSage fish = new Fish(bird);             fish.move();        // 3. &quot;齐天大圣&quot;变成&quot;昆虫&quot;之后，再变成&quot;花&quot;        GreatSage flower = new Flower(new Insect(sage));        flower.move();    }}</code></pre><p>运行结果：</p><pre><code>Monkey MoveFish MoveFlower Move</code></pre><p>结果说明：上面的例子的2中，系统把大圣从一只猢狲装饰成了一只鸟儿（把鸟儿的功能加到了猢狲身上），然后又把鸟儿装饰成了一条鱼儿（把鱼儿的功能加到了猢狲+鸟儿身上，得到了猢狲+鸟儿+鱼儿）。如下图所示：<br><img src="/images/media/pattern10_03.jpg" alt="pattern10_03"><br><img src="/images/media/pattern10_04.jpg" alt="pattern10_04"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰模式简介&quot;&gt;&lt;a href=&quot;#装饰模式简介&quot; class=&quot;headerlink&quot; title=&quot;装饰模式简介&quot;&gt;&lt;/a&gt;装饰模式简介&lt;/h1&gt;&lt;p&gt;装饰(Decorator)模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。&lt;/p&gt;
&lt;p&gt;它以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="装饰模式" scheme="https://smartliby.github.io/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式09之 合成(Composite)模式(结构模式)</title>
    <link href="https://smartliby.github.io/2014/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F09%E4%B9%8B-%E5%90%88%E6%88%90-Composite-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/22/设计模式09之-合成-Composite-模式-结构模式/</id>
    <published>2014-05-22T03:06:02.000Z</published>
    <updated>2019-04-22T15:23:58.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合成模式简介"><a href="#合成模式简介" class="headerlink" title="合成模式简介"></a>合成模式简介</h1><p>合成模式属于对象的结构型模式，有时又被称为”部分-整体模式”。合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。</p><a id="more"></a><p>例如，文件系统就是一个典型的合成模式系统。合成模式的树形图如下所示：<br><img src="/images/media/pattern09_01.jpg" alt="pattern09_01"></p><p>它的UML类图如下所示：<br><img src="/images/media/pattern09_02.jpg" alt="pattern09_02"></p><p>它共包括3个角色：<strong>抽象构件(Component)</strong>，<strong>树叶构件(Leaf)</strong> 和 <strong>树枝构件(Composite)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象构件</td><td>这是一个抽象角色，它给参加组合的对象规定一个接口。这个角色给出共有的接口及其默认行为。</td></tr><tr><td>树叶构件</td><td>代表参加组合的树叶对象。树叶对象没有下级子对象，它定义出参加组合的原始对象的行为。</td></tr><tr><td>树枝构件</td><td>代表参加组合的有下级子对象的对象，并给出树枝构件对象的行为。</td></tr></tbody></table><p>根据”参加组合的对象的管理方式”，可以将合成模式分为两种不同的形式：<strong>安全合成模式</strong> 和 <strong>透明合成模式</strong>。<br>• 安全合成模式：此方式只允许”树枝构件”有对象的管理方法。<br>• 透明合成模式：此方式只允许”树枝构件’和”树叶构件”都有对象的管理方法，但”树叶构件”中的管理方法无实际意义。  </p><h1 id="安全合成模式"><a href="#安全合成模式" class="headerlink" title="安全合成模式"></a>安全合成模式</h1><p>安全合成模式要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。</p><p>安全合成模式的UML图如下：<br><img src="/images/media/pattern09_03.jpg" alt="pattern09_03"></p><p>它共包括3个角色：<strong>抽象构件(Component)，树叶构件(Leaf) 和 树枝构件(Composite)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象构件</td><td>这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。</td></tr><tr><td>树叶构件</td><td>树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。</td></tr><tr><td>树枝构件</td><td>代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。</td></tr></tbody></table><p>示例代码</p><pre><code>public interface Component {    // 返还自己的示例    Composite getComposite();    // 某个商业方法    void sampleOperation();}public class Composite implements Component {    private Vector componentVector = new Vector();    public Composite getComposite() {        return this;    }    public void sampleOperation() {        Enumeration enum = composites();        while (enum.hasMoreElements()) {            ((Composite)enum.nextElement()).sampleOperation();        }    }    // 添加一个子构件对象    public void add(Component component) {        componentVector.addElement(component);    }    // 删除一个子构件对象    public void remove(Component component) {        componentVector.removeElement(component);    }    // 聚集管理办法，返还聚集的Enumeration对象    public Enumeration components() {        return componentVector.elements();    }}public class Leaf implements Component {    public void sampleOperation() {    }    public Composite getComposite() {        return null;    }}</code></pre><p>从中可以看出，树叶构建(Leaf)中没有对节点的管理方法，而只有树枝构建(Composite)中有节点的管理方法。</p><h1 id="透明合成模式"><a href="#透明合成模式" class="headerlink" title="透明合成模式"></a>透明合成模式</h1><p>与安全式的合成模式不同的是，透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。</p><p>透明合成模式的UML图如下：<br><img src="/images/media/pattern09_04.jpg" alt="pattern09_04"></p><p>它共包括3个角色：<strong>抽象构件(Component)，树叶构件(Leaf) 和 树枝构件(Composite)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象构件</td><td>这是一个抽象角色，它给参加组合的对象规定一个接口，规范共有的接口及默认行为。这个接口可以用来管理所有的子对象，要提供一个接口以规范取得和管理下层组件的接口，包括add(), remove()以及getChild()之类的方法。</td></tr><tr><td>树叶构件</td><td>代表参加组合的树叶对象，定义出参加组合的原始对象的行为。树叶类会给出add(), remove()以及getChild()之类的用来管理子类对象的方法的平庸实现。</td></tr><tr><td>树枝构件</td><td>代表参加组合的有子对象的对象，定义出这样的对象的行为。</td></tr></tbody></table><p>示例代码</p><pre><code>public interface Component {    // 某个商业方法    void sampleOperation();    // 返还自己的示例    Composite getComposite();    // 聚集管理方法，增加子构件对象    void add(Component component);    // 聚集管理方法，删除子构件对象    void remove(Component component);    // 聚集管理办法，返还聚集的Enumeration对象    Enumeration components();}public class Composite implements Component {    private Vector componentVector = new Vector();    public Composite getComposite() {        return this;    }    public void sampleOperation() {        Enumeration enum = composites();        while (enum.hasMoreElements()) {            ((Composite)enum.nextElement()).sampleOperation();        }    }    // 添加一个子构件对象    public void add(Component component) {        componentVector.addElement(component);    }    // 删除一个子构件对象    public void remove(Component component) {        componentVector.removeElement(component);    }    // 聚集管理办法，返还聚集的Enumeration对象    public Enumeration components() {        return componentVector.elements();    }}public class Leaf implements Component {    public void sampleOperation() {    }    public Composite getComposite() {        return null;    }    // 添加一个子构件对象    public void add(Component component) {    }    // 删除一个子构件对象    public void remove(Component component) {    }    // 聚集管理办法，返还聚集的Enumeration对象    public Enumeration components() {        return null;    }}　</code></pre><p><a name="anchor4"></a></p><h1 id="合成模式示例"><a href="#合成模式示例" class="headerlink" title="合成模式示例"></a>合成模式示例</h1><p>下面以一个逻辑树为例子，演示合成模式。</p><h2 id="抽象构件-IFile-java"><a href="#抽象构件-IFile-java" class="headerlink" title="抽象构件(IFile.java)"></a>抽象构件(IFile.java)</h2><pre><code>public interface IFile {    //返回自己的实例    IFile getComposite();    //某个商业方法    void sampleOperation();    //获取深度    int getDeep();    //设置深度    void setDeep(int x);}</code></pre><h2 id="树枝构件-Folder-java"><a href="#树枝构件-Folder-java" class="headerlink" title="树枝构件(Folder.java)"></a>树枝构件(Folder.java)</h2><pre><code>import java.util.Vector;public class Folder implements IFile {    private String name;    //文件名字    private int deep;       //层级深度，根深度为0    private Vector&lt;IFile&gt; componentVector = new Vector&lt;IFile&gt;();    public Folder(String name) {        this.name = name;    }    //返回自己的实例    public IFile getComposite() {        return this;    }    //某个商业方法    public void sampleOperation() {        System.out.println(&quot;执行了某个商业方法！&quot;);    }    //增加一个文件或文件夹    public void add(IFile IFile) {        componentVector.addElement(IFile);        IFile.setDeep(this.deep + 1);    }    //删除一个文件或文件夹    public void remove(IFile IFile) {        componentVector.removeElement(IFile);    }    //返回直接子文件（夹）集合    public Vector getAllComponent() {        return componentVector;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getDeep() {        return deep;    }    public void setDeep(int deep) {        this.deep = deep;    }}</code></pre><h2 id="树枝构件-File-java"><a href="#树枝构件-File-java" class="headerlink" title="树枝构件(File.java)"></a>树枝构件(File.java)</h2><pre><code>public class File implements IFile {    private String name;    //文件名字    private int deep;       //层级深度    public File(String name) {        this.name = name;    }    //返回自己的实例    public IFile getComposite() {        return this;    }    //某个商业方法    public void sampleOperation() {        System.out.println(&quot;执行了某个商业方法！&quot;);    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getDeep() {        return deep;    }    public void setDeep(int deep) {        this.deep = deep;    }}</code></pre><h2 id="客户端测试程序-Client-java"><a href="#客户端测试程序-Client-java" class="headerlink" title="客户端测试程序(Client.java)"></a>客户端测试程序(Client.java)</h2><pre><code>import java.util.Iterator;import java.util.Vector;import java.util.Collections;public class Client {    private static final String INDENT_CHAR = &quot;\t&quot;;       //文件层次缩进字符    public static void main(String args[]) {        new Client().test();    }    /**     * 客户端测试方法     */    public void test() {        //根下文件及文件夹        Folder root = new Folder(&quot;树根&quot;);        Folder b1_1 = new Folder(&quot;1_枝1&quot;);        Folder b1_2 = new Folder(&quot;1_枝2&quot;);        Folder b1_3 = new Folder(&quot;1_枝3&quot;);        File l1_1 = new File(&quot;1_叶1&quot;);        File l1_2 = new File(&quot;1_叶2&quot;);        File l1_3 = new File(&quot;1_叶3&quot;);        //b1_2下的文件及文件夹        Folder b2_1 = new Folder(&quot;2_枝1&quot;);        Folder b2_2 = new Folder(&quot;2_枝2&quot;);        File l2_1 = new File(&quot;2_叶1&quot;);        //缔造树的层次关系（简单测试，没有重复添加的控制）        root.add(b1_1);        root.add(b1_2);        root.add(l1_1);        root.add(l1_2);        b1_2.add(b2_1);        b1_2.add(b2_2);        b1_2.add(l2_1);        root.add(l1_3);        root.add(b1_3);        //控制台打印树的层次        outTree(root);    }    public void outTree(Folder folder) {        System.out.println(folder.getName());        iterateTree(folder);    }    /**     * 遍历文件夹，输入文件树     *     * @param folder     */    public void iterateTree(Folder folder) {        Vector&lt;IFile&gt; clist = folder.getAllComponent();        for (Iterator&lt;IFile&gt; it = clist.iterator(); it.hasNext();) {            IFile em = it.next();            if (em instanceof Folder) {                Folder cm = (Folder) em;                System.out.println(getIndents(em.getDeep()) + cm.getName());                iterateTree(cm);            } else {                System.out.println(getIndents(em.getDeep()) + ((File) em).getName());            }        }    }    /**     * 文件层次缩进字符串     *     * @param x 缩进字符个数     * @return 缩进字符串     */    public static String getIndents(int x) {        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; x; i++) {            sb.append(INDENT_CHAR);        }        return sb.toString();    }}</code></pre><p>运行结果：</p><pre><code>树根    1_枝1    1_枝2        2_枝1        2_枝2        2_叶1    1_叶1    1_叶2    1_叶3    1_枝3</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合成模式简介&quot;&gt;&lt;a href=&quot;#合成模式简介&quot; class=&quot;headerlink&quot; title=&quot;合成模式简介&quot;&gt;&lt;/a&gt;合成模式简介&lt;/h1&gt;&lt;p&gt;合成模式属于对象的结构型模式，有时又被称为”部分-整体模式”。合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="合成模式" scheme="https://smartliby.github.io/tags/%E5%90%88%E6%88%90%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式08之 适配器(Adapter)模式(结构模式)</title>
    <link href="https://smartliby.github.io/2014/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08%E4%B9%8B-%E9%80%82%E9%85%8D%E5%99%A8-Adapter-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/21/设计模式08之-适配器-Adapter-模式-结构模式/</id>
    <published>2014-05-21T03:05:37.000Z</published>
    <updated>2019-04-22T15:23:58.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式简介"><a href="#原型模式简介" class="headerlink" title="原型模式简介"></a>原型模式简介</h1><p>原型模式是”创建模式”(创建对象的模式)。通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。</p><a id="more"></a><p>Java语言的支持支持创建模式。在Java中Object是所有类的父类，而Object中提供了clone()方法。clone()会通过调用本地方法实现对象的复制。它的源码如下：</p><pre><code>protected native Object clone() throws CloneNotSupportedException;</code></pre><p>clone()定义了Object中，就相当于Java中的任何类都继承了clone()方法。但是，如果要类支持克隆的话，必须要声明该类实现了Cloneable接口。否则，调用该类的clone()方法时，会抛出CloneNotSupportedException异常。</p><p>使用场景: 系统的产品是动态加载的，而产品类具有一定的等级结构。 例如，数据库中存储了很多数据，有时我们需要将其中的一些数据取出来存放到新的表格中。或者，有时候我们需要对比一个对象在处理前/后的姿态；在处理之前，可以克隆该对象，然后和处理之后的对象比较。</p><p>原型模式有两种表现形式：<strong>简单形式</strong> 和 <strong>登记形式</strong>。<br>如果需要创建的原型对象数目少而且比较固定的华，就采用”简单形式”；如果要创建的原型对象数目不确定的华，就采用”登记形式”。</p><h1 id="简单形式的原型模式"><a href="#简单形式的原型模式" class="headerlink" title="简单形式的原型模式"></a>简单形式的原型模式</h1><p>类图<br><img src="/images/media/pattern07_01.jpg" alt="pattern07_01"></p><p>它涉及到3个角色：<strong>客户(Client), 抽象原型(Prototype) 和 具体原型(ConcretePrototype)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Client</td><td>客户类提出创建对象的请求。</td></tr><tr><td>Prototype</td><td>抽象原型给出所有的具体原型所需要实现的函数接口。</td></tr><tr><td>ConcreteType</td><td>被复制的对象，实现了Prototype中的函数接口。</td></tr></tbody></table><p>代码模型</p><pre><code>public interface Prototype extends Cloneable {    Prototype clone();}public class ConcretePrototype implements Prototype {    public Object clone() {        try {            return super.clone();        } catch (CloneNotSupportedException e) {            return null;        }    }}public class Client {    private Prototype prototype;    public void operation(Prototype example) {        Prototype p = (Prototype) example.clone();    }}</code></pre><h1 id="登记形式的原型模式"><a href="#登记形式的原型模式" class="headerlink" title="登记形式的原型模式"></a>登记形式的原型模式</h1><p>UML类图<br><img src="/images/media/pattern07_02.jpg" alt="pattern07_02"></p><p>它涉及到4个角色：<strong>客户(Client), 抽象原型(Prototype), 具体原型(ConcretePrototype) 和 PrototypeManager(原型管理器)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Client</td><td>客户类提出创建对象的请求。</td></tr><tr><td>Prototype</td><td>抽象原型给出所有的具体原型所需要实现的函数接口。</td></tr><tr><td>ConcreteType</td><td>被复制的对象，实现了Prototype中的函数接口。</td></tr><tr><td>PrototypeManager</td><td>创建具体原型类的对象，并记录每一个被创建的对象。</td></tr></tbody></table><p>代码模型</p><pre><code>public interface Prototype extends Cloneable {    Prototype clone();}public class ConcretePrototype implements Prototype {    public synchronized Object clone() {        Prototype temp = null;        try {            temp = (Prototype)super.clone();            return temp;        } catch (CloneNotSupportedException e) {            return null;        } finally {            return temp;        }    }}public class PrototypeManager {    private Vector objects = new Vector();    public void add(Prototype object) {        objects.add(object);    }    public Prototype get(int i) {        return (Prototype) objects.get(i);    }    public int getSize() {        return objects.size();    }}public class Client {    private PrototypeManager mgr;    private Prototype prototype;    public void registerPrototype() {        prototype = new ConcretePrototype();        Prototype copytype = (Prototype)prototype.clone();        mgr.add(copytype);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原型模式简介&quot;&gt;&lt;a href=&quot;#原型模式简介&quot; class=&quot;headerlink&quot; title=&quot;原型模式简介&quot;&gt;&lt;/a&gt;原型模式简介&lt;/h1&gt;&lt;p&gt;原型模式是”创建模式”(创建对象的模式)。通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="原型模式" scheme="https://smartliby.github.io/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式07之 原型模式(创建模式)</title>
    <link href="https://smartliby.github.io/2014/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07%E4%B9%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/20/设计模式07之-原型模式-创建模式/</id>
    <published>2014-05-20T03:05:17.000Z</published>
    <updated>2019-04-22T15:23:58.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式简介"><a href="#原型模式简介" class="headerlink" title="原型模式简介"></a>原型模式简介</h1><p>原型模式是”创建模式”(创建对象的模式)。通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。</p><a id="more"></a><p>Java语言的支持支持创建模式。在Java中Object是所有类的父类，而Object中提供了clone()方法。clone()会通过调用本地方法实现对象的复制。它的源码如下：</p><pre><code>protected native Object clone() throws CloneNotSupportedException;</code></pre><p>clone()定义了Object中，就相当于Java中的任何类都继承了clone()方法。但是，如果要类支持克隆的话，必须要声明该类实现了Cloneable接口。否则，调用该类的clone()方法时，会抛出CloneNotSupportedException异常。</p><p>使用场景: 系统的产品是动态加载的，而产品类具有一定的等级结构。 例如，数据库中存储了很多数据，有时我们需要将其中的一些数据取出来存放到新的表格中。或者，有时候我们需要对比一个对象在处理前/后的姿态；在处理之前，可以克隆该对象，然后和处理之后的对象比较。</p><p>原型模式有两种表现形式：<strong>简单形式</strong> 和 <strong>登记形式</strong>。<br>如果需要创建的原型对象数目少而且比较固定的华，就采用”简单形式”；如果要创建的原型对象数目不确定的华，就采用”登记形式”。</p><h1 id="简单形式的原型模式"><a href="#简单形式的原型模式" class="headerlink" title="简单形式的原型模式"></a>简单形式的原型模式</h1><p>类图<br><img src="/images/media/pattern07_01.jpg" alt="pattern07_01"></p><p>它涉及到3个角色：<strong>客户(Client), 抽象原型(Prototype) 和 具体原型(ConcretePrototype)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Client</td><td>客户类提出创建对象的请求。</td></tr><tr><td>Prototype</td><td>抽象原型给出所有的具体原型所需要实现的函数接口。</td></tr><tr><td>ConcreteType</td><td>被复制的对象，实现了Prototype中的函数接口。</td></tr></tbody></table><p>代码模型</p><pre><code>public interface Prototype extends Cloneable {    Prototype clone();}public class ConcretePrototype implements Prototype {    public Object clone() {        try {            return super.clone();        } catch (CloneNotSupportedException e) {            return null;        }    }}public class Client {    private Prototype prototype;    public void operation(Prototype example) {        Prototype p = (Prototype) example.clone();    }}</code></pre><h1 id="登记形式的原型模式"><a href="#登记形式的原型模式" class="headerlink" title="登记形式的原型模式"></a>登记形式的原型模式</h1><p>UML类图<br><img src="/images/media/pattern07_02.jpg" alt="pattern07_02"></p><p>它涉及到4个角色：<strong>客户(Client), 抽象原型(Prototype), 具体原型(ConcretePrototype) 和 PrototypeManager(原型管理器)</strong>。</p><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>Client</td><td>客户类提出创建对象的请求。</td></tr><tr><td>Prototype</td><td>抽象原型给出所有的具体原型所需要实现的函数接口。</td></tr><tr><td>ConcreteType</td><td>被复制的对象，实现了Prototype中的函数接口。</td></tr><tr><td>PrototypeManager</td><td>创建具体原型类的对象，并记录每一个被创建的对象。</td></tr></tbody></table><p>代码模型</p><pre><code>public interface Prototype extends Cloneable {    Prototype clone();}public class ConcretePrototype implements Prototype {    public synchronized Object clone() {        Prototype temp = null;        try {            temp = (Prototype)super.clone();            return temp;        } catch (CloneNotSupportedException e) {            return null;        } finally {            return temp;        }    }}public class PrototypeManager {    private Vector objects = new Vector();    public void add(Prototype object) {        objects.add(object);    }    public Prototype get(int i) {        return (Prototype) objects.get(i);    }    public int getSize() {        return objects.size();    }}public class Client {    private PrototypeManager mgr;    private Prototype prototype;    public void registerPrototype() {        prototype = new ConcretePrototype();        Prototype copytype = (Prototype)prototype.clone();        mgr.add(copytype);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原型模式简介&quot;&gt;&lt;a href=&quot;#原型模式简介&quot; class=&quot;headerlink&quot; title=&quot;原型模式简介&quot;&gt;&lt;/a&gt;原型模式简介&lt;/h1&gt;&lt;p&gt;原型模式是”创建模式”(创建对象的模式)。通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="原型模式" scheme="https://smartliby.github.io/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式06之 建造模式(创建模式)</title>
    <link href="https://smartliby.github.io/2014/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06%E4%B9%8B-%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartliby.github.io/2014/05/19/设计模式06之-建造模式-创建模式/</id>
    <published>2014-05-19T03:04:57.000Z</published>
    <updated>2019-04-22T15:23:58.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建造模式简介"><a href="#建造模式简介" class="headerlink" title="建造模式简介"></a>建造模式简介</h1><p>建造模式是”创建模式”(创建对象的模式)。当我们要创建的对象比较复杂的时候，可以将对象的”创建”和”表示”分割开来；从而可以使一个构造过程创建具有不同表示的产品。这种参见对象的方式就是建造模式。</p><a id="more"></a><p><strong>建造模式的使用场景</strong></p><p>(01), 对象包含复杂的内部结构。每个内部成分本身可以是对象，也可以仅仅是一个对象的一个组成成分。<br>&nbsp;&nbsp;&nbsp;&nbsp; 例如，一个电子邮件由发件人地址、收件人地址、主题、内容、附件等内容。我们可以根据这些组成部分组合成一份邮件，然后发送出去。</p><p>(02), 对象的各个属性相互依赖。<br>&nbsp;&nbsp;&nbsp;&nbsp; 例如，某对象包含许多性质，而这些性质必须按照某个顺序赋值才有意义。</p><p>(03), 对象创建过程会使用到系统中的其他对象，而这些对象在产品对象的创建过程中不易得到。</p><p>下面看看它的结构图：<br><img src="/images/media/pattern06_01.jpg" alt="pattern06_01"></p><p>建造模式包括4个组成部分：<strong>导演者(Director), 抽象建造者(Builder), 具体建造者(ConcreteBuilder) 和 产品(Product)</strong>。</p><table><thead><tr><th>组成部分</th><th>说明</th></tr></thead><tbody><tr><td>Director</td><td>它会调用具体创建者来创造一个产品对象。</td></tr><tr><td>Builder</td><td>它会给出”创建一个产品对象的各个组成成分”的抽象接口。</td></tr><tr><td>ConcreteBuilder</td><td>实现”抽象建造者”给出的抽象接口。</td></tr><tr><td>Product</td><td>要被创建的产品对象。</td></tr></tbody></table><h1 id="建造模式代码模型"><a href="#建造模式代码模型" class="headerlink" title="建造模式代码模型"></a>建造模式代码模型</h1><pre><code>public class Director {    private Builder builder;    // 构造产品    public void construct() {        builder = new ConcreteBuilder();        builder.buildPart1();        builder.buildPart2();    }}abstract public class Builder {    // 构造&quot;产品的Part1&quot;的接口    public abstract void buildPart1();    // 构造&quot;产品的Part2&quot;的接口    public abstract void buildPart2();    // 返回产品    public abstract Product retrieveResult();}public class ConcreteBuilder {    private Product product = new Product();    public void buildPart1() {        // 参见产品的Part1    }    public void buildPart2() {        // 参见产品的Part2    }    public Product retrieveResult() {        return product;    }}public class Product {     // 产品组成部分...}</code></pre><h1 id="建造模式示例"><a href="#建造模式示例" class="headerlink" title="建造模式示例"></a>建造模式示例</h1><p>假设由一个电子杂志系统，定期的向用户的发送电子邮箱。发送的电子邮件模板由两种：欢迎和欢送。邮件包括”发送者地址”，”接收者地址”，“主题”，“内容”，“发送日期”等内容；其中，“发送者地址”和“接收者地址”是必填的。</p><p>下面通过建造模式实现该系统，对应的UML图如下：<br><img src="/images/media/pattern06_02.jpg" alt="pattern06_02"></p><p>建造模式包括4个组成部分：”导演者”, “抽象建造者”, “具体建造者”和”产品”这4个角色分别如下：</p><h2 id="“导演者”"><a href="#“导演者”" class="headerlink" title="“导演者”"></a>“导演者”</h2><p>导演者是Director。Director会根据Builder对象，构造出邮件。</p><p>Director的源码</p><pre><code>public class Director {    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    public void construct(String from, String to) {        builder.buildFrom(from);        builder.buildTo(to);        builder.buildSubject();        builder.buildBody();        builder.buildSendDate();        builder.send();    }}</code></pre><h2 id="“抽象建造者”"><a href="#“抽象建造者”" class="headerlink" title="“抽象建造者”"></a>“抽象建造者”</h2><p>抽象建造者是Builder。Builder是抽象类，它包含具体的邮件对象msg，msg是在Builder的子类中根据所要创建的消息来初始化的。此外，Builder提供了构造邮件的函数接口。</p><p>Builder的源码</p><pre><code>import java.util.Date;abstract public class Builder {    protected AutoMessage msg;    public Builder() {    }    public abstract void buildBody() ;    public abstract void buildSubject() ;    public void buildFrom(String from) {        msg.setFrom(from);    }    public void buildTo(String to) {        msg.setTo(to);    }    public void buildSendDate() {        msg.setSendDate(new Date());    }    public void send() {        msg.send();    }}</code></pre><h2 id="“具体建造者”"><a href="#“具体建造者”" class="headerlink" title="“具体建造者”"></a>“具体建造者”</h2><p>具体建造者是WelcomeBuilder和GoodbyeBuilder。WelcomeBuilder是欢迎消息，GoodbyeBuilder是欢送消息。</p><p>WelcomeBuilder的源码</p><pre><code>public class WelcomeBuilder extends Builder {    public WelcomeBuilder() {        System.out.println(&quot;create WelcomeBuilder&quot;);        this.msg = new WelcomeMessage();    }    public void buildBody() {        msg.setBody(&quot;Welcome body!&quot;);    }    public void buildSubject() {        msg.setSubject(&quot;Welcome subject!&quot;);    }}</code></pre><p>GoodbyeBuilder的源码</p><pre><code>public class GoodbyeBuilder extends Builder {    public GoodbyeBuilder() {        System.out.println(&quot;create GoodbyeBuilder&quot;);        msg = new GoodbyeMessage();    }    public void buildBody() {        msg.setBody(&quot;Goodbye body!&quot;);    }    public void buildSubject() {        msg.setSubject(&quot;Goodbye subject!&quot;);    }}</code></pre><h2 id="“产品”"><a href="#“产品”" class="headerlink" title="“产品”"></a>“产品”</h2><p>产品是AutoMessage。AutoMessage是抽象出来的产品类，它包含两个子类WelcomeBuilder和GoodbyeMessage。</p><p>AutoMessage的源码</p><pre><code>import java.util.Date;abstract public class AutoMessage {    protected String from;    protected String to;    protected String subject;    protected String body;    protected Date sendDate;    public void setFrom(String from) {        this.from = from;    }    public String getFrom() {        return from;    }    public void setTo(String to) {        this.to = to;    }    public String getTo() {        return to;    }    public void setSubject(String subject) {        this.subject = subject;    }    public String getSubject() {        return subject;    }    public void setBody(String body) {        this.body = body;    }    public String getBody() {        return body;    }    public void setSendDate(Date sendDate) {        this.sendDate = sendDate;    }    public Date getSendDate() {        return sendDate;    }    public void send() {        System.out.println(&quot;send MSG[Subject: \&quot;&quot;+subject+&quot;\&quot;, Body: \&quot;&quot;+body+&quot;\&quot;] from \&quot;&quot;+from+&quot;\&quot; to \&quot;&quot;+to+&quot;\&quot; @date:\&quot;&quot;+sendDate+&quot;\&quot;&quot;);    }}</code></pre><p>WelcomeMessage的源码</p><pre><code>public class WelcomeMessage extends AutoMessage {    public WelcomeMessage() {        System.out.println(&quot;Create WelcomeMessage&quot;);    }    public void sayWelcome() {        System.out.println(&quot;Welcome.&quot;);    }}</code></pre><p>GoodbyeMessage的源码</p><pre><code>public class GoodbyeMessage extends AutoMessage {    public GoodbyeMessage() {        System.out.println(&quot;Create GoodbyeMessage&quot;);    }    public void sayGoodbye() {        System.out.println(&quot;Goodbye.&quot;);    }}</code></pre><h2 id="客户端测试程序"><a href="#客户端测试程序" class="headerlink" title="客户端测试程序"></a>客户端测试程序</h2><p>客户端是”Client”。</p><p>Client的源码</p><pre><code>public class Client {    private static Director dw, dg;    private static Builder bw, bg;    public static void main(String[] args) {        bw = new WelcomeBuilder();        dw = new Director(bw);        dw.construct(&quot;skywang12345@gmail.com&quot;, &quot;java_patterns@gmail.com&quot;);        bg = new GoodbyeBuilder();        dg = new Director(bg);        dg.construct(&quot;skywang54321@gmail.com&quot;, &quot;java_patterns@gmail.com&quot;);    }}</code></pre><p>运行结果：</p><pre><code>create WelcomeBuilderCreate WelcomeMessagesend MSG[Subject: &quot;Welcome subject!&quot;, Body: &quot;Welcome body!&quot;] from &quot;skywang12345@gmail.com&quot; to &quot;java_patterns@gmail.com&quot; @date:&quot;Sun Jan 19 10:48:02 CST 2014&quot;create GoodbyeBuilderCreate GoodbyeMessagesend MSG[Subject: &quot;Goodbye subject!&quot;, Body: &quot;Goodbye body!&quot;] from &quot;skywang54321@gmail.com&quot; to &quot;java_patterns@gmail.com&quot; @date:&quot;Sun Jan 19 10:48:02 CST 2014&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;建造模式简介&quot;&gt;&lt;a href=&quot;#建造模式简介&quot; class=&quot;headerlink&quot; title=&quot;建造模式简介&quot;&gt;&lt;/a&gt;建造模式简介&lt;/h1&gt;&lt;p&gt;建造模式是”创建模式”(创建对象的模式)。当我们要创建的对象比较复杂的时候，可以将对象的”创建”和”表示”分割开来；从而可以使一个构造过程创建具有不同表示的产品。这种参见对象的方式就是建造模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://smartliby.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="https://smartliby.github.io/tags/java/"/>
    
      <category term="建造模式" scheme="https://smartliby.github.io/tags/%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
