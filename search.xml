<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu+Hexo+Github Pages搭建个人博客]]></title>
    <url>%2F2020%2F04%2F06%2FUbuntu-Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我的个人博客其实若干年前就搭建完成并投入使用了，但是比较懒一直没有写笔记，最近发现百度爬虫没有收录我的个人博客文章，研究了一下发现是github把百度爬虫给禁掉了，解决一下顺便补一下笔记吧 安装NodejsNode.js是基于Chrome V8引擎的JavaScript运行环境，npm是随Node.js一起安装的包管理工具，新版的Node.js集成了npm。 12sudo apt install nodejssudo apt install npm 检查node版本：node -v 1v8.10.0 检查npm版本：npm -v 16.9.0 安装HexoHexo是一个基于node.js的快速、简洁且高效的博客框架，支持Markdown解析文章。简言之，hexo将Markdown编写的文章生成为静态html页面，然后部署到github。安装hexo：sudo npm install -g hexo。在指定文件夹新建所需的文件： 123hexo init &lt;blog-name&gt;cd &lt;blog-name&gt;npm install 该位置就是hexo的工作空间，该工作空间的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中，_config.yml是博客网站的配置文件,source文件夹是存放用户资源的地方，_posts 文件夹存放Markdown文件（.md），scaffolds是模板文件夹，当用hexo新建文章时，hexo会根据scaffolds文件夹下的文件来建立文件，themes文件夹是存放主题的文件夹，hexo根据主题生成静态页面。关于_config.yml的补充说明：其中工作空间根目录下有一个_config.yml，是博客网站的配置文件，themes文件夹中对应不同主题的目录下也有一个_config.yml文件夹，是主题的配置文件。 配置Hexohexo常用命令 命令 作用 简写 hexo init “folder-name” 新建一个网站 hexo new “title-name” 新建一篇文章 hexo clean 清除缓存文件 hexo generate 生成静态文件 hexo g hexo server 启动服务器，默认服务器网址：http://localhost:4000/ hexo s hexo deploy 部署网站 hexo d 更换主题默认主题为landscape，更换为next或其它主题。下载主题命令： 12git clone https://github.com/theme-next/hexo-theme-nextgit pull 我一般会在自己的github保存hexo-theme-next主题，这样方便个性化修改保存，我的主题地址大家可以参考下 1git@github.com:smartliby/hexo-theme-next.git 采用git命令克隆主题文件，以后更新可以通过git pull命令来快速更新，而不用再次下载安装包进行替换。打开_config.yml文件，修改theme为next。然后运行： 123hexo cleanhexo ghexo s 打开http://localhost:4000/可以发现主题更改了。 安装配置github首先查看是否已经安装git，git --version，一般ubuntu自带git。若没有安装采用sudo apt install git进行安装。 配置github命令行输入： 12git config --global user.name &quot;your user name&quot;git config --global user.email &quot;your email address&quot; 创建公钥命令行输入： 1ssh-keygen -C &apos;your email address&apos; -t rsa 一直按回车直至结束，结束后会在～/.ssh/下建立密钥文件，即~/.ssh/id_rsa_pub，打开该文件，复制全部内容。 github添加公钥点击个人头像—&gt;settings—&gt;SSH and GPG keys—&gt;New SSH key，粘贴刚才复制的文本。 创建项目仓库在github页面，选择New repository，Respository name输入username.github.io，点击确定。 hexo将静态页面部署到github打开hexo目录下的_config.yml，在最后添加： 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master master分支托管public目录下的静态网页代码，source分支托管markdown源码，这样就不用担心源码丢失了，就算电脑丢了也不怕，同时也方便管理，平时在source分支开发即可。 我平时写文章的流程： hexo new “title-name” hexo g 生成静态网页代码 hexo d push到远程master分支 在source分支执行 git add -A git commit -m &quot;提交内容&quot; git push 然后安装hexo插件： 1npm install hexo-deployer-git --save 最终进行部署，命令行输入： 123hexo cleanhexo ghexo d 现在就可以通过username.github.io访问你的博客了！ 丰富博客功能安装一些插件或者配置 gitalk 评论功能 busuanzi 极简网页计数器 local_search 搜索功能 google_analytics 网站运行情况分析 baidu_analytics 网站运行情况分析 google_site_verification 验证网站所有权,SEO优化 baidu_site_verification 验证网站所有权,SEO优化 needmoreshare2 分享功能 以上是本人使用的一些插件和配置，大家参考一下，可根据自己情况选择安装和配置,具体安装和配置方法可自行google 绑定域名首先申请域名，我是在阿里云申请的，需要备案 域名解析配置,添加一条CNAME记录 github pages 上 CNAME 文件配置 方法1：静态源码中添加CNAME文件，内容为申请的域名并执行hexo g hexo d部署到github上 方法2：直接在github.io仓库的Settings的GitHub Pages项直接设置Custom domain,github会自动添加CNAME文件 现在使用申请的域名访问一下试试吧 解决百度爬虫无法爬取 Github Pages 个人博客问题网上有很多方法可以使百度爬虫爬取博客页面，总结起来主要有： CDN，利用云服务提供商将 blog 多做几个镜像。 换托管平台，比如说国内的代码托管平台。 自行使用 VPS 托管。 CDN 比较贵还不完美，不适合小流量网站，又不想换托管平台，VPS 大陆访问速度不快。 有没有简单、可靠还免费的方法？ 有，真的有，zeit.co就是目前比较好的一个选择，一个静态网页和无状态函数托管的云平台。试用了之后，感觉非常强大，它能够以 Github App 的形式与 GitHub 集成，接管 repo 的 CI，进行深度定制，并且能够快速部署、自动伸缩。 关键是，现在基本功能是免费的，这对于我们托管博客来说，已经很够用了。更惊喜的是，它还提供智能 CDN 和智能 DNS 本质上他们提供了 Storage + CDN + DNS 这一套完整服务。根据他们的文档，整个过程我只需要： 用我的 Github 账户登陆 Import Project—&gt;Import Git Repository—&gt;给zeit 我的静态网页 repo 的 read 权限 导入过程中，选择 other 模板即可，默认 ci 命令不用改，Root Directory 也不用改，导入完成后就会自动帮你 deploy。 等几秒，importing 部署成功！ 不用写任何 code，点两下鼠标就完事了。部署完成后，会生成一个类似于 xxxxxxx.now.sh 的链接，点击即可访问，静态资源已经部署到了他们的边缘 CDN 节点上。 接着在zeit.co设置域名 Selecting Your Project—&gt;Settings—&gt;Domains—&gt;Entering Your Chosen Domain—&gt;Add the Domain 这时候它会报错，因为你的域名还没有添加解析。这里，他们推荐的方式是让你的域名使用他们的Nameserver，或者说让他们提供DNS解析服务。但是我这里选择CNAME的方式。因为我一直使用的是cloudflare的DNS解析，我申请的域名之前是为梯子用的，cloudflare的CDN免费并且支持websocket，所以我这里就继续这么用了，在cloudflare上添加 CNAME 记录就行了，内容为上图的value值：alias.zeit.co。 如果还是报错的话，你可以试着删除（先点击“Edit”按钮，然后点击“Remove”）后重新添加，如下图即表示设置成功了 百度爬取最后在百度站长工具页面，在 数据监控 &gt; 抓取诊断，进行测试，测试通过后选择链接提交以sitemap方式提交链接即可，之后百度就会开始爬取我们的博客了 参考[1] 解决百度爬虫无法爬取 Github Pages 个人博客的问题：https://zpjiang.me/2020/01/15/let-baidu-index-github-page/[2] zeit.co 帮助文档：https://zeit.co/docs[3] 使用 zeit.co 托管 Hexo 静态博客：https://www.qtmuniao.com/2020/03/15/hexo-to-zeit-co/[4] 域名绑定：https://segmentfault.com/a/1190000011203711[5] zeit域名解析：https://blog.solariar.tech/2020/how-this-site-work-v2/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>ubuntu</tag>
        <tag>gitHub pages</tag>
        <tag>zeit.co</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过阿里云容器镜像服务下载gcr.io镜像]]></title>
    <url>%2F2020%2F04%2F05%2F%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E4%B8%8B%E8%BD%BDgcr-io%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[安装k8s时发现好多镜像都是gcr.io上的，在国内由于被墙而不能正常下载，也就导致了集群不能正常安装。那么问题来了，要怎样才能下载这些镜像呢？我们要寻找免费下载gcr.io镜像的途径，阿里云就提供了这一服务。本文通过github设置代码源下载所需的gcr.io镜像。 github创建仓库首先在github创建一个repository，创建好后然后git clone到本地，并在本地创建所需下载的镜像dockerfile，这里本地的目录层级为 镜像名称-&gt;版本号-&gt;dockerfile。创建之后再把所有的文件push到github仓库。这里是我的github上的dockderfile仓库，大家可以follow我的项目 选取其中一个组件的dockerfile，查看其中的内容 12FROM gcr.io/kubeflow-images-public/tensorflow-1.15.2-notebook-cpu:1.0.0MAINTAINER smartliby &lt;liboyuma@qq.com&gt; 里面的内容非常少，就两行，其中第一行是基于某个镜像制作的新镜像，第二行为作者信息。通过这个dockerfile我们就可以看出端倪来了，其实我们什么都没做，就是利用阿里云这个介质帮我们翻墙去下载镜像。 登录阿里云镜像创建镜像仓库 选择镜像构建所依赖的在github仓库 进入刚创建的仓库然后选择构建菜单点击添加构建规则 点击立即构建 构建成功 使用镜像12docker pull registry.cn-beijing.aliyuncs.com/smartliby/tensorflow-1.15.2-notebook-gpu:1.0.0docker tag registry.cn-beijing.aliyuncs.com/smartliby/tensorflow-1.15.2-notebook-gpu:1.0.0 gcr.io/kubeflow-images-public/tensorflow-1.15.2-notebook-gpu:1.0.0]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>github</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kubeflow 1.0 安装教程]]></title>
    <url>%2F2020%2F04%2F04%2Fkubeflow%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Kubeflow是Google推出的基于kubernetes环境下的机器学习组件，通过Kubeflow可以实现对TFJob等资源类型定义，可以像部署应用一样完成在TFJob分布式训练模型的过程。最初的设计是将Kubernetes和Tensorflow结合实现对Tensorflow分布式训练的支持。但是仅仅实现对Tensorflow的支持还是远远不够的，Kubeflow社区又陆续对各种深度学习框架进行支持,例如:MXNet, Caffee, PyTorch等。使得机器学习算法同学只需关心算法实现，而后续的模型训练和服务上线都交给平台来做,解放算法同学使其专做自己擅长的事儿。 目前Kubeflow仅支持在v1.15.11及以下版本的k8s上部署，v1.16及以上存在兼容性问题，具体情况可参考这篇文章，接下来我们基于Microk8s（版本1.15/stable）部署kubeflow v1.0 安装 knative v0.7.1kubeflow安装时依赖knative和istio组件，所以需要先安装knative，istio(microk8s安装时已安装microk8s.enable istio，不需要再安装)，knative 的镜像是用 sha256 方式来 pull的。在本地我们不能通过 docker tag 的方式重新打包，只能修改 yaml 里的所有配置 默认knative的安装配置文件在/snap/microk8s/current/actions/knative/目录下，没有操作权限无法修改，需要先拷贝出来或者去github下载到本地，并将里面的镜像下载域名由gcr.io改成gcr.azk8s.cn 12345# 安装 Knative CRDkubectl apply --selector knative.dev/crd-install=true -f serving.yaml# 再运行一遍 kubectl applykubectl apply -f serving.yaml 验证 knative 安装运行kubectl get pods --namespace knative-serving验证 Knative 所有 pod 是否可以正常启动 1234567NAME READY STATUS RESTARTS AGEactivator-55f6c8d9b-2hs77 2/2 Running 24 2d13hautoscaler-78d575f875-l7zfj 2/2 Running 18 2d13hcontroller-776478fb94-hmmxc 1/1 Running 3 2d13hnetworking-certmanager-779cd6f448-xtvrb 1/1 Running 3 2d13hnetworking-istio-674bd78b75-688gc 1/1 Running 3 2d13hwebhook-59b575dc79-cs7f4 1/1 Running 0 13h 安装kubeflow下载 kfctl binary from the Kubeflow releases page 解压安装包并添加到执行目录 12tar -xvf kfctl_v1.0.1-0-gf3edb9b_linux.tar.gzsudo cp kfctl /usr/bin 设置环境 1234export BASE_DIR=/data/export KF_NAME=my-kubeflowexport KF_DIR=$&#123;BASE_DIR&#125;/$&#123;KF_NAME&#125;export CONFIG_URI=&quot;https://raw.githubusercontent.com/kubeflow/manifests/v1.0-branch/kfdef/kfctl_k8s_istio.v1.0.1.yaml&quot; 部署kubeflow 1234mkdir -p $&#123;KF_DIR&#125;cd $&#123;KF_DIR&#125;kfctl apply -V -f $&#123;CONFIG_URI&#125;kubectl -n kubeflow get all 输出如下日志即安装成功 查看当前 Kubernetes pods 状态 1kubectl get pods --namespace kubeflow 发现kubeflow的pod大部分没有启动成功，原因还是网络问题，需要访问gcr.io下载镜像 执行以下脚本将镜像下载到本地并导入到microk8s 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/env bashecho ""echo "=========================================================="echo "pull kubeflow v1.0 images from gcr.azk8s.cn ..."echo "=========================================================="echo ""ORIGINAL_REGISTRY=gcr.ioMY_REGISTRY=gcr.azk8s.cngcr_imgs=( "kfserving/kfserving-controller:0.2.2" "ml-pipeline/api-server:0.2.0" "kubeflow-images-public/kfam:v1.0.0-gf3e09203" "kubeflow-images-public/ingress-setup:latest" "kubeflow-images-public/kubernetes-sigs/application:1.0-beta" "kubeflow-images-public/centraldashboard:v1.0.0-g3ec0de71" "kubeflow-images-public/jupyter-web-app:v1.0.0-g2bd63238" "kubeflow-images-public/katib/v1alpha3/katib-controller:v0.8.0" "kubeflow-images-public/katib/v1alpha3/katib-db-manager:v0.8.0" "kubeflow-images-public/katib/v1alpha3/katib-ui:v0.8.0" "kubebuilder/kube-rbac-proxy:v0.4.0" "metacontroller/metacontroller:v0.3.0" "kubeflow-images-public/metadata:v0.1.11" "ml-pipeline/envoy:metadata-grpc" "tfx-oss-public/ml_metadata_store_server:v0.21.1" "kubeflow-images-public/metadata-frontend:v0.1.8" "ml-pipeline/visualization-server:0.2.0" "ml-pipeline/persistenceagent:0.2.0" "ml-pipeline/scheduledworkflow:0.2.0" "ml-pipeline/frontend:0.2.0" "ml-pipeline/viewer-crd-controller:0.2.0" "kubeflow-images-public/notebook-controller:v1.0.0-gcd65ce25" "kubeflow-images-public/profile-controller:v1.0.0-ge50a8531" "kubeflow-images-public/pytorch-operator:v1.0.0-g047cf0f" "spark-operator/spark-operator:v1beta2-1.0.0-2.4.4" "spark-operator/spark-operator:v1beta2-1.0.0-2.4.4" "google_containers/spartakus-amd64:v1.1.0" "kubeflow-images-public/tf_operator:v1.0.0-g92389064" "kubeflow-images-public/admission-webhook:v1.0.0-gaf96e4e3")for img in $&#123;gcr_imgs[@]&#125;do # 拉取镜像 docker pull $&#123;MY_REGISTRY&#125;/$&#123;img&#125; # 添加Tag docker tag $&#123;MY_REGISTRY&#125;/$&#123;img&#125; $&#123;ORIGINAL_REGISTRY&#125;/$&#123;img&#125; # 输出 docker save $&#123;ORIGINAL_REGISTRY&#125;/$&#123;img&#125; &gt; $&#123;img##*/&#125;.tar # 输入 microk8s.ctr -n k8s.io image import $&#123;img##*/&#125;.tar # 删除Tag docker rmi $&#123;MY_REGISTRY&#125;/$&#123;img&#125; $&#123;ORIGINAL_REGISTRY&#125;/$&#123;img&#125;doneecho ""echo "=========================================================="echo "pull kubeflow v1.0 images from gcr.azk8s.cn finished."echo "=========================================================="echo "" 如果还是有pod无法启动，可通过kubectl describe pod 未启动pod的名称 -n kubeflow查看原因 如果是因为镜像无法下载，可以将依赖的镜像加到上面的脚本里下载镜像 如果是因为镜像拉取策略导致每次都重新下载问题，可通过下面命令或者kubernetes-dashboard修改，将Always 改为 IfNotPresent 1kubectl edit pod 未启动pod的名称 -n kubeflow 执行 kubectl get pods --namespace kubeflow查看kubeflow的pod都已运行起来 123456789101112131415161718192021222324252627282930313233343536NAME READY STATUS RESTARTS AGEadmission-webhook-bootstrap-stateful-set-0 1/1 Running 6 2d4hadmission-webhook-deployment-569558c8b6-n8b7k 1/1 Running 0 13happlication-controller-stateful-set-0 1/1 Running 3 2d4hargo-ui-7ffb9b6577-w8pb7 1/1 Running 7 3d7hcentraldashboard-659bd78c-fxgqd 1/1 Running 3 3d7hjupyter-web-app-deployment-878f9c988-xgh82 1/1 Running 3 2d5hkatib-controller-7f58569f7d-8bw7z 1/1 Running 4 3d7hkatib-db-manager-54b66f9f9d-ngqw9 1/1 Running 3 3d7hkatib-mysql-dcf7dcbd5-7wbck 1/1 Running 12 4d1hkatib-ui-6f97756598-4mtjs 1/1 Running 3 3d7hkfserving-controller-manager-0 2/2 Running 7 2d5hmetacontroller-0 1/1 Running 5 3d7hmetadata-db-65fb5b695d-wq8vh 1/1 Running 12 4d1hmetadata-deployment-65ccddfd4c-vwfd2 1/1 Running 3 3d7hmetadata-envoy-deployment-7754f56bff-svtz2 1/1 Running 3 3d7hmetadata-grpc-deployment-75f9888cbf-zj4sn 1/1 Running 5 3d7hmetadata-ui-7c85545947-v68l7 1/1 Running 3 3d7hminio-69b4676bb7-w96xk 1/1 Running 12 4d1hml-pipeline-5cddb75848-bsc48 1/1 Running 3 2d6hml-pipeline-ml-pipeline-visualizationserver-7f6fcb68c8-vxjj7 1/1 Running 3 2d7hml-pipeline-persistenceagent-6ff9fb86dc-dvxx4 1/1 Running 5 2d6hml-pipeline-scheduledworkflow-7f84b54646-ndxcb 1/1 Running 3 2d7hml-pipeline-ui-6758f58868-gqvlp 1/1 Running 3 2d6hml-pipeline-viewer-controller-deployment-685874bc58-jljw8 1/1 Running 3 2d5hmysql-6bcbfbb6b8-xmphz 1/1 Running 12 4d1hnotebook-controller-deployment-7db7c8589d-mlgb4 1/1 Running 3 2d5hprofiles-deployment-56b7c6788f-kk8kh 2/2 Running 6 2d7hpytorch-operator-cf8c5c497-nmfnv 1/1 Running 7 3d7hseldon-controller-manager-6b4b969447-qp7l4 1/1 Running 20 4d1hspark-operatorcrd-cleanup-rrpxd 0/2 Completed 0 3d7hspark-operatorsparkoperator-76dd5f5688-kn28n 1/1 Running 3 3d7hspartakus-volunteer-5dc96f4447-xjclm 1/1 Running 3 3d7htensorboard-5f685f9d79-9x549 1/1 Running 12 4d1htf-job-operator-5fb85c5fb7-lqvrg 1/1 Running 6 3d7hworkflow-controller-689d6c8846-znvt9 1/1 Running 12 4d1h 执行如下命令进行端口映射访问Kubeflow UI 1nohup kubectl port-forward -n istio-system svc/istio-ingressgateway 8088:80 &amp; 访问http://127.0.0.1:8088/ 创建Jupyter notebook server 点击连接之后就可以跑模型训练了 测试Jupyter创建Python 3 notebook，执行如下代码 123456789101112131415161718192021222324252627from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&quot;MNIST_data/&quot;, one_hot=True)import tensorflow as tfx = tf.placeholder(tf.float32, [None, 784])W = tf.Variable(tf.zeros([784, 10]))b = tf.Variable(tf.zeros([10]))y = tf.nn.softmax(tf.matmul(x, W) + b)y_ = tf.placeholder(tf.float32, [None, 10])cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))train_step = tf.train.GradientDescentOptimizer(0.05).minimize(cross_entropy)sess = tf.InteractiveSession()tf.global_variables_initializer().run()for _ in range(1000): batch_xs, batch_ys = mnist.train.next_batch(100) sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))print(&quot;Accuracy: &quot;, sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;)) 运行结果如下 1Accuracy: 0.9012]]></content>
      <categories>
        <category>kubeflow</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubeflow</tag>
        <tag>microk8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 18.04安装microk8s教程]]></title>
    <url>%2F2020%2F04%2F03%2Fmicrok8s%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Microk8s是一个集成化的容器管理平台，与Kubernetes完全兼容，主要面向工作站、边缘计算和IoT等领域建立容器计算平台。 安装 microk8s1snap install microk8s --classic --channel=1.15/stable 设置别名1sudo snap alias microk8s.kubectl kubectl config配置1sudo microk8s.kubectl config view --raw &gt; $HOME/.kube/config 启用k8s组件1microk8s.enable dashboard dns ingress istio registry storage 如果有GPU1microk8s.enable gpu 执行 microk8s.enable 顺利的话，你将看到类似下面的日志12345678910111213141516171819202122logentry.config.istio.io/accesslog createdlogentry.config.istio.io/tcpaccesslog createdrule.config.istio.io/stdio createdrule.config.istio.io/stdiotcp created......Istio is startingEnabling the private registryEnabling default storage classdeployment.extensions/hostpath-provisioner createdstorageclass.storage.k8s.io/microk8s-hostpath createdStorage will be available soonApplying registry manifestnamespace/container-registry createdpersistentvolumeclaim/registry-claim createddeployment.extensions/registry createdservice/registry createdThe registry is enabledEnabling default storage classdeployment.extensions/hostpath-provisioner unchangedstorageclass.storage.k8s.io/microk8s-hostpath unchangedStorage will be available soon 使用 microk8s.status 检查各个组件的状态1234567891011121314151617microk8s is runningaddons:knative: disabledjaeger: disabledfluentd: disabledgpu: enabledcilium: disabledstorage: enabledregistry: enabledrbac: disabledingress: enableddns: enabledmetrics-server: disabledlinkerd: disabledprometheus: disabledistio: enableddashboard: enabled 使用 microk8s.inspect 排查下安装部署结果123456789101112131415161718Inspecting services Service snap.microk8s.daemon-containerd is running Service snap.microk8s.daemon-docker is running Service snap.microk8s.daemon-apiserver is running Service snap.microk8s.daemon-proxy is running Service snap.microk8s.daemon-kubelet is running Service snap.microk8s.daemon-scheduler is running Service snap.microk8s.daemon-controller-manager is running Service snap.microk8s.daemon-etcd is running Copy service arguments to the final report tarballInspecting AppArmor configurationGathering system info Copy network configuration to the final report tarball Copy processes list to the final report tarball Copy snap list to the final report tarball Inspect kubernetes cluster WARNING: IPtables FORWARD policy is DROP. Consider enabling traffic forwarding with: sudo iptables -P FORWARD ACCEPT 执行如下命令 12sudo ufw default allow routedsudo iptables -P FORWARD ACCEPT 再次使用 microk8s.inspect 命令检查，会发现 WARNING消失了 使用 microk8s.kubectl get pods --all-namespaces 查看当前 Kubernetes pods 状态123456NAMESPACE NAME READY STATUS RESTARTS AGEcontainer-registry registry-7fc4594d64-rrgs9 0/1 Pending 0 15mdefault default-http-backend-855bc7bc45-t4st8 0/1 ContainerCreating 0 16mdefault nginx-ingress-microk8s-controller-kgjtl 0/1 ContainerCreating 0 16m...... 大部分pod都没有启动起来，什么原因呢？ 使用 describe 命令查看 pod1kubectl describe pod default-http-backend -n container-registry 日志如下 1234Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedCreatePodSandBox 22m (x33 over 69m) kubelet, izwz9h8m2chowowqckbcy0z Failed create pod sandbox: rpc error: code = Unknown desc = failed to get sandbox image &quot;k8s.gcr.io/pause:3.1&quot;: failed to pull image &quot;k8s.gcr.io/pause:3.1&quot;: failed to resolve image &quot;k8s.gcr.io/pause:3.1&quot;: no available registry endpoint: failed to do request: Head https://k8s.gcr.io/v2/pause/manifests/3.1: dial tcp 108.177.97.82:443: i/o timeout 这是 pod 的 sandbox 镜像拉取失败。 网上查资料，k8s.gcr.io/pause:3.1 是存放在 google cloud 上的镜像，由于众所周知的原因，访问失败了。 解决的方法有： 科学上网 手动下载镜像 方法1操作流程编辑 MicroK8s 使用的 docker 环境变量配置文件，vim /var/snap/microk8s/current/args/containerd-env在其中添加代理配置 1HTTPS_PROXY=https://127.0.0.1:8123 重启 docker 1sudo systemctl restart snap.microk8s.daemon-docker.service 重置 MicroK8s 并再次尝试安装各种组件 12microk8s.resetmicrok8s.enable dashboard dns ingress istio registry storage 方法2操作流程安装 docker 1sudo apt install docker-ce 感谢微软 azure 提供 gcr 镜像下载：地址 12docker pull gcr.azk8s.cn/google_containers/pause:3.1docker tag gcr.azk8s.cn/google_containers/pause:3.1 k8s.gcr.io/pause:3.1 v1.14 之后 microk8s 使用 containerd 代替 dockerd，具体可见这个issue Indeed in the 1.14 release contanerd replaced dockerd. 要么使用私有仓库 registry，要么手动把 docker 镜像导入到 containerd。microk8s 官网提供了例子：Working with locally built images without a registry。 这里先使用手动操作，以后再建立私有仓库 12docker save k8s.gcr.io/pause:3.1 &gt; pause.tarmicrok8s.ctr -n k8s.io image import pause.tar -n 是指定 namespace。microk8s.ctr -n k8s.io image ls，看到导入的镜像了： 1k8s.gcr.io/pause:3.1 application/vnd.oci.image.manifest.v1+json sha256:3efe4ff64c93123e1217b0ad6d23b4c87a1fc2109afeff55d2f27d70c55d8f73 728.9 KiB linux/amd64 io.cri-containerd.image=managed 其他组件如果遇到gcr.io无法访问的情况也可使用如上的方法，这里特别写了个脚本来自动下载并导入这些镜像 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env bashecho ""echo "=========================================================="echo "pull microk8s v1.15.11 images from gcr.azk8s.cn ..."echo "=========================================================="echo ""gcr_imgs=( "gcr.azk8s.cn/google_containers/pause:3.1,k8s.gcr.io/pause:3.1" "gcr.azk8s.cn/google_containers/heapster-influxdb-amd64:v1.3.3,k8s.gcr.io/heapster-influxdb-amd64:v1.3.3" "gcr.azk8s.cn/google_containers/heapster-grafana-amd64:v4.4.3,k8s.gcr.io/heapster-grafana-amd64:v4.4.3" "gcr.azk8s.cn/google_containers/kubernetes-dashboard-amd64:v1.10.1,k8s.gcr.io/google_containers/kubernetes-dashboard-amd64:v1.10.1" "gcr.azk8s.cn/google_containers/heapster-amd64:v1.5.2,k8s.gcr.io/heapster-amd64:v1.5.2" "gcr.azk8s.cn/google_containers/defaultbackend-amd64:1.4,gcr.io/google_containers/defaultbackend-amd64:1.4")for img in $&#123;gcr_imgs[@]&#125;do img_array=($&#123;img//,/ &#125;) # 拉取镜像 docker pull $&#123;img_array[0]&#125; # 添加Tag docker tag $&#123;img_array[0]&#125; $&#123;img_array[1]&#125; # 输出 docker save $&#123;img_array[1]&#125; &gt; $&#123;img_array[1]##*/&#125;.tar # 输入 microk8s.ctr -n k8s.io image import $&#123;img_array[1]##*/&#125;.tar # 删除Tag docker rmi $&#123;img_array[0]&#125; $&#123;img_array[1]&#125;doneecho ""echo "=========================================================="echo "pull microk8s v1.15.11 images from gcr.azk8s.cn finished."echo "=========================================================="echo "" 使用 microk8s.kubectl get pods --all-namespaces 继续进行验证 123456789101112131415161718192021222324252627282930NAMESPACE NAME READY STATUS RESTARTS AGEcert-manager cert-manager-5d849b9888-8nh9j 1/1 Running 12 3d18hcert-manager cert-manager-cainjector-dccb4d7f-7rrkf 1/1 Running 15 3dcert-manager cert-manager-webhook-695df7dbb-gpsqs 1/1 Running 12 3d18hcontainer-registry registry-6c99589dc-gttcq 1/1 Running 15 4d4hdefault default-http-backend-5d5ff5d4f5-g9h8h 1/1 Running 15 4d4hdefault nginx-ingress-microk8s-controller-td2mz 1/1 Running 59 3h26mistio-system cluster-local-gateway-7bf56777fb-rbjjn 1/1 Running 12 3d18histio-system grafana-6575997f54-j77rc 1/1 Running 6 3distio-system istio-citadel-894d98c85-xr8qm 1/1 Running 12 3d19histio-system istio-cleanup-secrets-1.2.2-l4djr 0/1 Completed 0 3d19histio-system istio-egressgateway-9b7866bf5-h8ltc 1/1 Running 10 3distio-system istio-galley-5b984f89b-w26n9 1/1 Running 0 6h43mistio-system istio-grafana-post-install-1.2.2-v5sfg 0/1 Completed 0 3d19histio-system istio-ingressgateway-75ddf64567-glfkm 1/1 Running 12 3d19histio-system istio-pilot-5d77c559d4-nhc7d 2/2 Running 14 3distio-system istio-policy-86478df5d4-w2lgb 2/2 Running 46 3distio-system istio-security-post-install-1.2.2-sczrc 0/1 Completed 0 3d19histio-system istio-sidecar-injector-7b98dd6bcc-g597g 1/1 Running 8 3distio-system istio-telemetry-786747687f-t8k6k 2/2 Running 35 3distio-system istio-tracing-555cf644d-4d9f4 1/1 Running 13 3d19histio-system kfserving-ingressgateway-64c7bd9b76-2rcxt 1/1 Running 12 3d18histio-system kiali-6cd6f9dfb5-tlwzq 1/1 Running 13 3d19histio-system prometheus-7d7b9f7844-swqf8 1/1 Running 19 3d19hkube-system coredns-f7867546d-wkv76 1/1 Running 15 4d4hkube-system heapster-v1.5.2-844b564688-kr9t8 4/4 Running 60 4d4hkube-system hostpath-provisioner-65cfd8595b-rjlhz 1/1 Running 5 3dkube-system kubernetes-dashboard-7d75c474bb-s7n2t 1/1 Running 15 4d4hkube-system monitoring-influxdb-grafana-v4-6b6954958c-spcqb 2/2 Running 32 4d4hkube-system nvidia-device-plugin-daemonset-jv96f 1/1 Running 14 3d23h 如果你看到的结果类似上面这样，说明 Kubernetes 是真的就绪了。 查看 Dashboardmicrok8s.kubectl describe service kubernetes-dashboard -n kube-system获取访问ip和端口 123456789Name: kubernetes-dashboardNamespace: kube-systemLabels: k8s-app=kubernetes-dashboardAnnotations: kubectl.kubernetes.io/last-applied-configuration: &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;labels&quot;:&#123;&quot;k8s-app&quot;:&quot;kubernetes-dashboard&quot;&#125;,&quot;name&quot;:&quot;kubernetes-dashboard&quot;...Selector: k8s-app=kubernetes-dashboardType: ClusterIPIP: 10.152.183.151Port: &lt;unset&gt; 443/TCP 接着访问下面的地址，就能看到我们熟悉的 Dashboard 1https://10.152.183.151/ 使用令牌登录获取token 123token=$(microk8s kubectl -n kube-system get secret | grep default-token | cut -d " " -f1) echo $tokenmicrok8s kubectl -n kube-system describe secret $token 输入token后就进入管理页面了]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>microk8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac、Ubuntu系统的下载神器aria2]]></title>
    <url>%2F2019%2F05%2F12%2FMac%E3%80%81Ubuntu%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%A5%9E%E5%99%A8aria2%2F</url>
    <content type="text"><![CDATA[背景Mac 用户肯定都受够了百度网盘在自己电脑上的糟糕体验，至少我是如此：安装官方的 App，经常下载时中断，有时甚至 Bug 般连续中断，无奈使用浏览器下载，速度却是令人挠头。花点时间来配置 aria2，结合 Chrome，一定让你舒心 aria2 是什么？ aria2 是一款支持多种协议的轻量级命令行下载工具。有以下特性： 多线程连线：aria2 会自动从多个线程下载文件，并充分利用你的带宽； 轻量：运行时不会占用过多资源，根据官方介绍，内存占用通常在 4MB~9MB，使用 BitTorrent 协议，下行速度 2.8MB/s 时 CPU 占用率约 6%； 全功能 BitTorrent 客户端； 支持 RPC 界面远程控制（下文重点介绍）。 开始吧 1.安装 aria21brew install aria2 2.设置配置文件aria2 提供两种方式使用，一种是直接命令行模式下载，不推荐使用这种方法，推荐使用另外一种 RPC 模式，这种方式 aria 启动之后只会安静的等待下载请求，下载完成后也只会安静的驻留后台不会自动退出。而使用RPC模式推荐做一个配置文件方便使用。我们把配置文件放在 ~/.aria2 下，依次输入命令： 1234cd ~mkdir .aria2cd .aria2vim aria2.conf 复制以下内容到aria2.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#用户名#rpc-user=user#密码#rpc-passwd=passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret=token#允许rpcenable-rpc=true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all=true#允许外部访问，false的话只监听本地端口rpc-listen-all=true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port=6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads=5#断点续传continue=true#同服务器连接数max-connection-per-server=5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10#下载速度限制max-overall-download-limit=0#单文件速度限制max-download-limit=0#上传速度限制max-overall-upload-limit=0#单文件速度限制max-upload-limit=0#断开速度过慢的连接#lowest-speed-limit=0#验证用，需要1.16.1之后的release版本#referer=*#文件保存路径, 默认为当前启动位置dir=/Users/xxx/Downloads#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache=0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap=true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持file-allocation=prealloc 默认下载路径的「/Users/xxx/Downloads」可以改为任何你想要的绝对路径。此处写为 Downloads 目录，xxx 请自行替换成你的 Mac 用户名，然后保存，退出编辑器。 3.启动 RPC 模式在终端输入aria2c –conf-path=”/Users/xxxxxx/.aria2/aria2.conf” -D，然后 aria2 就启动了，但是如何搞定百度网盘？还需要在Chrome网上应用商店下载百度网盘助手插件。 4.访问webUI首先从github中克隆webui-aria2项目 1git clone https://github.com/ziahamza/webui-aria2 方法一：不需创建任何 web 服务器，只需直接双击运行 index.html 方法二：在终端执行下面的命令 1python -m SimpleHTTPServer 6801 在浏览器中访问http://localhost:6801 即可 5.如何进行下载操作随便打开一个百度网盘的链接，会发现网页上多出一个「导出下载」按钮，点击它弹出的「ARIA2 RPC」就自动添加到你的下载队列里了，然后利用 这里 提供的网页界面管理你的下载任务，如下图所示，你可以利用图形界面进行许多操作： 6.关闭 aria2如果你想关掉后台的 aria2，可以到活动监视器中找到 aria2c 杀掉 7.设置aria2开机自动启动在家目录 /Users/liby/ 执行 vim aria2-starter,然后添加如下内容 1234#!/bin/basharia2c --conf-path=&quot;/Users/liby/.aria2/aria2.conf&quot; -Dnohup python -m SimpleHTTPServer 6801 &amp;exit 设置该脚本为可执行文件最后在 系统偏好设置-&gt;用户与组群-&gt;登录项 添加该执行脚本 8.总结通过 Aria2 下载后，速度一般可达300KB以上，如果不用，同一个文件可能才只有几十或者100K左右的速度，这个差别真是非常大啊！]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>aria2</tag>
        <tag>系统设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04系统工作环境设置]]></title>
    <url>%2F2017%2F03%2F11%2FUbuntu16-04%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主题美化1.执行以下命令安装Flatabulous主题 1234sudo apt-get install unity-tweak-toolsudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme 2.该主题有配套的图标，安装方式如下 123sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons 3.安装完成后，打开unity-tweak-tool软件，修改主题和图标 4.进入Theme，修改为Flatabulous 5.在此界面下进入Icons栏，修改为Ultra-flat 6.安装字体YaHei Consolas Hybrid 1234要想安装这款字体，首先需要安装 Font Manager (字体管理)软件。sudo apt-get install font-managergoogle搜索 YaHei.Consolas 下载这款字体。在 Font Manager 中点击 Manager Fonts - Install Fonts ，就可以安装 ttf 字体了。 系统更新12sudo apt-get updatesudo apt-get upgrade 安装vim1sudo apt-get install vim 安装 maximum-awesome-linux12git clone https://github.com/smartliby/maximum-awesome-linux.gitcd maximum-awesome-linux &amp;&amp; rake 安装zsh、oh-my-zsh安装zsh 1sudo apt install zsh via curl download Oh My Zsh 1sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 切换到zsh 1chsh -s /usr/bin/zsh 安装terminatorUbuntu自带的终端是gnome-terminal，虽然也还不错，但是不能支持屏幕分割、选择复制等功能让我很不爽，于是我换用terminator作为终端，terminator可以支持屏幕分割，并且默认快捷键和gnome-terminal无异，熟悉gnome-terminal的话可以快速上手。 Ubuntu下可以这样安装terminator 1sudo apt-get install terminator terminator常用快捷键 Ctrl-Shift-c 拷贝 Ctrl-Shift-v 粘贴 Ctrl-Shift-t 开新Tab窗口 Ctrl-Shift-o 上下拆分屏幕 Ctrl-Shift-e 左右拆分屏幕 Ctrl-Shift-w 关闭当前窗口 Ctrl-Shift-q 关闭整个终端 配置terminator使用solarized配色 12mkdir -p ~/.config/terminator/curl https://raw.github.com/ghuntley/terminator-solarized/master/config &gt; ~/.config/terminator/config 然后重新打开terminator就已经是solarized配色了。 对terminator更多的配置 接下来，可以在terminator-solarized配置文件的基础上进行更多的配置，例如背景透明、启用选择复制等。 关于terminator的详细配置选项可以参考terminator manpage，下面贴出我的~/.config/terminator/config供参考： 12345678910111213141516171819202122232425262728293031323334353637383940[global_config] title_transmit_bg_color = "#d30102" focus = system suppress_multiple_term_dialog = True[keybindings][profiles] [[default]] palette = "#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3" copy_on_selection = True background_image = None background_darkness = 0.95 background_type = transparent use_system_font = False cursor_color = "#eee8d5" foreground_color = "#839496" show_titlebar = False font = Monospace 11 background_color = "#002b36" [[solarized-dark]] palette = "#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3" background_color = "#002b36" background_image = None cursor_color = "#eee8d5" foreground_color = "#839496" [[solarized-light]] palette = "#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3" background_color = "#fdf6e3" background_image = None cursor_color = "#002b36" foreground_color = "#657b83"[layouts] [[default]] [[[child1]]] type = Terminal parent = window0 profile = default [[[window0]]] type = Window parent = ""[plugins] 配置dircolors 完成上述配置后，你会发现用ls命令查看目录和文件时是一片灰色。这是因为默认情况下solarized各种bright方案基本都是灰色，而系统默认显示目录和文件时多用bright色，此时需要配置dircolors才能显示出彩色的文件和目录。 dircolors-solarized项目提供了适合于solarized的dircolors配色方案，只要选择合适的方案使用就可以了。例如我是用的solarized dark配色，所以可以选择适合这个配色的dircolors.ansi-dark 1curl https://raw.github.com/seebi/dircolors-solarized/master/dircolors.ansi-dark &gt; ~/.dircolors 然后在~/.zshrc中加入如下配置： 12345678910111213141516# enable color support of ls and also add handy aliasesif [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors &amp;&amp; eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto'fi# some more ls aliasesalias ll='ls -alF'alias la='ls -A'alias l='ls -CF' 执行 1source ~/.zshrc 后，再执行ls或ll就可以看到彩色的目录或文件了。 配置完的terminator效果如下： 安装jdk1.81234567891011121.下载jdk，因为oracle现在要同意协议才能下载，直接使用wget加链接下载不到，所以要加上前面的那些代码 wget --no-check-certificate --no-cookie --header "Cookie: oraclelicense=accept-securebackup-cookie;" http://download.oracle.com/otn-pub/java/jdk/8u121-b13/jdk-8u121-linux-x64.tar.gz2.安装jdk tar -zxvf jdk-8u121-linux-x64.tar.gz3.设置环境变量 vim /home/liby/.zshrc,添加如下内容 export JAVA_HOME=/home/liby/local/jdk1.8.0_121/ export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export MAVEN_HOME=/home/liby/local/apache-maven-3.3.9 export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;MAVEN_HOME&#125;/bin:$PATH4.刷新配置文件 source /home/liby/.zshrc 安装maven1234567891011121.下载maven wget http://mirror.cc.columbia.edu/pub/software/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz2.安装maven tar -zxvf apache-maven-3.3.9-bin.tar.gz3.设置环境变量 vim /home/liby/.zshrc,添加如下内容 export JAVA_HOME=/home/liby/local/jdk1.8.0_121/ export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export MAVEN_HOME=/home/liby/local/apache-maven-3.3.9 export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;MAVEN_HOME&#125;/bin:$PATH4.刷新配置文件 source /home/liby/.zshrc 下载chrome123wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo dpkg -i google-chrome-stable_current_amd64.deb登录账号并同步数据 安装搜狗输入法12wget http://cdn2.ime.sogou.com/dl/index/1475147394/sogoupinyin_2.1.0.0082_amd64.deb?st=_vb5fHHeRyUHCwduavC5Qw&amp;e=1489585347&amp;fn=sogoupinyin_2.1.0.0082_amd64.debsudo dpkg -i sogoupinyin_2.1.0.0082_amd64.deb 安装virtualbox12wget http://download.virtualbox.org/virtualbox/5.1.16/virtualbox-5.1_5.1.16-113841~Ubuntu~xenial_amd64.debsudo dpkg -i virtualbox-5.1_5.1.16-113841~Ubuntu~xenial_amd64.deb 安装idea123wget https://download.jetbrains.8686c.com/idea/ideaIU-2016.3.5.tar.gztar -zxvf ideaIU-2016.3.5.tar.gz安装插件：scala,.ignore,python,Markdown Navigator2.3.2破解版,VisualVM Launcher 安装pycharm123wget https://download.jetbrains.8686c.com/python/pycharm-professional-2016.3.2.tar.gztar -zxvf pycharm-professional-2016.3.2.tar.gz安装插件：.ignore,Markdown Navigator2.3.2破解版 修复idea和pycharm字体模糊锯齿和乱码等现象设置字体为YaHei Consolas Hybrid，同时支持中英文 idea与系统冲突的快捷键设置1234561.Change or disable the Lock Screen action, assigned to Ctrl + Alt + L (Reformat code)2.Change or disable the Launch terminal action, assigned to Ctrl + Alt + T (Surround with)3.Change or disable the Switch to workspace action, assigned to Ctrl + Alt + Arrow Keys(Navigation)4.Disable the Move window action, assigned to Alt + F7 (Find usages)5.Change or disable the Resize window action, assigned to Alt + F8 (Evaluate expression)6.Fcitx输入法激活快捷键，assigned to Ctrl + 空格 (code completion basic) 解决办法是打开系统设置中的键盘，修改冲突的快捷键，将系统的快捷键禁用或者修改idea快捷键。 1234561.修改idea快捷键为Ctrl + L2.用的地方不多，先不修改了3.窗口中的移动窗口禁用4.导航中的切换至左侧工作区/切换至右侧工作区/切换至侧上工作区/切换至下侧工作区禁用5.窗口中的调整窗口大小禁用6.禁用Fcitx输入法激活快捷键 安装atom12wget https://atom-installer.github.com/v1.15.0/atom-amd64.deb?s=1489019656&amp;ext=.debsudo dpkg -i atom-amd64.deb 安装插件：markdown-writer、autocomplete-python、ile-icons、git-control、language-hql、markdown-pdf、pdf-view、activate-power-mode 安装markdown神器1234567# optional, but recommendedsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE# add Typora's repositorysudo add-apt-repository 'deb https://typora.io ./linux/'sudo apt-get update# install typorasudo apt-get install typora 截图工具1sudo apt-get install shutter 网易云音乐123wget http://s1.music.126.net/download/pc/netease-cloud-music_1.0.0_amd64_ubuntu16.04.debsudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb登录账号并同步数据 开启ssh服务，允许远程连接12sudo apt-get install openssh-server这样其他的电脑就可以ssh登录公司的这台电脑了 开启远程桌面服务 1.Dash中打开桌面共享 2.安装并运行dconf-editor，把加密选项去掉 12sudo apt-get install dconf-editordconf-editor 依次展开org-&gt;gnome-&gt;desktop-&gt;remote-access这里也可以直接设置远程控制选项，但重要的是将“requre-encryption”去掉。 之后就可以在其他的电脑上使用远程桌面登录了 16.04默认没有打开工作区切换功能需要手动打开，使用起来方便多了。 最终的效果图]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>系统设置</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flume1.7源码调试]]></title>
    <url>%2F2017%2F02%2F14%2FFlume1-7%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[下载源码git clone https://github.com/apache/flume.git 将源码导入Idea 编译时会有以下jar仓库中无法找到并下载，需要手动下载到本地仓库1linq4j-0.4.jar pentaho-aggdesigner-algorithm-5.1.3-jhyde.jar quidem-0.1.1.jar 以上jar文件可以在下面的网站中找到 12http://conjars.org/repo/http://repository.pentaho.org/artifactory/repo/ 执行下面的命令将jar下载到本地仓库 123mvn install:install-file -Dfile=pentaho-aggdesigner-algorithm-5.1.3-jhyde.jar -DgroupId=org.pentaho -DartifactId=pentaho-aggdesigner-algorithm -Dversion=5.1.3-jhyde -Dpackaging=jarmvn install:install-file -Dfile=linq4j-0.4.jar -DgroupId=net.hydromatic -DartifactId=linq4j -Dversion=0.4 -Dpackaging=jarmvn install:install-file -Dfile=quidem-0.1.1.jar -DgroupId=net.hydromatic -DartifactId=quidem -Dversion=0.1.1 -Dpackaging=jar 执行编译命令1mvn clean install -DskipTests 本地调试12主类：org.apache.flume.node.Application参数：-n agent -f /home/liby/local/apache-flume-1.7.0-bin/conf/flume-conf.properties flume-conf.properties 123456789101112131415161718# Name the components on this agentagent.sources = r1agent.sinks = k1agent.channels = c1# Describe/configure the sourceagent.sources.r1.type = netcatagent.sources.r1.bind = localhostagent.sources.r1.port = 44445# Describe the sink# 将数据输出至日志中agent.sinks.k1.type = logger# Use a channel which buffers events in memoryagent.channels.c1.type = memoryagent.channels.c1.capacity = 1000agent.channels.c1.transactionCapacity = 100# Bind the source and sink to the channelagent.sources.r1.channels = c1agent.sinks.k1.channel = c1 运行效果 远程调试在conf/flume-env.properties增加以下配置，然后启动flume 1-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 在idea中启动远程调试]]></content>
      <categories>
        <category>Flume</category>
      </categories>
      <tags>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符编码浅析]]></title>
    <url>%2F2016%2F07%2F14%2Fjava%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[java字符编码浅析 关于这篇文章其实是从一个问题开始的：java中char类型能存储汉字吗？ UTF-8编码UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8的编码规则很简单，只有二条： 1.对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2.对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围(十六进制) UTF-8编码方式(二进制) 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。下面，还是以汉字”严”为例，演示如何实现UTF-8编码。已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。 UTF-16编码UTF-16是Unicode的其中一个使用方式。 UTF是 Unicode TransferFormat，即把Unicode转做某种格式的意思。UTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节 (2字节) 储存，但UTF-16却无法兼容于ASCII编码。UTF-16的大端和小端储存形式都在用。为了弄清楚UTF-16文件的大小端，在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文字档案是以UTF-16编码，其中U+FEFF字符在UNICODE中代表的意义是ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。 实例讲解例1123456789101112String s = &quot;I&apos;m 李博玉&quot;;byte[] charArr = s.getBytes(Charset.forName(&quot;UTF-16&quot;)); for (byte b : charArr) &#123; System.out.printf(&quot;%X &quot;, b); &#125;System.out.println(s.getBytes(Charset.forName(&quot;UTF-16&quot;)).length);charArr = s.getBytes(Charset.forName(&quot;UTF-8&quot;)); for (byte b : charArr) &#123; System.out.printf(&quot;%X &quot;, b); &#125;System.out.println(s.getBytes(Charset.forName(&quot;UTF-8&quot;)).length); 输出的结果是什么呢？FE FF 0 49 0 27 0 6D 0 20 67 4E 53 5A 73 891649 27 6D 20 E6 9D 8E E5 8D 9A E7 8E 8913 1.UTF-16的编码为什么是16？对于大部分字符来讲，UTF-16都使用两个字节来存储。但是UTF-16是支持大小端的，所以需要在字符的开头使用两个字节的额外空间指定好它的字节序，FE FF 表示使用大端存储。7 x 2 + 2 = 162.UTF-8的编码为什么是13？UTF-8是完全兼容ASCII编码的，所以英文是占一个字节，中文大部分占3个字节，不常用的占4个字节4 + 3 x 3 = 13 例2String s1 = “李”;String s2 = ““System.out.println(s1.length());System.out.println(s2.length()); 输出的结果是什么呢？12看到这个结果是不是崩溃了，到底怎么回事？ 1.首先要明白.length指的是什么，String内部是以char数组的形式存储的，.length是指char数组的长度，char是以UTF-16编码的，李是常用字，UTF-16编码后占两个字节，一个char就能够存储，所以是长度是1，而UTF-16编码后占四个字节，两个char来存储，所以长度是2]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式19之 迭代器(Iterator)模式(行为模式)]]></title>
    <url>%2F2014%2F06%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F19%E4%B9%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器模式简介 迭代器模式又叫游标(Cursor)模式，是对象的行为模式。迭代器模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation）。 迭代器模式是设计模式中最常见的几个模式之一。在Java的集合(Collection)框架中，广泛的使用迭代器(Iterator和Enumeration)来遍历集合的元素。 迭代器模式涉及到以下几个角色：抽象迭代器(Iterator)，具体迭代器(ConcreteIterator)，聚集(Aggregate)，具体聚集(ConcreteAggregate)，客户端(Client)。 角色 说明 抽象迭代器 此抽象角色定义出遍历元素所需的接口。 具体迭代器 此角色实现了抽象迭代器的接口，并保持迭代过程中的游标位置。 聚集 此抽象角色给出创建迭代器(Iterator)对象的接口。 具体聚集 实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。 客户端 持有对聚集及其迭代器对象的引用，调用迭代器对象的迭代接口，也有可能通过迭代器操作聚集元素的增加和删除。 迭代器模式有两种：外禀迭代器和内禀迭代器。外禀迭代器 – “具体迭代器”是在”具体聚集”之外实现的。内禀迭代器 – “具体迭代器”是在”具体聚集”里面实现的，”具体迭代器”是”具体聚集”的私有内部类。 在外禀迭代器中，”具体聚集”向外提供了访问聚集中各个元素的接口；而在内禀迭代器中，”具体聚集”包含了内部类”具体迭代器”，这就意味着”具体迭代器”可以直接访问”具体聚集”的成员对象，而不需要通过函数接口去访问。 外禀迭代器 如果迭代器是在聚集结构之外实现的，这样的迭代器被称为外禀迭代器(Extrinsic Iterator)。 下面看看”外禀迭代器”中各个角色的代码。 抽象迭代器类public interface Iterator { // 迭代方法：移动到第一个元素 public void first(); // 迭代方法：移动到下一个元素 public void next(); // 迭代方法：是否为最后一个元素 public boolean isDone(); // 迭代方法：返还当前元素 public Object currentItem(); } 具体迭代器类public class ConcreteIterator implements Iterator { private ConcreteAggregate agg; // 索引位置 private int index = 0; // 集合大小 private int size = 0; public ConcreteIterator(ConcreteAggregate agg){ this.agg = agg; this.size = agg.size(); index = 0; } // 迭代方法：移动到第一个元素 @Override public void first() { index = 0; } // 迭代方法：是否为最后一个元素 @Override public boolean isDone() { return (index &gt;= size); } // 迭代方法：移动到下一个元素 @Override public void next() { if(index &lt; size) { index ++; } } // 迭代方法：返还当前元素 @Override public Object currentItem() { return agg.getElement(index); } } 聚集类abstract public class Aggregate { // 工厂方法：返回迭代器对象 public abstract Iterator createIterator(); } 具体聚集类public class ConcreteAggregate extends Aggregate { private Object[] objs = {&quot;Monk Tang&quot;, &quot;Monkey&quot;, &quot;Pigsy&quot;, &quot;Sandy&quot;, &quot;Horse&quot;}; @Override public Iterator createIterator() { return new ConcreteIterator(this); } // 取值方法：向外界提供聚集元素 public Object getElement(int index){ if(index &lt; objs.length){ return objs[index]; }else{ return null; } } // 取值方法：向外界提供聚集的大小 public int size(){ return objs.length; } } 客户端类public class Client { private Iterator it; private Aggregate agg = new ConcreteAggregate(); public void operation() { it = agg.createIterator(); while(!it.isDone()) { System.out.println(it.currentItem()); it.next(); } }3.4 public static void main(String[] args) { Client client = new Client(); client.operation(); } } 运行结果： Monk Tang Monkey Pigsy Sandy Horse 内禀迭代器 如果将”外禀迭代器”中的”具体迭代器”改写成”具体聚集类”的一个私有类，即迭代器是在聚集结构之内实现；这样的迭代器，就被称为内禀迭代器(Intrinsic Iterator)。 下面看看”内禀迭代器”中各个角色的代码。 抽象迭代器类public interface Iterator { // 迭代方法：移动到第一个元素 public void first(); // 迭代方法：移动到下一个元素 public void next(); // 迭代方法：是否为最后一个元素 public boolean isDone(); // 迭代方法：返还当前元素 public Object currentItem(); } 聚集类abstract public class Aggregate { // 工厂方法：返回迭代器对象 public abstract Iterator createIterator(); } 具体聚集类public class ConcreteAggregate extends Aggregate { private Object[] objs = {&quot;Monk Tang&quot;, &quot;Monkey&quot;, &quot;Pigsy&quot;, &quot;Sandy&quot;, &quot;Horse&quot;}; @Override public Iterator createIterator() { return new ConcreteIterator(); } private class ConcreteIterator implements Iterator { // 索引位置 private int index = 0; // 迭代方法：移动到第一个元素 @Override public void first() { index = 0; } // 迭代方法：是否为最后一个元素 @Override public boolean isDone() { return (index == objs.length); } // 迭代方法：移动到下一个元素 @Override public void next() { if(index &lt; objs.length) { index ++; } } // 迭代方法：返还当前元素 @Override public Object currentItem() { return objs[index]; } } } 客户端类public class Client { private Iterator it; private Aggregate agg = new ConcreteAggregate(); public void operation() { it = agg.createIterator(); while(!it.isDone()) { System.out.println(it.currentItem()); it.next(); } } public static void main(String[] args) { Client client = new Client(); client.operation(); } } 运行结果： Monk Tang Monkey Pigsy Sandy Horse]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式18之 观察者(Observer)模式(行为模式)]]></title>
    <url>%2F2014%2F06%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F18%E4%B9%8B-%E8%A7%82%E5%AF%9F%E8%80%85-Observer-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式简介 观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 例如，马路上的交通指示灯为红灯亮的话，汽车会停止，行人可以通行。在这个场景中，交通指示等就是被观察者，而行人和汽车则是观察者，他们会根据观察到的交通指示灯的状况作出相应的行为。 观察者的UML类图如下： 观察者模式所涉及的角色有：抽象主题(Subject)，具体主题(ConcreteSubject)，抽象观察者(Observer)，具体观察者(ConcreteObserver)。 角色 说明 抽象主题 抽象主题角色把所有对观察者对象的引用保存在一个集合(比如Vector对象)里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色，一般用一个抽象类或者一个接口实现。 具体主题 将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。具体主题通常用一个具体子类实现。 抽象观察者 为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。 具体观察者 存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。它通常用一个具体子类实现。 示意代码抽象主题类 import java.util.Vector; import java.util.Enumeration; abstract public class Subject { private Vector observersVector = new Vector(); // 注册观察者对象 public void attach(Observer observer) { observersVector.addElement(observer); } // 注销观察者对象 public void detach(Observer observer) { observersVector.removeElement(observer); } // 通知所有注册的观察者对象 public void notifyObservers() { Enumeration enu = observers(); while (enu.hasMoreElements()) { ((Observer)enu.nextElement()).update(); } } public Enumeration observers(){ return ((Vector)observersVector.clone()).elements(); } } 具体主题类 public class ConcreteSubject extends Subject{ private String state; // 改变主题的方法。 public void change(String newState){ state = newState; this.notifyObservers(); } } 抽象观察者类 public interface Observer { // 通知接口 public void update(); } 具体观察者类 public class ConcreteObserver implements Observer { @Override public void update() { System.out.println(&quot;I am notified.&quot;); } } 客户端类 public class Client { private static ConcreteSubject subject; private static Observer observer; public static void main(String[] args) { // 创建主题 subject = new ConcreteSubject(); // 创建观察者 observer = new ConcreteObserver(); // 将观察者注册到&quot;主题&quot;上 subject.attach(observer); // 改变主题对象的状态 subject.change(&quot;new state&quot;); } } 运行结果： I am notified. Java中的观察者模式 Java语言本身支持”观察者模式”，它提供了相应的”抽象主题类(Observable)”和”抽象观察者类(Observer)”。 Observable是个实例类。它提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 Observer是一个接口。它只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 下面演示Java中Observer和Observable的用法。 以公鸡打鸣来建模：太阳是被观察者，公鸡是观察者；当公鸡观察到太阳升起的时候，就打鸣。 太阳太阳是被观察者，它继承了Observable。 import java.util.Observable; public class Sun extends Observable { public void rise() { System.out.println(&quot;Sun rise.&quot;); // 设置&quot;被观察者&quot;的状态标记，表示它发生了变化。 this.setChanged(); // 通知&quot;观察者&quot;该变化。 this.notifyObservers(); } } 公鸡公鸡是观察者，它实现了Observer对象。 import java.util.Observer; import java.util.Observable; public class Cock implements Observer { private Sun sun; public Cock(Sun sun) { this.sun = sun; // 将观察者Cock注册到&quot;被观察者sun&quot;上。 sun.addObserver(this); } // &quot;被观察者&quot;发生变化时，&quot;观察者&quot;对应的响应方法。 @Override public void update(Observable o, Object arg) { System.out.println(&quot;Cock gogoda,gogoda,gogoda...&quot;); } } 客户端测试程序public class Client { private static Cock cock; private static Sun sun; public static void main(String[] args) { // 新建&quot;太阳&quot;(被观察者) sun = new Sun(); // 新建&quot;公鸡&quot;(观察者) cock = new Cock(sun); // 太阳升起。公鸡观察到太阳升级后，会打鸣！ sun.rise(); } } 运行结果： Sun rise. Cock gogoda,gogoda,gogoda...]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式17之 模板方法(Template Method)模式(行为模式)]]></title>
    <url>%2F2014%2F06%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F17%E4%B9%8B-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95-Template-Method-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板模式简介 模板方法(Template Method)模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 模板方法模式是所有模式中最为常见的几个模式之一，而且很可能我们自己使用过模板方法模式而没有意识到自己已经使用了这个模式。模板方法模式是基于继承的代码复用的基本技术。 Java的集合就是一个典型的，利用了模板方法模式的例子。Java集合中的Collection集合包括List和Set两大组成部分。List是队列，而Set是没有重复元素的集合。它们共同的接口都在Collection接口声明；例如，都包含了size()，isEmpty()方法。而AbstractCollection这个抽象类则实现了它们共同的方法，其余未实现的方法定义为抽象方法。List和Set的实例类，就是通过继承AbstractCollection(或它的子类)，省去了许多重复性编码的工作！ 模板方法模式的UML类图： 这里涉及到两个角色：抽象模板(Abstract Template)，具体模板(Concrete Template)。 抽象模板有如下责任：• 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。• 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板有如下责任：• 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。• 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 示意代码 abstract public class AbstractClass { // 模板方法 public void templateMethod(){ hookMethod(); //调用基本方法(由子类实现) abstractMethod(); //调用基本方法(由子类实现) concreteMethod(); //调用基本方法(已经实现) } // 基本方法的声明（由子类实现，但抽象模板给出了默认实现） public void hookMethod() {} // 基本方法的声明（由子类实现） public abstract void abstractMethod(); // 基本方法（已经实现） public final void concreteMethod(){ // do something } } public class ConcreteClass extends AbstractClass { // 基本方法的实现 @Override public void hookMethod() { // do something } // 基本方法的实现 @Override public void abstractMethod() { // do something } } 抽象模板角色AbstractTemplate提供了两个具体方法templateMethod()和concreteMethod()；声明了2个抽象方法hookMethod()和abstractMethod()。 具体模板角色ConcreteTemplate实现了父类声明的基本方法hookMethod()和abstractMethod()。 模板方法模式中的方法 模板方法中的方法可以分为两大类：模板方法 和 基本方法。 模板方法 一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 基本方法 基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。• 抽象方法: 一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。• 具体方法: 一个具体方法由抽象类声明并实现，而子类并不实现或置换。• 钩子方法: 一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 在前面的UML示例中，AbstractClass是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。 提示：钩子方法的名字应当以do开始。 模板方法模式示例 考虑一个计算存款利息的例子。假设系统需要支持两种存款账号，即货币市场(Money Market)账号和定期存款(Certificate of Deposite)账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同的账号类型。 这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤：一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。 显然，系统需要一个抽象角色给出顶级行为的实现，而将两个作为细节步骤的基本方法留给具体子类实现。由于需要考虑的账号有两种：一是货币市场账号，二是定期存款账号。系统的UML类图如下图所示。 抽象模板类abstract public class Account { protected String accountNumber; public Account() { accountNumber = null; } public Account(String accountNumber) { this.accountNumber = accountNumber; } // 模板方法，计算利息数额 public final double calculateInterest(){ double interestRate = doCalculateInterestRate(); String accountType = doCalculateAccountType(); double amount = calculateAmount(accountType, accountNumber); return amount * interestRate; } // 基本方法留给子类实现 protected abstract String doCalculateAccountType(); // 基本方法留给子类实现 protected abstract double doCalculateInterestRate(); // 基本方法，已经实现 private double calculateAmount(String accountType, String accountNumber){ // retrive amount from database return 7243.00D; } } 具体模板类MoneyMarketAccount public class MoneyMarketAccount extends Account { @Override protected String doCalculateAccountType() { return &quot;Money Market&quot;; } @Override protected double doCalculateInterestRate() { return 0.045D; } } CDAccount public class CDAccount extends Account { @Override protected String doCalculateAccountType() { return &quot;Certificate of Deposite&quot;; } @Override protected double doCalculateInterestRate() { return 0.065D; } } 客户端测试程序public class Client { private static Account acct = null; public static void main(String[] args) { acct = new MoneyMarketAccount(); System.out.println(&quot;Interest from Money Market account: &quot; + acct.calculateInterest()); acct = new CDAccount(); System.out.println(&quot;Interest from CD account: &quot; + acct.calculateInterest()); } } 运行结果： Interest from Money Market account: 325.935 Interest from CD account: 470.795 结果说明：Account是抽象模板类，calculateInterest()是模板方法。不管是”货币市场帐号”或者”定期存款”，它们的利息计算方式都是通过抽象模板类的calculateInterest()来计算的；只不过涉及到的本金和利率不同而已。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式16之 策略(Strategy)模式(行为模式)]]></title>
    <url>%2F2014%2F05%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F16%E4%B9%8B-%E7%AD%96%E7%95%A5-Strategy-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式简介策略(Strategy)模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 UML类图 这个模式涉及到三个角色：环境(Context)，抽象策略(Strategy)，具体策略(ConcreteStrategy)。 角色 说明 环境 持有一个Strategy的引用。 抽象策略 这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略 包装了相关的算法或行为。 示意代码 public class Context { // 策略对象 private Strategy strategy; // 构造函数 public Context(Strategy strategy){ this.strategy = strategy; } // 策略方法 public void contextInterface(){ strategy.strategyInterface(); } } abstract public class Strategy { // 策略方法 public abstract void strategyInterface(); } public class ConcreteStrategy extends Strategy { @Override public void strategyInterface() { // write your algorithm code here } } 策略模式示例假设现在要设计一个贩卖各类书籍的电子商务的购物车系统。下面是图书的三种折扣算法。 算法一：对图书没有折扣。算法二：对图书提供一个固定值为5元的折扣。算法三：对图书提供一个八折的折扣。 使用策略模式描述的话，这些不同的算法都是不同的具体策略角色：用一个NoDiscountStrategy对象描述”算法一”；用一个FlatRateStrategy对象描述”算法二”；用一个PercentageStrage对象描述”算法三”。 抽象策略abstract public class DiscountStrategy { // 价格 protected int price = 0; // 策略 protected int copies = 0; public abstract int calculateDiscount(); public DiscountStrategy(int price, int copies) { this.price = price; this.copies = copies; } } 具体策略算法一(无折扣) public class NoDiscountStrategy extends DiscountStrategy { public NoDiscountStrategy(int price, int copies) { super(price, copies); } public int calculateDiscount() { return copies*price; } } 算法二(优惠5元) public class FlatRateStrategy extends DiscountStrategy { private int discard = 5; public FlatRateStrategy(int price, int copies) { super(price, copies); } public void setDiscard() { this.discard = discard; } public int getDiscard() { return discard; } public int calculateDiscount() { return copies*(price - discard); } } 算法三(打8折) public class PercentageStrategy extends DiscountStrategy { // 折扣比例 private float percent = 0.8f; public PercentageStrategy(int price, int copies) { super(price, copies); } public void setPercent() { this.percent = percent; } public float getPercent() { return percent; } public int calculateDiscount() { return (int)(copies*price*percent); } } 客户端public class Client { public static void main(String[] args) { // 第一种策略 DiscountStrategy strategy = new NoDiscountStrategy(60, 5); System.out.println(&quot;total(60,5)=&quot;+strategy.calculateDiscount()); strategy = new FlatRateStrategy(80, 5); System.out.println(&quot;total(80,5)=&quot;+strategy.calculateDiscount()); strategy = new PercentageStrategy(100, 3); System.out.println(&quot;total(100,4)=&quot;+strategy.calculateDiscount()); } } 运行结果： total(60,5)=300 total(80,5)=375 total(100,4)=240]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式15之 不变(Immutable)模式(行为模式)]]></title>
    <url>%2F2014%2F05%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F15%E4%B9%8B-%E4%B8%8D%E5%8F%98-Immutable-%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不变模式简介一个对象的状态在对象被创建之后就不再变化，这就是所谓的不变(Immutable)模式。 不变模式的结构 不变模式可增强对象的强壮型(robustness)。不变模式允许多个对象共享某一个对象，降低了对该对象进行并发访问时的同步化开销。如果需要修改一个不变对象的状态，那么就需要建立一个新的同类型对象，并在创建时将这个新的状态存储在新对象里。 不变模式只涉及到一个类。一个类的内部状态创建后，在整个生命周期都不会发生变化时，这样的类称作不变类。这种使用不变类的做法叫做不变模式。不变模式有两种形式：一种是弱不变模式，另一种是强不变模式。 弱不变模式 一个类的实例的状态是不可改变的；但是这个类的子类的实例具有可能会变化的状态。这样的类符合弱不变模式的定义。要实现弱不变模式，一个类必须满足下面条件： (01) 所考虑的对象没有任何方法会修改对象的状态；这样一来，当对象的构造函数将对象的状态初始化之后，对象的状态便不再改变。(02) 所有属性都应当是私有的。不要声明任何的公开的属性，以防客户端对象直接修改任何的内部状态。(03) 这个对象所引用到的其他对象如何是可变对象的话，必须设法限制外界对这些可变对象的访问，以防止外界修改这些对象。如何可能，应当尽量在不变对象内部初始化这些被引用的对象，而不要在客户端初始化，然后再传入到不变对象内部来。如果某个可变对象必须在客户端初始化，然后再传入到不变对象里的话，就应当考虑在不变对象初始化的时候，将这个可变对象复制一份，而不要使用原来的拷贝。 弱不变模式的缺点是：第一, 一个弱不变对象的子对象可以是可变对象；换言之，一个弱不变对象的子对象可能是可变的。第二, 这个可变的子对象可能可以修改父对象的状态，从而可能会允许外界修改父对象的状态。 强不变模式 一个类的实例不会改变，同时它的子类的实例也具有不可变化的状态。这样的类符合强不变模式。要实现强不变模式，一个类必须首先满足弱不变模式所要求的所有条件，并且还有满足下面条件之一：(01) 所考虑的类所有的方法都应当是final，这样这个类的子类不能够置换掉此类的方法。(02) 这个类本身就是final的，那么这个类就不可能会有子类，从而也就不可能有被子类修改的问题。 不变模式示例通过以下几个示例来看看”弱不变模式”和”强不变模式”。 可变模式class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public String toString() { return &quot;name:&quot;+name+&quot;, age:&quot;+age; } } // Complex不是&quot;弱不变类&quot;。 // 因为它包含了可变类对象person，并且person是在外部初始化的。 class Complex { private Person person; private int id; public Complex (Person person, int id) { this.person = person; this.id = id; } public int getId() { return id; } public Person getPerson() { return person; } public String toString() { return &quot;id:&quot;+id+&quot;, person(&quot;+person+&quot;)&quot;; } } public class MutableDemo { public static void main(String[] args) { // 新建Complex对象，在&quot;外部(即，非Complex内部)&quot;初始化person。 Person person = new Person(&quot;张三&quot;, 18); Complex com = new Complex(person, 1); System.out.println(com); // 修改person的名字为&quot;李四&quot;，年龄为20 person.setName(&quot;李四&quot;); person.setAge(20); System.out.println(com); } } 运行结果： id:1, person(name:张三, age:18) id:1, person(name:李四, age:20) 结果说明：MutableDemo中的Complex类满足”弱不变模式”的前2个条件：(01) Complex中没有方法可以修改对象的状态。Complex包含了person和id两个属性值，但是没有方法修改这两个树形。(02) Complex中的person和id属性都是私有的。 但是，Complex不满足”若不变模式”的第3个条件。Complex引用了”可变类对象person”，person是Person类的对象，而Person是一个可变类！ 所以，在MutableDemo中，我们初始化了Complex的person值为(“张三”,18)之后；在后面修改了person的名字为”李四”,年龄为18。Complex中的person的值也会相应的改变！所以，Complex是”可变类”。 若想将Complex修改为”不变类”，需要将Complex修改的满足”若不变模式”的第3个条件。方法是，在Complex中初始化person的时候，创建一个person的拷贝即可。详细代码请看”2. 弱不变模式”。 弱不变模式class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public String toString() { return &quot;name:&quot;+name+&quot;, age:&quot;+age; } } // Complex是&quot;弱不变类&quot;。 // 它虽然包含了可变的外部对象person，但是Complex内部的person是不会改变的。因为它保存的是person的拷贝。 class Complex { private Person person; private int id; public Complex (Person person, int id) { // 新建一个person的拷贝。 this.person = new Person(person.getName(), person.getAge()); this.id = id; } public int getId() { return id; } public Person getPerson() { return person; } public String toString() { return &quot;id:&quot;+id+&quot;, person(&quot;+person+&quot;)&quot;; } } public class WeakImmutable { public static void main(String[] args) { // 新建Complex对象。 // id是1, person的名字是&quot;张三&quot;，年龄是18 Person person = new Person(&quot;张三&quot;, 18); Complex com = new Complex(person, 1); System.out.println(com); // 修改person的名字为&quot;李四&quot;，年龄为20 person.setName(&quot;李四&quot;); person.setAge(20); System.out.println(com); } } 运行结果： id:1, person(name:张三, age:18) id:1, person(name:张三, age:18) 结果说明：WeakImmutable相比MutableDemo，只对Complex的构造函数进行了修改。Complex同时满足”弱不变模式”的3个条件，因此，它就是个不变模式。 强不变模式class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public String toString() { return &quot;name:&quot;+name+&quot;, age:&quot;+age; } } // Complex是&quot;强不变类&quot;。 final class Complex { private final Person person; private final int id; public Complex (Person person, int id) { // 新建一个person的拷贝。 this.person = new Person(person.getName(), person.getAge()); this.id = id; } public final int getId() { return id; } public final Person getPerson() { return person; } public String toString() { return &quot;id:&quot;+id+&quot;, person(&quot;+person+&quot;)&quot;; } } public class StrongImmutable { public static void main(String[] args) { // 新建Complex对象。 // id是1, person的名字是&quot;张三&quot;，年龄是18 Person person = new Person(&quot;张三&quot;, 18); Complex com = new Complex(person, 1); System.out.println(com); // 修改person的名字为&quot;李四&quot;，年龄为20 person.setName(&quot;李四&quot;); person.setAge(20); System.out.println(com); } } 运行结果： id:1, person(name:张三, age:18) id:1, person(name:张三, age:18) 结果说明：StrongImmutable中的Complex满足”强不变模式”的要求。StrongImmutable相比WeakImmutable，进行了两个修改：第一，将Complex中的属性和方法都修改为final类型。第二，将Complex类本身修改为final类型。 不变模式的优缺点不变模式有很明显的优点：(1) 因为不能修改一个不变对象的状态，所以可以避免由此引起的不必要的程序错误；换言之，一个不变的对象要比可变的对象更加容易维护。(2) 因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以自由地被不同的客户端共享。 不变模式的缺点：不变模式唯一的缺点是：一旦需要修改一个不变对象的状态，就只好创建一个新的同类对象。在需要频繁修改不变对象的环境里，会有大量的不变对象作为中间结果被创建出来，再被JAVA垃圾收集器收集走。这是一种资源上的浪费。 在设计任何一个类的时候，应当慎重考虑其状态是否有需要变化的可能性。除非其状态有变化的必要，不然应当将它设计成不变类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>不变模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式14之 桥梁(Bridge)模式(结构模式)]]></title>
    <url>%2F2014%2F05%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F14%E4%B9%8B-%E6%A1%A5%E6%A2%81-Bridge-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[桥梁模式简介 桥梁模式(Bridge)，又称为柄体(Handle and Body)模式或接口(Interface)模式。它属于对象的结构模式，其用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。 这句话有三个关键词：“抽象化”、”实现化”和”脱耦”。 • 抽象化 存在于多个实体中的共同的概念联系，就是抽象话。例如，苹果、葡萄、草莓，它们的共同特征就是水果，因此，水果是它们的抽象化存在；圆形、正方形、三角形，它们的共同特征就是形状，因此，形状就是它们的抽象话。 通常情况下，一组对象如果具有相同的特征，那么它们就可以通过一个共同的类来描述。如果一些类具有相同的特征，往往可以通过一个共同的抽象类来描述。 • 实现化 抽象化给出的具体实现，就是实现化。 一个类的实例就是这个类的实例化，一个具体子类是它的抽象超类的实例化。 • 脱耦 所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。 所谓强关联，就是在编译时期已经确定的，无法在运行时期动态改变的关联；所谓弱关联，就是可以动态地确定并且可以在运行时期动态地改变的关联。显然，在Java语言中，继承关系是强关联，而聚合关系是弱关联。 将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联。因此，桥梁模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用聚合关系而不是继承关系，从而使两者可以相对独立地变化。这就是桥梁模式的用意。 桥梁模式的UML类图 从中可以看出，桥接模式含有两个等级结构：(01) 由抽象化角色和修正抽象化角色组成的抽象化等级结构。(02) 由实现化角色和两个具体实现化角色所组成的实现化等级结构。 桥梁模式包含四种角色： 抽象化(Abstraction)，修正抽象化(RefinedAbstraction)，实现化(Implementor)，具体实现化(ConcreteImplementor)。• 抽象化: 抽象化给出的定义，并保存一个对实现化对象的引用。• 修正抽象化: 扩展抽象化角色，改变和修正父类对抽象化的定义。• 实现化: 这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。• 具体实现化: 这个角色给出实现化角色接口的具体实现。 对象是对行为的封装，而行为是由方法实现的。在这个示意性系统里，抽象化等级结构中的类封装了operation()方法；而实现化等级结构中的类封装的是operationImpl()方法。当然，在实际的系统中往往会有多于一个的方法。 抽象化等级结构中的方法通过向对应的实现化对象的委派实现自己的功能，这意味着抽象化角色可以通过向不同的实现化对象委派，来达到动态地转换自己的功能的目的。 示意代码抽象化 public abstract class Abstraction { protected Implementor impl; public Abstraction(Implementor impl){ this.impl = impl; } // 商业方法 public void operation(){ impl.operationImpl(); } } 修正抽象化角色 public class RefinedAbstraction extends Abstraction { public RefinedAbstraction(Implementor impl) { super(impl); } } 实现化角色 public abstract class Implementor { // 方法的实现化声明 public abstract void operationImpl(); } 具体实现化角色 public class ConcreteImplementorA extends Implementor { // 方法的实现化实现 @Override public void operationImpl() { // something you want to do } } public class ConcreteImplementorB extends Implementor { // 方法的实现化实现 @Override public void operationImpl() { // something you want to do } } 桥梁模式示例 问题 空中巴士(Airbus)、波音(Boeing)和麦道(MD)都是飞机制造商，它们都生成载客飞机(PassengerPlane)和载货飞机(CargoPlane)。现在需要设计一个系统，描述这些飞机制造商以及它们所制造的飞机种类。 设计方案一(不使用桥梁模式) 系统是关于飞机的，因此可以设计一个总的飞机接口，叫做Airplane。其它所有的飞机都是这个总接口的字接口或者具体实现。 下面是这个方案的设计图，可以看出，这是一个不太高明的设计，导致了理不清的关系。 在这个设计方案里面，出现了两个子接口，分别代表客户和货机。所有的具体飞机又要继承自Airbus，Boeing和MD等超类。这样一类，每个具体飞机都带有两个超类：飞机制造商类型，客、货机类型。 设计方案二(使用桥梁模式) 使用桥梁模式的关键在于准确的找出这个系统的抽象化角色和具体化角色。从系统所面对的问题不难看出，代表飞机的抽象化是它的类型，也就是”客户”或者”货机”；而代表飞机的实现化的则是飞机的制造商。 使用桥梁模式，对应的UML类图如下： 抽象化类abstract public class Airplane { // 飞机制造商 protected AirplaneMaker maker; // 指定飞机制造商 public Airplane(AirplaneMaker maker) { this.maker = maker; } public void fly() { // 调用AirplaneMaker的produce()方法 maker.produce(); } } 修正抽象化PassengerPlane代码 public class PassengerPlane extends Airplane { public PassengerPlane(AirplaneMaker maker) { super(maker); } public void fly() { super.fly(); System.out.println(&quot;PassengerPlane fly.&quot;); } } CargoPlane代码 public class CargoPlane extends Airplane { public CargoPlane(AirplaneMaker maker) { super(maker); } public void fly() { super.fly(); System.out.println(&quot;CargoPlane fly.&quot;); } } 实现化AirplaneMaker代码 abstract public class AirplaneMaker { // 生产飞机 public abstract void produce() ; } 具体实现化Airbus代码 public class Airbus extends AirplaneMaker { public void produce() { System.out.println(&quot;Airbus produced.&quot;); } } Boeing代码 public class Boeing extends AirplaneMaker { public void produce() { System.out.println(&quot;Boeing produced.&quot;); } } MD代码 public class MD extends AirplaneMaker { public void produce() { System.out.println(&quot;MD produced.&quot;); } } 客户端测试程序public class Client { public static void main(String[] args) { // &quot;飞机制造商&quot;为Airbus AirplaneMaker maker = new Airbus(); // &quot;飞机类型&quot;为PassengerPlane Airplane plane = new PassengerPlane(maker); // 飞机飞行 plane.fly(); // &quot;飞机制造商&quot;为MD maker = new MD(); // &quot;飞机类型&quot;为CargoPlane plane = new CargoPlane(maker); // 飞机飞行 plane.fly(); } } 运行结果： Airbus produced. PassengerPlane fly. MD produced. CargoPlane fly.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>桥梁模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式13之 门面(Facade)模式(结构模式)]]></title>
    <url>%2F2014%2F05%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13%E4%B9%8B-%E9%97%A8%E9%9D%A2-Facade-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[门面模式简介门面模式是对象的结构模式，外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 举个例子，病人去医院看病，如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情：首先病人必须先挂号，然后门诊；如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验；化验后再回到门诊室。如下图所示： 而如果引”进门面模式”，在医院中增加一个接待员。由接待员负责代为挂号、划价、缴费、取药等，病人只接触接待员，由接待员与各个部门打交道。这样，对病人来说，就会简单很多。如下图所示： 下面看看门面模式的UML类图： 门面模式包括2个角色：门面(Facade)，子系统(SubSystem)。 角色 说明 门 面 客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。 子系统 可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 门面模式示例一个保安系统由两个录像机、三个电灯、一个遥控器和一个警报器组成。保安系统的操作人员在早上上班的时候，将这些仪器打开；晚上下班之后，会将这些仪器关闭。 我们先演示在不使用”门面模式”的情况下，实现该系统。然后，通过”门面模式”实现该系统。 未使用”门面模式”UML类图如下： 从图中可以看出，客户端Client对象需要引用到录像机(Camera)、电灯(Light)、感应器(Sensor)和报警器(Alarm)所有的对象。 客户端(Client)源码 public class Client { private static Camera camera1, camera2; private static Light light1, light2, light3; private static Sensor sensor; private static Alarm alarm; public static void main(String[] args) { camera1 = new Camera(); camera2 = new Camera(); light1 = new Light(); light2 = new Light(); light3 = new Light(); sensor = new Sensor(); alarm = new Alarm(); camera1.turnOn(); camera2.turnOn(); light1.turnOn(); light2.turnOn(); light3.turnOn(); sensor.activate(); alarm.activate(); } } 录像机(Camera)源码 public class Camera { // 打开录像机 public void turnOn() { System.out.println(&quot;Turning on the camera.&quot;); } // 关闭录像机 public void turnOff() { System.out.println(&quot;Turning off the camera.&quot;); } // 转动录像机 public void rotate(int degrees) { System.out.println(&quot;Rotating the camera by &quot;+degrees+&quot; degrees.&quot;); } } 电灯(Light)源码 public class Light { // 打开灯 public void turnOn() { System.out.println(&quot;Turning on the light.&quot;); } // 关闭灯 public void turnOff() { System.out.println(&quot;Turning off the light.&quot;); } // 换灯泡 public void changeBulb() { System.out.println(&quot;Cotating the light-bulb.&quot;); } } 感应器(Sensor)源码 public class Sensor { // 启动感应器 public void activate() { System.out.println(&quot;Activating on the sensor.&quot;); } // 关闭感应器 public void deactivate() { System.out.println(&quot;Deactivating the sensor.&quot;); } // 触发感应器 public void trigger() { System.out.println(&quot;The sensor has been triggered.&quot;); } } 报警器(Alarm)源码 public class Alarm { // 启动警报器 public void activate() { System.out.println(&quot;Activating on the alarm.&quot;); } // 关闭警报器 public void deactivate() { System.out.println(&quot;Deactivating the alarm.&quot;); } // 拉响警报器 public void ring() { System.out.println(&quot;Ringing the alarm&quot;); } // 停掉警报器 public void stopRing() { System.out.println(&quot;Stop the alarm&quot;); } } 运行结果： Turning on the camera. Turning on the camera. Turning on the light. Turning on the light. Turning on the light. Activating on the sensor. Activating on the alarm. 使用”门面模式”UML类图如下： 可以看出：门面SecurityFade承担了与保安系统内部各个对象打交道的任务，而客户对象只需要与门面对象打交道即可。SecurityFade是客户端与保安系统之间的一个门户，它使得客户端与子系统之间的关系变得简单和易于管理。 客户端(Client)源码 public class Client { private static SecurityFacade security; public static void main(String[] args) { security = new SecurityFacade(); security.activate(); } } 门面(SecurityFade)源码 public class SecurityFacade { private Camera camera1, camera2; private Light light1, light2, light3; private Sensor sensor; private Alarm alarm; public SecurityFacade() { camera1 = new Camera(); camera2 = new Camera(); light1 = new Light(); light2 = new Light(); light3 = new Light(); sensor = new Sensor(); alarm = new Alarm(); } public void activate() { camera1.turnOn(); camera2.turnOn(); light1.turnOn(); light2.turnOn(); light3.turnOn(); sensor.activate(); alarm.activate(); } public void deactivate() { camera1.turnOff(); camera2.turnOff(); light1.turnOff(); light2.turnOff(); light3.turnOff(); sensor.deactivate(); alarm.deactivate(); } } 录像机(Camera)源码 public class Camera { // 打开录像机 public void turnOn() { System.out.println(&quot;Turning on the camera.&quot;); } // 关闭录像机 public void turnOff() { System.out.println(&quot;Turning off the camera.&quot;); } // 转动录像机 public void rotate(int degrees) { System.out.println(&quot;Rotating the camera by &quot;+degrees+&quot; degrees.&quot;); } } 电灯(Light)源码 public class Light { // 打开灯 public void turnOn() { System.out.println(&quot;Turning on the light.&quot;); } // 关闭灯 public void turnOff() { System.out.println(&quot;Turning off the light.&quot;); } // 换灯泡 public void changeBulb() { System.out.println(&quot;Cotating the light-bulb.&quot;); } } 感应器(Sensor)源码 public class Sensor { // 启动感应器 public void activate() { System.out.println(&quot;Activating on the sensor.&quot;); } // 关闭感应器 public void deactivate() { System.out.println(&quot;Deactivating the sensor.&quot;); } // 触发感应器 public void trigger() { System.out.println(&quot;The sensor has been triggered.&quot;); } } 报警器(Alarm)源码 public class Alarm { // 启动警报器 public void activate() { System.out.println(&quot;Activating on the alarm.&quot;); } // 关闭警报器 public void deactivate() { System.out.println(&quot;Deactivating the alarm.&quot;); } // 拉响警报器 public void ring() { System.out.println(&quot;Ringing the alarm&quot;); } // 停掉警报器 public void stopRing() { System.out.println(&quot;Stop the alarm&quot;); } } 运行结果： Turning on the camera. Turning on the camera. Turning on the light. Turning on the light. Turning on the light. Activating on the sensor. Activating on the alarm.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>门面模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式12之 享元(Flyweight)模式(结构模式)]]></title>
    <url>%2F2014%2F05%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F12%E4%B9%8B-%E4%BA%AB%E5%85%83-Flyweight-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[享元模式简介享元模式(Flyweight)是对象的结构模式，它以共享的方式高效地支持大量的细粒度对象。 它的好处是，通过共享来避免大量拥有相同内容对象的开销。 享元模式中的对象称为享元对象，享元对象分为内蕴状态和外蕴状态。内蕴对象和外蕴对象是相互独立的：内蕴状态是存储在享元对象内部，并且不会随环境改变而有所不同的；内蕴状态是可以共享。外蕴状态是随环境改变而改变，不可以共享的状态；享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。 一个比较典型的享元模式示例就是：”Java中的String对象”。 例如，定义一个String常量a和b，它们的值为”hello”，定义如下： String a=&quot;hello&quot;; String b=&quot;hello&quot;; 实际上，a和b都是存在常量池中。由于a和b的值都是”hello”，它们实际上是常量池的同一个对象！ 常量池(constant pool)指的是在编译期就被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。 String示例1public class String1 { public static void main(String[] args) { String a = &quot;hello&quot;; String b = &quot;hello&quot;; String c = &quot;he&quot;+&quot;llo&quot;; System.out.println(a==b); System.out.println(a==c); } } 运行结果： true true 结果说明：(01) a和b中的”hello”都是字符串常量，它们存储在常量池中，在编译期就被确定了，所以a==b为true。(02) “he”和”llo”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以c也同样在编译期就被解析为一个字符串常量，所以c也是常量池中”hello”的一个引用。 String示例2public class String2 { public static void main(String[] args) { String a = &quot;hello&quot;; String b = new String(&quot;hello&quot;); String c = &quot;he&quot;+new String(&quot;llo&quot;); System.out.println(a==b); System.out.println(a==c); System.out.println(b==c); } } 运行结果： false false false 结果说明：a还是常量池中”hello”字符串常量；而b则无法在编译期确定，它是运行时创建”hello”对象的引用；而c因为有后半部分new String(“llo”)，所以c也无法在编译期确定，因此，c也是一个新创建的”hello”对象的应用。 继续回到享元模式。它分为”单纯享元模式“ 和 “复合享元模式“。 单纯享元模式在单纯的享元模式中，所有的享元对象都是可以共享的。它的UML类图如下： 单纯享元模式涉及到的角色：抽象享元(Flyweight)，具体享元(ConcreteFlyweight)，享元工厂(FlyweightFactory)。 角色 说明 抽象享元 该角色是所有的具体享元类的超类，它给出了具体享元类需要实现的公共接口。 具体享元 实现抽象享元角色所规定出的接口。 享元工厂 本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。 抽象享元abstract public class Flyweight { // 示意性方法，参数state是外蕴状态。 public abstract void operation(String state); } 具体享元public class ConcreteFlyweight extends Flyweight { private Character intrinsicState = null; // 内蕴状态作为参数传入 public ConcreteFlyweight(Character state) { this.intrinsicState = state; } // 外蕴状态作为参量传入方法中，改变方法的行为。 public void operation(String state) { System.out.println(&quot;\tIntrisic State=&quot; + intrinsicState + &quot;, Extriinsic State=&quot;+state); } } 享元工厂import java.util.Map; import java.util.HashMap; import java.util.Iterator; public class FlyweightFactory { private HashMap flies = new HashMap(); public Flyweight factory(Character state) { if (flies.containsKey(state)) { System.out.println(state+&quot; exists.&quot;); return (Flyweight)flies.get(state); } else { System.out.println(state+&quot; not exists!&quot;); Flyweight fly = new ConcreteFlyweight(state); flies.put(state, fly); return fly; } } } 客户端测试程序public class Client { public static void main(String[] args) { FlyweightFactory factory = new FlyweightFactory(); Flyweight fly = factory.factory(new Character(&apos;a&apos;)); fly.operation(&quot;First Call&quot;); fly = factory.factory(new Character(&apos;b&apos;)); fly.operation(&quot;Second Call&quot;); fly = factory.factory(new Character(&apos;a&apos;)); fly.operation(&quot;Third Call&quot;); } } 运行结果： a not exists! Intrisic State=a, Extriinsic State=First Call b not exists! Intrisic State=b, Extriinsic State=Second Call a exists. Intrisic State=a, Extriinsic State=Third Call 结果说明： 抽象享元类Flyweight提供了operation()公共接口。具体享元类ConcreteFlyweight实现了抽象享元所给定的接口。享元工厂类FlyweightFactory负责创建和管理享元角色。客户端不能直接将具体享元类实例化，而必须通过调用工厂对象的factory()来获取享元对象。在示例中，虽然客户端申请了三个享元对象，但是实际创建的享元对象只有两个，这就是共享的含义。 复合享元模式在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。而还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。 复合享元模式的UML类图如下： 复合享元角色所涉及到的角色如下：抽象享元(Flyweight)，具体享元(ConcreteFlyweight)，复合享元(ConcreteCompositeFlyweight)，享元工厂(FlyweightFactory)。 角色 说明 抽象享元 该角色是所有的具体享元类的超类，它给出了具体享元类需要实现的公共接口。 具体享元 实现抽象享元角色所规定出的接口。 复合享元 复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。 享元工厂 本角色负责创建和管理享元角色。 抽象享元抽象享元类是Flyweight，它定义了operation()公共接口，operation()方法接收一个外蕴状态作为参量。 abstract public class Flyweight { // 示意性方法，参数state是外蕴状态 public abstract void operation(String state); } 具体享元具体享元类是ConcreteFlyweight。它主要责任有两个：(01) 实现抽象享元所定义的接口operation()。(02) 为内涵状态提供存储空间，也就是ConcreteFlyweight中的intrinsicState树形。 public class ConcreteFlyweight extends Flyweight { private Character intrinsicState = null; // 构造函数，内蕴状态作为参数传入 public ConcreteFlyweight(Character state){ this.intrinsicState = state; } // 外蕴状态作为参数传入方法中，改变方法的行为， @Override public void operation(String state) { System.out.println(&quot;\tIntrisic State=&quot; + intrinsicState + &quot;, Extriinsic State=&quot;+state); } } 复合享元复合享元类是ConcreteCompositeFlyweight。 复合享元是由”单纯享元”对象通过复合而成，因此，它提供了add()这样的聚集管理方法。由于一个复合享元对象具有不同的聚集元素，这些聚集元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。 此外，复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法，这个方法有一个参数，代表复合享元对象的外蕴状态。一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的；而一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的，不然就没有使用价值了。 import java.util.Map; import java.util.HashMap; import java.util.Iterator; // 复合享元：它由若干个&quot;单纯享元对象&quot;组成。 public class ConcreteCompositeFlyweight extends Flyweight { private HashMap flies = new HashMap(); private Flyweight flyweight; // 增加一个新的单纯享元对象到复合享元中 public void add(Character key , Flyweight fly) { flies.put(key,fly); } // 外蕴状态作为参数传入到方法中 @Override public void operation(String state) { Flyweight fly = null; for (Iterator it = flies.entrySet().iterator(); it.hasNext(); ) { Map.Entry e = (Map.Entry) it.next(); fly = (Flyweight) e.getValue(); fly.operation(state); } } } 享元工厂享元工厂是FlyweightFactory类。 享元工厂提供两种不同的”返回抽象享元”的方法，一种用于提供单纯享元对象，另一种用于提供复合享元对象。 当需要单纯享元的时候，就调用factory()，并传入Character类型的参数。当需要复合享元的时候，就调用factory()，并传入String类型的参数。 import java.util.Map; import java.util.HashMap; import java.util.Iterator; public class FlyweightFactory { private HashMap flies = new HashMap(); // 创建&quot;复合享元&quot;的工厂方法 public Flyweight factory(String compositeState){ ConcreteCompositeFlyweight compositeFly = new ConcreteCompositeFlyweight(); int length = compositeState.length(); Character state = null; for (int i=0; i&lt;length; i++) { state = new Character(compositeState.charAt(i)); System.out.println(&quot;factory(&quot;+state+&quot;)&quot;); // 通过 this.factory(state)创建&quot;单纯享元&quot;， // 然后 将&quot;单纯享元&quot;添加到&quot;复合享元&quot;中。 compositeFly.add(state, this.factory(state)); } return compositeFly; } // 创建&quot;单纯享元&quot;的工厂方法 public Flyweight factory(Character state){ if (flies.containsKey(state)) { return (Flyweight)flies.get(state); } else { Flyweight fly = new ConcreteFlyweight(state); flies.put(state, fly); return fly; } } } 客户端测试程序客户端是Client。 public class Client { public static void main(String[] args) { FlyweightFactory factory = new FlyweightFactory(); String str = &quot;abcda&quot;; Flyweight com1 = factory.factory(str); Flyweight com2 = factory.factory(str); com1.operation(&quot;Composite Call&quot;); com2.operation(&quot;Composite Call&quot;); System.out.println(&quot;com1==com2:&quot;+(com1==com2)); Character c = &apos;1&apos;; Flyweight pure1 = factory.factory(c); Flyweight pure2 = factory.factory(c); pure1.operation(&quot;pure Call&quot;); pure2.operation(&quot;pure Call&quot;); System.out.println(&quot;pure1==pure2:&quot;+(pure1==pure2)); } } 运行结果： factory(a) factory(b) factory(c) factory(d) factory(a) factory(a) factory(b) factory(c) factory(d) factory(a) Intrisic State=d, Extriinsic State=Composite Call Intrisic State=b, Extriinsic State=Composite Call Intrisic State=c, Extriinsic State=Composite Call Intrisic State=a, Extriinsic State=Composite Call Intrisic State=d, Extriinsic State=Composite Call Intrisic State=b, Extriinsic State=Composite Call Intrisic State=c, Extriinsic State=Composite Call Intrisic State=a, Extriinsic State=Composite Call com1==com2:false Intrisic State=1, Extriinsic State=pure Call Intrisic State=1, Extriinsic State=pure Call 结果说明：Client中创建两个复合享元com1和com2，它们的内容都是”abcda”。但是com1==com2:false表明：复合享元是不能够共享的。Client中创建两个单纯享元pure1和pure2，它们的内容都是’1’。pure1==pure2:true表明：单纯享元是可以共享的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式11之 代理(Proxy)模式(结构模式)]]></title>
    <url>%2F2014%2F05%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11%E4%B9%8B-%E4%BB%A3%E7%90%86-Proxy-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式简介代理(Proxy)模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。 一个比较典型的例子就是”Windows的快捷方式”。Windows快捷方式，可以使任何对象同时出现在多个地方而不必修改原对象。对快捷方式的调用完全与对原对象的调用一样，换言之，快捷方式对客户端是完全透明的。 代理模式的类图如下： 代理模式中共包含了三个角色: 抽象主体(Subject)，代理主题(ProxySubject)，真实主题(RealSubject)。 角色 说明 抽象主题角色 声明了真实主题和代理主题的共同接口，这样一来在任何可以使用真实主题的地方都可以使用代理主题。 代理主题角色 代理主题内部含有真实主题的引用，从而可以在任何时候操作真实主题；代理主题提供一个与真实主题相同的接口，以便可以在任何时候替代真实主题。代理主题通常在客户端调用传递给真实主题之前或之后，执行某个操作，而不是单纯地将调用传递给真实主题。 真实主题角色 定义了代理主题所代表的真实主题。 示意代码 abstract public class Subject { // 声明一个抽象的请求方法 public abstract void request(); } public class RealSubject extends Subject { @Override public void request() { System.out.println(&quot;From real subject&quot;); } } public class ProxySubject extends Subject{ RealSubject realSubject = new RealSubject(); @Override public void request() { preRequest(); realSubject.request(); postRequest(); } // 请求前的操作 private void preRequest() { // something you want to do before requesting } // 请求后的操作 private void postRequest() { // something you want to do after requesting } } 若要使用代理主题，则可以通过以下代码： Subject subject = new ProxySubject(); subject.request(); 从中可以看出代理模式是怎样工作的。首先，代理模式并不改变主题的接口，因为代理模式的用意是不让客户端感觉到代理的存在；其次，代理使用委派将客户端的调用委派给真实的主题对象；换言之，代理主题起到的是一个传递请求的作用。最后，代理主题在传递请求之前和之后都可以执行特定的操作，而不是单纯的传递请求。 它的时序图如下： 代理模式示例下面，通过”高老庄悟空降八戒”的例子来对代理模式进行说明。 悟空假扮成高小姐去见猪八戒。通过代理模式去分析，”高小姐的神貌”是抽象主题，高小姐本人是真实主题，而悟空是代理主题，他巧妙的实现了”高小姐的神貌”；猪八戒就是客户端，猪八戒根本分不清”悟空假扮的高小姐”和”高小姐本人”。 对应的类图如下： 下面是各个角色对应的类。 抽象主体抽象主题是”高小姐的神貌”，它对应的类是AbstractAppearance。 abstract public class AbstractAppearance { public abstract void smile(); } 真实主题真实主题是”高小姐本人”，它对应的类是MissGao。 public class MissGao extends AbstractAppearance { @Override public void smile() { System.out.println(&quot;Miss Gao smiles.&quot;); } } 代理主题代理主题是”悟空”，它对应的类是WuKong。 public class WuKong extends AbstractAppearance { AbstractAppearance missGao = new MissGao(); @Override public void smile() { missGao.smile(); System.out.println(&quot;Actual, it&apos;s wukong smiles.&quot;); } } 客户端测试程序客户端是”八戒”，它对应的类是BaJie。 public class BaJie { public static void main(String[] args) { // 八戒只认识&quot;高小姐的样貌&quot;，而该&quot;高小姐的样貌&quot;实际上是悟空假扮的。 AbstractAppearance appearance = new WuKong(); appearance.smile(); } } 运行结果： Miss Gao smiles. Actual, it&apos;s wukong smiles.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式10之 装饰(Decorator)模式(结构模式)]]></title>
    <url>%2F2014%2F05%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F10%E4%B9%8B-%E8%A3%85%E9%A5%B0-Decorator-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式简介装饰(Decorator)模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 它以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。 装饰模式的类图如下： 装饰模式包含了三个角色: 抽象构件(Component)，具体构件(ConcreteComponent) ，装饰(Decorator) 和 具体装饰(ConcreteDecorator)。 角色 说明 抽象构件(Component) 给出一个抽象接口，以规范准备接收附加责任的对象。 具体构件(ConcreteComponent) 定义一个将要接收附加责任的类。 装饰(Decorator) 持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 具体装饰(ConcreteDecorator) 负责给构件对象“贴上”附加的责任。 示意代码 public interface Component { // 商业方法 public void sampleOperation(); } public class ConcreteComponent implements Component { // 构造函数 public ConcreteComponent() { // write your code here } @Override public void sampleOperation() { // 写相关的业务代码 } } public class Decorator implements Component{ private Component component; // 构造函数 public Decorator(Component component){ // write your code here } // 构造函数 public Decorator(Component component){ this.component = component; } @Override public void sampleOperation() { // 商业方法，委派给构件 component.sampleOperation(); } } public class ConcreteDecorator extends Decorator { @Override public void sampleOperation() { super.sampleOperation(); // write your code here } } 需要指出的是：(01) 在装饰类Decorator中，有一个私有树形component，其数据结构是构件(Component)。(02) 装饰类Decorator实现了构件(Component)接口。(03) Decorator类中，接口的每一个实现方法都委派给父类，但并不单纯地委派，而是有功能的增强。 装饰模式示例下面，通过”齐天大圣”的例子来对装饰模式进行说明。 孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。 在装饰模式中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是花、鸟、鱼、虫等七十二般变化。它的类图如下： 示例代码 抽象构件(Component)抽象构件是”齐天大圣”，它包行了move()接口。 abstract public class GreatSage { public abstract void move(); } 具体构件(ConcreteComponent)具体构件属于大圣的本尊，就是孙悟空。 public class Monkey extends GreatSage { @Override public void move() { System.out.println(&quot;Monkey Move&quot;); } } 装饰(Decorator)装饰由大圣的七十二变扮演。 public class Change extends GreatSage { private GreatSage sage; public Change(GreatSage sage){ this.sage = sage; } @Override public void move() { sage.move(); } } 具体装饰(ConcreteDecorator)。花 public class Flower extends Change { public Flower(GreatSage sage) { super(sage); } @Override public void move() { System.out.println(&quot;Flower Move&quot;); } } 鸟 public class Bird extends Change { public Bird(GreatSage sage) { super(sage); } @Override public void move() { System.out.println(&quot;Bird Move&quot;); } } 鱼 public class Fish extends Change { public Fish(GreatSage sage) { super(sage); } @Override public void move() { System.out.println(&quot;Fish Move&quot;); } } 虫 public class Insect extends Change { public Insect(GreatSage sage) { super(sage); } @Override public void move() { System.out.println(&quot;Insect Move&quot;); } } 客户端测试程序public class Client { public static void main(String[] args) { GreatSage sage = new Monkey(); // 1. &quot;齐天大圣&quot; sage.move(); // 2. &quot;齐天大圣&quot;变成&quot;鸟&quot;之后，再变成&quot;鱼&quot; GreatSage bird = new Bird(sage); GreatSage fish = new Fish(bird); fish.move(); // 3. &quot;齐天大圣&quot;变成&quot;昆虫&quot;之后，再变成&quot;花&quot; GreatSage flower = new Flower(new Insect(sage)); flower.move(); } } 运行结果： Monkey Move Fish Move Flower Move 结果说明：上面的例子的2中，系统把大圣从一只猢狲装饰成了一只鸟儿（把鸟儿的功能加到了猢狲身上），然后又把鸟儿装饰成了一条鱼儿（把鱼儿的功能加到了猢狲+鸟儿身上，得到了猢狲+鸟儿+鱼儿）。如下图所示：]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式09之 合成(Composite)模式(结构模式)]]></title>
    <url>%2F2014%2F05%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F09%E4%B9%8B-%E5%90%88%E6%88%90-Composite-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[合成模式简介合成模式属于对象的结构型模式，有时又被称为”部分-整体模式”。合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。 例如，文件系统就是一个典型的合成模式系统。合成模式的树形图如下所示： 它的UML类图如下所示： 它共包括3个角色：抽象构件(Component)，树叶构件(Leaf) 和 树枝构件(Composite)。 角色 说明 抽象构件 这是一个抽象角色，它给参加组合的对象规定一个接口。这个角色给出共有的接口及其默认行为。 树叶构件 代表参加组合的树叶对象。树叶对象没有下级子对象，它定义出参加组合的原始对象的行为。 树枝构件 代表参加组合的有下级子对象的对象，并给出树枝构件对象的行为。 根据”参加组合的对象的管理方式”，可以将合成模式分为两种不同的形式：安全合成模式 和 透明合成模式。• 安全合成模式：此方式只允许”树枝构件”有对象的管理方法。• 透明合成模式：此方式只允许”树枝构件’和”树叶构件”都有对象的管理方法，但”树叶构件”中的管理方法无实际意义。 安全合成模式安全合成模式要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。 安全合成模式的UML图如下： 它共包括3个角色：抽象构件(Component)，树叶构件(Leaf) 和 树枝构件(Composite)。 角色 说明 抽象构件 这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。 树叶构件 树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。 树枝构件 代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。 示例代码 public interface Component { // 返还自己的示例 Composite getComposite(); // 某个商业方法 void sampleOperation(); } public class Composite implements Component { private Vector componentVector = new Vector(); public Composite getComposite() { return this; } public void sampleOperation() { Enumeration enum = composites(); while (enum.hasMoreElements()) { ((Composite)enum.nextElement()).sampleOperation(); } } // 添加一个子构件对象 public void add(Component component) { componentVector.addElement(component); } // 删除一个子构件对象 public void remove(Component component) { componentVector.removeElement(component); } // 聚集管理办法，返还聚集的Enumeration对象 public Enumeration components() { return componentVector.elements(); } } public class Leaf implements Component { public void sampleOperation() { } public Composite getComposite() { return null; } } 从中可以看出，树叶构建(Leaf)中没有对节点的管理方法，而只有树枝构建(Composite)中有节点的管理方法。 透明合成模式与安全式的合成模式不同的是，透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。 透明合成模式的UML图如下： 它共包括3个角色：抽象构件(Component)，树叶构件(Leaf) 和 树枝构件(Composite)。 角色 说明 抽象构件 这是一个抽象角色，它给参加组合的对象规定一个接口，规范共有的接口及默认行为。这个接口可以用来管理所有的子对象，要提供一个接口以规范取得和管理下层组件的接口，包括add(), remove()以及getChild()之类的方法。 树叶构件 代表参加组合的树叶对象，定义出参加组合的原始对象的行为。树叶类会给出add(), remove()以及getChild()之类的用来管理子类对象的方法的平庸实现。 树枝构件 代表参加组合的有子对象的对象，定义出这样的对象的行为。 示例代码 public interface Component { // 某个商业方法 void sampleOperation(); // 返还自己的示例 Composite getComposite(); // 聚集管理方法，增加子构件对象 void add(Component component); // 聚集管理方法，删除子构件对象 void remove(Component component); // 聚集管理办法，返还聚集的Enumeration对象 Enumeration components(); } public class Composite implements Component { private Vector componentVector = new Vector(); public Composite getComposite() { return this; } public void sampleOperation() { Enumeration enum = composites(); while (enum.hasMoreElements()) { ((Composite)enum.nextElement()).sampleOperation(); } } // 添加一个子构件对象 public void add(Component component) { componentVector.addElement(component); } // 删除一个子构件对象 public void remove(Component component) { componentVector.removeElement(component); } // 聚集管理办法，返还聚集的Enumeration对象 public Enumeration components() { return componentVector.elements(); } } public class Leaf implements Component { public void sampleOperation() { } public Composite getComposite() { return null; } // 添加一个子构件对象 public void add(Component component) { } // 删除一个子构件对象 public void remove(Component component) { } // 聚集管理办法，返还聚集的Enumeration对象 public Enumeration components() { return null; } } 合成模式示例下面以一个逻辑树为例子，演示合成模式。 抽象构件(IFile.java)public interface IFile { //返回自己的实例 IFile getComposite(); //某个商业方法 void sampleOperation(); //获取深度 int getDeep(); //设置深度 void setDeep(int x); } 树枝构件(Folder.java)import java.util.Vector; public class Folder implements IFile { private String name; //文件名字 private int deep; //层级深度，根深度为0 private Vector&lt;IFile&gt; componentVector = new Vector&lt;IFile&gt;(); public Folder(String name) { this.name = name; } //返回自己的实例 public IFile getComposite() { return this; } //某个商业方法 public void sampleOperation() { System.out.println(&quot;执行了某个商业方法！&quot;); } //增加一个文件或文件夹 public void add(IFile IFile) { componentVector.addElement(IFile); IFile.setDeep(this.deep + 1); } //删除一个文件或文件夹 public void remove(IFile IFile) { componentVector.removeElement(IFile); } //返回直接子文件（夹）集合 public Vector getAllComponent() { return componentVector; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getDeep() { return deep; } public void setDeep(int deep) { this.deep = deep; } } 树枝构件(File.java)public class File implements IFile { private String name; //文件名字 private int deep; //层级深度 public File(String name) { this.name = name; } //返回自己的实例 public IFile getComposite() { return this; } //某个商业方法 public void sampleOperation() { System.out.println(&quot;执行了某个商业方法！&quot;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getDeep() { return deep; } public void setDeep(int deep) { this.deep = deep; } } 客户端测试程序(Client.java)import java.util.Iterator; import java.util.Vector; import java.util.Collections; public class Client { private static final String INDENT_CHAR = &quot;\t&quot;; //文件层次缩进字符 public static void main(String args[]) { new Client().test(); } /** * 客户端测试方法 */ public void test() { //根下文件及文件夹 Folder root = new Folder(&quot;树根&quot;); Folder b1_1 = new Folder(&quot;1_枝1&quot;); Folder b1_2 = new Folder(&quot;1_枝2&quot;); Folder b1_3 = new Folder(&quot;1_枝3&quot;); File l1_1 = new File(&quot;1_叶1&quot;); File l1_2 = new File(&quot;1_叶2&quot;); File l1_3 = new File(&quot;1_叶3&quot;); //b1_2下的文件及文件夹 Folder b2_1 = new Folder(&quot;2_枝1&quot;); Folder b2_2 = new Folder(&quot;2_枝2&quot;); File l2_1 = new File(&quot;2_叶1&quot;); //缔造树的层次关系（简单测试，没有重复添加的控制） root.add(b1_1); root.add(b1_2); root.add(l1_1); root.add(l1_2); b1_2.add(b2_1); b1_2.add(b2_2); b1_2.add(l2_1); root.add(l1_3); root.add(b1_3); //控制台打印树的层次 outTree(root); } public void outTree(Folder folder) { System.out.println(folder.getName()); iterateTree(folder); } /** * 遍历文件夹，输入文件树 * * @param folder */ public void iterateTree(Folder folder) { Vector&lt;IFile&gt; clist = folder.getAllComponent(); for (Iterator&lt;IFile&gt; it = clist.iterator(); it.hasNext();) { IFile em = it.next(); if (em instanceof Folder) { Folder cm = (Folder) em; System.out.println(getIndents(em.getDeep()) + cm.getName()); iterateTree(cm); } else { System.out.println(getIndents(em.getDeep()) + ((File) em).getName()); } } } /** * 文件层次缩进字符串 * * @param x 缩进字符个数 * @return 缩进字符串 */ public static String getIndents(int x) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; x; i++) { sb.append(INDENT_CHAR); } return sb.toString(); } } 运行结果： 树根 1_枝1 1_枝2 2_枝1 2_枝2 2_叶1 1_叶1 1_叶2 1_叶3 1_枝3]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>合成模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式08之 适配器(Adapter)模式(结构模式)]]></title>
    <url>%2F2014%2F05%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08%E4%B9%8B-%E9%80%82%E9%85%8D%E5%99%A8-Adapter-%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式简介原型模式是”创建模式”(创建对象的模式)。通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。 Java语言的支持支持创建模式。在Java中Object是所有类的父类，而Object中提供了clone()方法。clone()会通过调用本地方法实现对象的复制。它的源码如下： protected native Object clone() throws CloneNotSupportedException; clone()定义了Object中，就相当于Java中的任何类都继承了clone()方法。但是，如果要类支持克隆的话，必须要声明该类实现了Cloneable接口。否则，调用该类的clone()方法时，会抛出CloneNotSupportedException异常。 使用场景: 系统的产品是动态加载的，而产品类具有一定的等级结构。 例如，数据库中存储了很多数据，有时我们需要将其中的一些数据取出来存放到新的表格中。或者，有时候我们需要对比一个对象在处理前/后的姿态；在处理之前，可以克隆该对象，然后和处理之后的对象比较。 原型模式有两种表现形式：简单形式 和 登记形式。如果需要创建的原型对象数目少而且比较固定的华，就采用”简单形式”；如果要创建的原型对象数目不确定的华，就采用”登记形式”。 简单形式的原型模式类图 它涉及到3个角色：客户(Client), 抽象原型(Prototype) 和 具体原型(ConcretePrototype)。 角色 说明 Client 客户类提出创建对象的请求。 Prototype 抽象原型给出所有的具体原型所需要实现的函数接口。 ConcreteType 被复制的对象，实现了Prototype中的函数接口。 代码模型 public interface Prototype extends Cloneable { Prototype clone(); } public class ConcretePrototype implements Prototype { public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException e) { return null; } } } public class Client { private Prototype prototype; public void operation(Prototype example) { Prototype p = (Prototype) example.clone(); } } 登记形式的原型模式UML类图 它涉及到4个角色：客户(Client), 抽象原型(Prototype), 具体原型(ConcretePrototype) 和 PrototypeManager(原型管理器)。 角色 说明 Client 客户类提出创建对象的请求。 Prototype 抽象原型给出所有的具体原型所需要实现的函数接口。 ConcreteType 被复制的对象，实现了Prototype中的函数接口。 PrototypeManager 创建具体原型类的对象，并记录每一个被创建的对象。 代码模型 public interface Prototype extends Cloneable { Prototype clone(); } public class ConcretePrototype implements Prototype { public synchronized Object clone() { Prototype temp = null; try { temp = (Prototype)super.clone(); return temp; } catch (CloneNotSupportedException e) { return null; } finally { return temp; } } } public class PrototypeManager { private Vector objects = new Vector(); public void add(Prototype object) { objects.add(object); } public Prototype get(int i) { return (Prototype) objects.get(i); } public int getSize() { return objects.size(); } } public class Client { private PrototypeManager mgr; private Prototype prototype; public void registerPrototype() { prototype = new ConcretePrototype(); Prototype copytype = (Prototype)prototype.clone(); mgr.add(copytype); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式07之 原型模式(创建模式)]]></title>
    <url>%2F2014%2F05%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07%E4%B9%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式简介原型模式是”创建模式”(创建对象的模式)。通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。 Java语言的支持支持创建模式。在Java中Object是所有类的父类，而Object中提供了clone()方法。clone()会通过调用本地方法实现对象的复制。它的源码如下： protected native Object clone() throws CloneNotSupportedException; clone()定义了Object中，就相当于Java中的任何类都继承了clone()方法。但是，如果要类支持克隆的话，必须要声明该类实现了Cloneable接口。否则，调用该类的clone()方法时，会抛出CloneNotSupportedException异常。 使用场景: 系统的产品是动态加载的，而产品类具有一定的等级结构。 例如，数据库中存储了很多数据，有时我们需要将其中的一些数据取出来存放到新的表格中。或者，有时候我们需要对比一个对象在处理前/后的姿态；在处理之前，可以克隆该对象，然后和处理之后的对象比较。 原型模式有两种表现形式：简单形式 和 登记形式。如果需要创建的原型对象数目少而且比较固定的华，就采用”简单形式”；如果要创建的原型对象数目不确定的华，就采用”登记形式”。 简单形式的原型模式类图 它涉及到3个角色：客户(Client), 抽象原型(Prototype) 和 具体原型(ConcretePrototype)。 角色 说明 Client 客户类提出创建对象的请求。 Prototype 抽象原型给出所有的具体原型所需要实现的函数接口。 ConcreteType 被复制的对象，实现了Prototype中的函数接口。 代码模型 public interface Prototype extends Cloneable { Prototype clone(); } public class ConcretePrototype implements Prototype { public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException e) { return null; } } } public class Client { private Prototype prototype; public void operation(Prototype example) { Prototype p = (Prototype) example.clone(); } } 登记形式的原型模式UML类图 它涉及到4个角色：客户(Client), 抽象原型(Prototype), 具体原型(ConcretePrototype) 和 PrototypeManager(原型管理器)。 角色 说明 Client 客户类提出创建对象的请求。 Prototype 抽象原型给出所有的具体原型所需要实现的函数接口。 ConcreteType 被复制的对象，实现了Prototype中的函数接口。 PrototypeManager 创建具体原型类的对象，并记录每一个被创建的对象。 代码模型 public interface Prototype extends Cloneable { Prototype clone(); } public class ConcretePrototype implements Prototype { public synchronized Object clone() { Prototype temp = null; try { temp = (Prototype)super.clone(); return temp; } catch (CloneNotSupportedException e) { return null; } finally { return temp; } } } public class PrototypeManager { private Vector objects = new Vector(); public void add(Prototype object) { objects.add(object); } public Prototype get(int i) { return (Prototype) objects.get(i); } public int getSize() { return objects.size(); } } public class Client { private PrototypeManager mgr; private Prototype prototype; public void registerPrototype() { prototype = new ConcretePrototype(); Prototype copytype = (Prototype)prototype.clone(); mgr.add(copytype); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式06之 建造模式(创建模式)]]></title>
    <url>%2F2014%2F05%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06%E4%B9%8B-%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造模式简介建造模式是”创建模式”(创建对象的模式)。当我们要创建的对象比较复杂的时候，可以将对象的”创建”和”表示”分割开来；从而可以使一个构造过程创建具有不同表示的产品。这种参见对象的方式就是建造模式。 建造模式的使用场景 (01), 对象包含复杂的内部结构。每个内部成分本身可以是对象，也可以仅仅是一个对象的一个组成成分。&nbsp;&nbsp;&nbsp;&nbsp; 例如，一个电子邮件由发件人地址、收件人地址、主题、内容、附件等内容。我们可以根据这些组成部分组合成一份邮件，然后发送出去。 (02), 对象的各个属性相互依赖。&nbsp;&nbsp;&nbsp;&nbsp; 例如，某对象包含许多性质，而这些性质必须按照某个顺序赋值才有意义。 (03), 对象创建过程会使用到系统中的其他对象，而这些对象在产品对象的创建过程中不易得到。 下面看看它的结构图： 建造模式包括4个组成部分：导演者(Director), 抽象建造者(Builder), 具体建造者(ConcreteBuilder) 和 产品(Product)。 组成部分 说明 Director 它会调用具体创建者来创造一个产品对象。 Builder 它会给出”创建一个产品对象的各个组成成分”的抽象接口。 ConcreteBuilder 实现”抽象建造者”给出的抽象接口。 Product 要被创建的产品对象。 建造模式代码模型public class Director { private Builder builder; // 构造产品 public void construct() { builder = new ConcreteBuilder(); builder.buildPart1(); builder.buildPart2(); } } abstract public class Builder { // 构造&quot;产品的Part1&quot;的接口 public abstract void buildPart1(); // 构造&quot;产品的Part2&quot;的接口 public abstract void buildPart2(); // 返回产品 public abstract Product retrieveResult(); } public class ConcreteBuilder { private Product product = new Product(); public void buildPart1() { // 参见产品的Part1 } public void buildPart2() { // 参见产品的Part2 } public Product retrieveResult() { return product; } } public class Product { // 产品组成部分... } 建造模式示例假设由一个电子杂志系统，定期的向用户的发送电子邮箱。发送的电子邮件模板由两种：欢迎和欢送。邮件包括”发送者地址”，”接收者地址”，“主题”，“内容”，“发送日期”等内容；其中，“发送者地址”和“接收者地址”是必填的。 下面通过建造模式实现该系统，对应的UML图如下： 建造模式包括4个组成部分：”导演者”, “抽象建造者”, “具体建造者”和”产品”这4个角色分别如下： “导演者”导演者是Director。Director会根据Builder对象，构造出邮件。 Director的源码 public class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public void construct(String from, String to) { builder.buildFrom(from); builder.buildTo(to); builder.buildSubject(); builder.buildBody(); builder.buildSendDate(); builder.send(); } } “抽象建造者”抽象建造者是Builder。Builder是抽象类，它包含具体的邮件对象msg，msg是在Builder的子类中根据所要创建的消息来初始化的。此外，Builder提供了构造邮件的函数接口。 Builder的源码 import java.util.Date; abstract public class Builder { protected AutoMessage msg; public Builder() { } public abstract void buildBody() ; public abstract void buildSubject() ; public void buildFrom(String from) { msg.setFrom(from); } public void buildTo(String to) { msg.setTo(to); } public void buildSendDate() { msg.setSendDate(new Date()); } public void send() { msg.send(); } } “具体建造者”具体建造者是WelcomeBuilder和GoodbyeBuilder。WelcomeBuilder是欢迎消息，GoodbyeBuilder是欢送消息。 WelcomeBuilder的源码 public class WelcomeBuilder extends Builder { public WelcomeBuilder() { System.out.println(&quot;create WelcomeBuilder&quot;); this.msg = new WelcomeMessage(); } public void buildBody() { msg.setBody(&quot;Welcome body!&quot;); } public void buildSubject() { msg.setSubject(&quot;Welcome subject!&quot;); } } GoodbyeBuilder的源码 public class GoodbyeBuilder extends Builder { public GoodbyeBuilder() { System.out.println(&quot;create GoodbyeBuilder&quot;); msg = new GoodbyeMessage(); } public void buildBody() { msg.setBody(&quot;Goodbye body!&quot;); } public void buildSubject() { msg.setSubject(&quot;Goodbye subject!&quot;); } } “产品”产品是AutoMessage。AutoMessage是抽象出来的产品类，它包含两个子类WelcomeBuilder和GoodbyeMessage。 AutoMessage的源码 import java.util.Date; abstract public class AutoMessage { protected String from; protected String to; protected String subject; protected String body; protected Date sendDate; public void setFrom(String from) { this.from = from; } public String getFrom() { return from; } public void setTo(String to) { this.to = to; } public String getTo() { return to; } public void setSubject(String subject) { this.subject = subject; } public String getSubject() { return subject; } public void setBody(String body) { this.body = body; } public String getBody() { return body; } public void setSendDate(Date sendDate) { this.sendDate = sendDate; } public Date getSendDate() { return sendDate; } public void send() { System.out.println(&quot;send MSG[Subject: \&quot;&quot;+subject+&quot;\&quot;, Body: \&quot;&quot;+body+&quot;\&quot;] from \&quot;&quot;+from+&quot;\&quot; to \&quot;&quot;+to+&quot;\&quot; @date:\&quot;&quot;+sendDate+&quot;\&quot;&quot;); } } WelcomeMessage的源码 public class WelcomeMessage extends AutoMessage { public WelcomeMessage() { System.out.println(&quot;Create WelcomeMessage&quot;); } public void sayWelcome() { System.out.println(&quot;Welcome.&quot;); } } GoodbyeMessage的源码 public class GoodbyeMessage extends AutoMessage { public GoodbyeMessage() { System.out.println(&quot;Create GoodbyeMessage&quot;); } public void sayGoodbye() { System.out.println(&quot;Goodbye.&quot;); } } 客户端测试程序客户端是”Client”。 Client的源码 public class Client { private static Director dw, dg; private static Builder bw, bg; public static void main(String[] args) { bw = new WelcomeBuilder(); dw = new Director(bw); dw.construct(&quot;skywang12345@gmail.com&quot;, &quot;java_patterns@gmail.com&quot;); bg = new GoodbyeBuilder(); dg = new Director(bg); dg.construct(&quot;skywang54321@gmail.com&quot;, &quot;java_patterns@gmail.com&quot;); } } 运行结果： create WelcomeBuilder Create WelcomeMessage send MSG[Subject: &quot;Welcome subject!&quot;, Body: &quot;Welcome body!&quot;] from &quot;skywang12345@gmail.com&quot; to &quot;java_patterns@gmail.com&quot; @date:&quot;Sun Jan 19 10:48:02 CST 2014&quot; create GoodbyeBuilder Create GoodbyeMessage send MSG[Subject: &quot;Goodbye subject!&quot;, Body: &quot;Goodbye body!&quot;] from &quot;skywang54321@gmail.com&quot; to &quot;java_patterns@gmail.com&quot; @date:&quot;Sun Jan 19 10:48:02 CST 2014&quot;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>建造模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式05之 多例模式(创建模式)]]></title>
    <url>%2F2014%2F05%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F05%E4%B9%8B-%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[多例模式简介多例模式(Multiton)，顾名思义，是指存在一个类由多个相同实例，而且该实例都是该类本身。这个类叫做多例类。 多例模式的特点是： (01), 多例类可以由多个实例。 (02), 多例类必须自己创建、管理自己的实例，并向外界提供自己的实例。 多例模式的结构图如下： 多例模式代码模型public class /images/mediaMultiton { public static final Multiton INSTANCE_01 = new Multiton(&quot;instance_01&quot;); public static final Multiton INSTANCE_02 = new Multiton(&quot;instance_02&quot;); private Multiton(String name) {} } 多例模式示例示例代码： // 多例类。 // 包括CHINA, ENGLAND 和 FRANCE 这3个实例。 class Country { public static final Country CHINA = new Country(&quot;chinae&quot;); public static final Country ENGLAND = new Country(&quot;england&quot;); public static final Country FRANCE = new Country(&quot;france&quot;); private String name; private Country(String name) { this.name = name; } public String getName() { return name; } } public class MultitonTest { public static void main(String[] args) { Country c1 = Country.CHINA; Country c2 = Country.ENGLAND; Country c3 = Country.FRANCE; System.out.println(&quot;c1 is: &quot;+c1.getName()); System.out.println(&quot;c2 is: &quot;+c2.getName()); System.out.println(&quot;c3 is: &quot;+c3.getName()); } } 运行结果： c1 is: chinae c2 is: england c3 is: france]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式04之 单例模式(创建模式)]]></title>
    <url>%2F2014%2F05%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F04%E4%B9%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式简介单例模式(Simple Factory)，确保类只有一个实例，而且类自己实例化该实例并向客户端提供该实例。它属于”创建模式”(创建对象的模式)。 单例模式具有以下特点：(01), 类只能有一个实例。(02), 类自行创建实例。(03), 向整个系统提供这个实例。 它的结构图如下所示： 单例模式代码模型单例模式包括：饿汉式单例模式 和 懒汉式单例模式 它们的相同点：它们的单例类中，构造函数都是私有的！这样，就避免了外界利用构造函数创建对象，而只能通过指定的函数来获取对象。此外，由于构造函数是私有的，此类不能被继承！ 它们的不同点：饿汉式单例模式，是在类被加载时，就创建了类的对象。而在懒汉式单例模式中，在类被第一次引用时，才将自己实例化。 饿汉式单例模式的代码模型public class EagerSingleton { private static final EagerSingleton mInstance = new EagerSingleton(); private EagerSingleton() {} public static EagerSingleton getInstance() { return mInstance; } } 在饿汉式单例模式中，在类被加载时，静态变量mInstance就会被初始化。这时候，单例类的唯一实例就被创建出来了。 懒汉式单例模式的代码模型public class LazySingleton { private static LazySingleton mInstance = null; private LazySingleton() {} synchronized public static LazySingleton getInstance() { if (mInstance==null) { mInstance = new LazySingleton(); } return mInstance; } } 在懒汉式单例模式中，在类被加载时，静态变量mInstance并不会被初始化；而只有当getInstance()第1次被调用的时候，mInstance才被初始化。 单例模式示例示例代码： class EagerSingleton { private static final EagerSingleton mInstance = new EagerSingleton(); private EagerSingleton() {} public static EagerSingleton getInstance() { return mInstance; } public void doSomething() { System.out.println(Thread.currentThread().getName()+&quot; do something&quot;); } } public class SingletonTest { public static void main(String[] args) { // 启动5个线程。它们会分别获取EagerSingleton实例，并调用它的doSomething()方法。 for (int i=0; i&lt;5; i++) { new Thread( new Runnable() { @Override public void run() { EagerSingleton es = EagerSingleton.getInstance(); es.doSomething(); } }).start(); } } } 运行结果： Thread-3 do something Thread-4 do something Thread-2 do something Thread-1 do something Thread-0 do something]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式03之 抽象工厂模式(创建模式)]]></title>
    <url>%2F2014%2F05%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F03%E4%B9%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式简介抽象工厂模式(Abstract Factory)，它是所有形态的工厂模式中最为抽象，也是最具有一般性的形态。它属于”创建模式”(创建对象的模式)。它的结构图如下所示： 抽象工厂模式的结构共包括4个组成部分：抽象工厂(Factory)，具体工厂(ConcreteFactory), 抽象产品(Product)，具体产品(ConcreteProduct)。 组成部分 说明 Factory 它提供了”创建产品”的函数接口，该函数接口由具体工厂ConcreteFactory来实现。Factory可以是接口或者抽象类。 ConcreteFactory 它实现了Factory的函数接口。 Product 它是抽象产品，是(许多)不同产品抽象出来的。在抽象工厂模式中，抽象产品不止一个。 ConcreteProduct 它是具体产品。ConcreteFactory中”创建产品”的函数实现中，实际上是返回的ConcreteProduct实例。 抽象工厂模式与工厂方法模式的区别: 在工厂方法模式中，”抽象产品”只有一个，而在抽象工厂模式中，”抽象产品”有很多个！在工厂方法模式中，是由”具体工厂”决定返回哪一类产品；然后，抽象工厂中，是由”客户端”决定返回哪一类产品。 抽象工厂模式代码模型代码 public interface Factory { public ProductA newProductA(); public ProductB newProductB(); } public class ConcreteFactory1 implements Factory { public ProductA newProductA() { return new ConcreteProductA1(); } public ProductB newProductB(); return new ConcreteProductB1(); } } public class ConcreteFactory2 implements Factory { public ProductA newProductA2() { return new ConcreteProduct1(); } public ProductB newProductB2(); return new ConcreteProduct1(); } } public interface ProductA { } public class ProductA1 implements ProductA { } public class ProductA2 implements ProductA { } public interface ProductB { } public class ProductB1 implements ProductB { } public class ProductB2 implements ProductB { } 模型的类图 抽象工厂模式示例假设，我们要实现一个工厂管理系统，记录三星和苹果这两家工厂(Factory)生产的手机(Phone)和电脑(Computer)信息。 已知，三星和苹果都由自己的工厂，分别是”三星工厂(SumFactory)”和”苹果工厂(AppleFactory)”。三星工厂生产”三星手机(SumPhone)”和”三星电脑(SumComputer)”，苹果工厂生产”苹果手机(ApplePhone)”和”苹果电脑(AppleComputer)”。 我们用抽象工厂模式实现该系统，它的设计图如下： 在该系统中，”抽象工厂”，”具体工厂”, 抽象产品”和”具体产品”这4个角色分别如下： 抽象工厂“抽象工厂”是Factory，Factory中定义了”生产手机”以及”生产电脑”的方法。 Factory的源码 public interface Factory { // 生产手机 public Phone createPhone() ; // 生产电脑 public Computer createComputer() ; } 具体工厂“具体工厂”是SumFactory和AppleFactory。SumFactory能返回的”三星手机(SumPhone)”和“三星电脑SumComputer”对象。AppleFactory能返回的”苹果手机(ApplePhone)”和“苹果电脑AppleComputer”对象。 SumFactory的源码 public class SumFactory implements Factory{ // 生产三星手机 public Phone createPhone() { return new SumPhone(); } // 生产三星电脑 public Computer createComputer() { return new SumComputer(); } } AppleFactory的源码 public class AppleFactory implements Factory{ // 生产苹果手机 public Phone createPhone() { return new ApplePhone(); } // 生产苹果电脑 public Computer createComputer() { return new AppleComputer(); } } 抽象产品“抽象产品”是”手机(Phone)”和”电脑(Computer)”。手机包括”activate()方法”，而电脑则包括”getOSName()方法”。 Phone的源码 abstract public class Phone { // 激活手机 abstract public void activate(); } Computer的源码 abstract public class Computer { // 获取操作系统名词 abstract public String getOSName(); } 具体产品“具体产品”是”三星手机(SumPhone)”，”三星电脑(SumComputer)”；以及 “苹果手机(ApplePhone)”和”苹果电脑(AppleComputer)”。 SumPhone源码 public class SumPhone extends Phone{ // 激活手机 public void activate() { System.out.println(&quot;activate SumPhone&quot;); } } SumComputer源码 public class SumComputer extends Computer{ // 获取操作系统名词 public String getOSName() { return &quot;Windows&quot;; } } ApplePhone源码 public class ApplePhone extends Phone{ // 激活手机 public void activate() { System.out.println(&quot;activate ApplePhone&quot;); } } AppleComputer源码 public class AppleComputer extends Computer{ // 获取操作系统名词 public String getOSName() { return &quot;Mac&quot;; } } 客户端测试程序客户端是”Client”。 Client的源码 public class Client { public static void main(String[] args) { // 创建&quot;Factory&quot;对象，该对象是&quot;AppleFactory&quot;的实例 Factory appleFac = new AppleFactory(); // 根据工厂实例，创建对应的手机和电脑 Phone applePhone = appleFac.createPhone(); Computer appleComputer = appleFac.createComputer(); // 激活&quot;手机&quot; applePhone.activate(); // 获取&quot;电脑操作系统名词&quot; String appleOS =appleComputer.getOSName(); System.out.println(&quot;appleOS is: &quot;+appleOS); // 创建&quot;Factory&quot;对象，该对象是&quot;SumFactory&quot;的实例 Factory sumFac = new SumFactory(); // 根据工厂实例，创建对应的手机和电脑 Phone sumPhone = sumFac.createPhone(); Computer sumComputer = sumFac.createComputer(); // 激活&quot;手机&quot; sumPhone.activate(); // 获取&quot;电脑操作系统名词&quot; String sumOS = sumComputer.getOSName(); System.out.println(&quot;sumOS is: &quot;+sumOS); } } 运行结果： activate ApplePhone appleOS is: Mac activate SumPhone sumOS is: Windows]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式02之 工厂方法模式(创建模式)]]></title>
    <url>%2F2014%2F05%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F02%E4%B9%8B-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂方法模式简介工厂方法模式(Factory Method)，又被称为”虚构造子模式”或”多态性工厂模式”。它属于”创建模式”(创建对象的模式)。 它的用意是提供一个”创建产品对象”的接口，而将这些接口的实现推迟到它的子类中去。因此它具有两个明显的优点：(1) 定义创建对象的接口,封装了对象的创建。(2) 使得具体化类的工作延迟到了子类中。 下面看看它的结构图： 工厂方法模式的结构共包括4个组成部分：抽象工厂(Factory)，具体工厂(ConcreteFactory), 抽象产品(Product)，具体产品(ConcreteProduct)。 组成部分 说明 Factory 它提供了”创建产品”的函数接口，该函数接口由具体工厂ConcreteFactory来实现。Factory可以是接口或者抽象类。 ConcreteFactory 它实现了Factory的函数接口。在上面的结构图中，给出了ConcreteFactory1和ConcreteFactory2两个具体工厂类。 Product 它是抽象产品。 ConcreteProduct 它是具体产品，实现了Product中的函数接口。ConcreteFactory中”创建产品”的函数实现中，实际上是返回的ConcreteProduct实例。在上面的结构图中，给出了ConcreteProduct1和ConcreteProduct2两个具体产品类。 工厂方法模式代码模型代码 public interface Factory { public Product newInstance() ; } public class ConcreteFactory1 implements Factory { public Product newInstance() { return new ConcreteProduct1(); } } public class ConcreteFactory2 implements Factory { public Product newInstance() { return new ConcreteProduct2(); } } public interface Product { } public class ConcreteProduct1 implements Product { public ConcreteProduct1() { // do something } } public class ConcreteProduct2 implements Product { public ConcreteProduct2() { // do something } } 模型的类图 以上模型中，对于”抽象工厂”和”抽象产品”都只给出了两个实现类；在实际中，情况可能比这复杂许多。 工厂方法模式示例将”简单工厂模式”中的示例，改为由”工厂方法模式”实现。它的UML类图如下： 抽象工厂类抽象工厂类类是”FruitFactory”。FruitFactory是水果工厂，水果工厂会生成苹果，葡萄和草莓这3种水果。 FruitFactory的源码 abstract public class FruitFactory { public abstract Fruit newInstance(); } 具体工厂类具体工厂类是”AppleFactory”, “GrapeFactory”和”StrawberryFactory”；它们都继承于FruitFactory。AppleFactory生产苹果，GrapeFactory生成葡萄，Strawberry生成草莓。 AppleFactory的源码 public class AppleFactory extends FruitFactory { public Fruit newInstance() { return new Apple(); } } GrapeFactory的源码 public class GrapeFactory extends FruitFactory { public Fruit newInstance() { return new Grape(); } } Strawberry的源码 public class StrawberryFactory extends FruitFactory { public Fruit newInstance() { return new Strawberry(); } } 抽象产品类抽象产品类是”Fruit”。Fruit代表水果，它是抽象类，包含水果的基本特征：生长，种植，收获。 Fruit的源码 public abstract class Fruit { abstract void grow(); // 生长 abstract void harvest(); // 收获 abstract void plant(); // 种植 } 具体产品类具体产品类是”Apple”, “Grape”和”Strawberry”。它们是3种具体的水果，分别代表苹果，葡萄和草莓。 Apple的源码 // Apple实现Fruit的函数接口，并且Apple中有私有成员age和私有方法log。 public class Apple extends Fruit { private int age; public void grow() { log(&quot;Apple grow()&quot;); } public void harvest() { log(&quot;Apple harvest()&quot;); } public void plant() { log(&quot;Apple plant()&quot;); } public void setAge(int age) { this.age = age; } public int getAge() { return age; } private void log(String msg) { System.out.println(msg); } } Grape的源码 // Grape仅仅只实现Fruit的函数接口。 public class Grape extends Fruit { public void grow() { System.out.println(&quot;Grape grow()&quot;); } public void harvest() { System.out.println(&quot;Grape harvest()&quot;); } public void plant() { System.out.println(&quot;Grape plant()&quot;); } } Strawberry的源码 // Strawberry实现Fruit的函数接口，并且Strawberry中有私有方法log public class Strawberry extends Fruit { public void grow() { log(&quot;Strawberry grow()&quot;); } public void harvest() { log(&quot;Strawberry harvest()&quot;); } public void plant() { log(&quot;Strawberry plant()&quot;); } private void log(String msg) { System.out.println(msg); } } 客户端测试程序客户端是”Client”。 Client的源码 public class Client { public static void main(String[] args) { // 创建&quot;抽象工厂FruitFactory&quot;对象，该对象是&quot;具体工厂AppleFactory&quot;的实例 FruitFactory appleFac = new AppleFactory(); // 根据工厂实例，创建对应的产品 Fruit apple = appleFac.newInstance(); apple.plant(); apple.grow(); apple.harvest(); // 创建&quot;抽象工厂FruitFactory&quot;对象，该对象是&quot;具体工厂GrapeFactory&quot;的实例 FruitFactory grapeFac = new GrapeFactory(); // 根据工厂实例，创建对应的产品 Fruit grape = grapeFac.newInstance(); grape.plant(); grape.grow(); grape.harvest(); // 创建&quot;抽象工厂FruitFactory&quot;对象，该对象是&quot;具体工厂StrawberryFactory&quot;的实例 FruitFactory strawberryFac = new StrawberryFactory(); // 根据工厂实例，创建对应的产品 Fruit strawberry = strawberryFac.newInstance(); strawberry.plant(); strawberry.grow(); strawberry.harvest(); } } 运行结果： Apple plant() Apple grow() Apple harvest() Grape plant() Grape grow() Grape harvest() Strawberry plant() Strawberry grow() Strawberry harvest() 工厂方法模式和简单工厂模式的比较在简单共存模式中，”工厂类”处于实例化产品的中心位置；它知道每一个产品，决定了哪一个产品类应该被实例化。如果有新的产品添加到系统中，就需要对应的修改”工厂类”。而工厂方法模式的出现，既保持了简单工厂模式的优点，又客服了它的缺点。在工厂方法模式中，”工厂类”不再负责产品的实例化，而是将实例化工作交给它的子类(具体工厂)去完成。这样，当有新的产品添加到系统中时，就不需要修改”工厂类”，而只要添加对应的”具体工厂”类即可! 简单工厂模式相当于工厂方法模式的特殊形式。即，当工厂方法模式中，只有一个”具体工厂”存在时，将”抽象工厂”和”具体工厂”合并成一个类；接着，将实例化产品的方法改为静态方法。此时，就得到了简单工厂模式。 反之，工厂方法模式也相当于”多态”的简单工厂模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>工厂方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式01之 简单工厂模式(创建模式)]]></title>
    <url>%2F2014%2F05%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01%E4%B9%8B-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单工厂模式简介简单工厂模式(Simple Factory)，又被称为”静态工厂方法模式”。它属于”创建模式”(创建对象的模式)，并且是”工厂方法”模式的一种特殊实现。 通常，我们利用简单工厂模式来进行类的创建。例如，获取线程池对象，就是通过简单工厂模式来实现的。它的结构图如下所示： 简单工厂模式的结构共包括3个组成部分：工厂(Factory)，抽象产品(Product)，具体产品(ConcreteProduct)。 组成部分 说明 工厂 工厂是简单工厂模式的核心，提供了对外接口。客户端或其它程序要获取Product对象，都是通过Factory的接口来获取的。 抽象产品 抽象产品是(许多)不同产品抽象出来的。Product可以是接口或者抽象类。 具体产品 工厂中返回的产品对象，实际上是通过ConcreteProduct来创建的。 简单工厂模式代码模型public class Factory { public static Product newInstance() { return new ConcreteProduct(); } } public abstract Product { } public class ConcreteProduct extends Product { public ConcreteProduct() {} } 模型的类图 简单工厂模式示例假设现在有一个水果工厂，能够生成各种各样的水果。目前能生产的水果包括苹果，葡萄和草莓。 我们通过”简单工厂模式”描述该问题，它的UML类图如下： 工厂类工厂类是”FruitFactory”。FruitFactory是水果工厂，水果工厂会生成水果。 FruitFactory的源码 public class FruitFactory { public static Fruit newInstance(String name) throws BadFruitException { // 如果name等于&quot;apple&quot;(忽略大小写)，则返回苹果。 if (&quot;apple&quot;.equalsIgnoreCase(name)) { return new Apple(); // 如果name等于&quot;grape&quot;(忽略大小写)，则返回葡萄。 } else if (&quot;grape&quot;.equalsIgnoreCase(name)) { return new Grape(); // 如果name等于&quot;strawberry&quot;(忽略大小写)，则返回草莓。 } else if (&quot;strawberry&quot;.equalsIgnoreCase(name)) { return new Strawberry(); // 其它情况，则抛出异常。 } else { throw new BadFruitException(&quot;Bad fruit request!&quot;); } } } 抽象产品类Product类是”Fruit”。Fruit代表水果，它是抽象类，包含水果的基本特征：生长，种植，收获。 Fruit的源码 public abstract class Fruit { abstract void grow(); // 生长 abstract void harvest(); // 收获 abstract void plant(); // 种植 } 具体产品类具体产品类是”Apple”, “Grape”和”Strawberry”。它们是3种具体的水果，分别代表苹果，葡萄和草莓。 Apple的源码 // Apple实现Fruit的函数接口，并且Apple中有私有成员age和私有方法log。 public class Apple extends Fruit { private int age; public void grow() { log(&quot;Apple grow()&quot;); } public void harvest() { log(&quot;Apple harvest()&quot;); } public void plant() { log(&quot;Apple plant()&quot;); } public void setAge(int age) { this.age = age; } public int getAge() { return age; } private void log(String msg) { System.out.println(msg); } } Grape的源码 // Grape仅仅只实现Fruit的函数接口。 public class Grape extends Fruit { public void grow() { System.out.println(&quot;Grape grow()&quot;); } public void harvest() { System.out.println(&quot;Grape harvest()&quot;); } public void plant() { System.out.println(&quot;Grape plant()&quot;); } } Strawberry的源码 // Strawberry实现Fruit的函数接口，并且Strawberry中有私有方法log public class Strawberry extends Fruit { public void grow() { log(&quot;Strawberry grow()&quot;); } public void harvest() { log(&quot;Strawberry harvest()&quot;); } public void plant() { log(&quot;Strawberry plant()&quot;); } private void log(String msg) { System.out.println(msg); } } 客户端测试程序客户端是”Client”。 Client的源码 public class Client { public static void main(String[] args) { try { Fruit apple = FruitFactory.newInstance(&quot;Apple&quot;); apple.plant(); apple.grow(); apple.harvest(); Fruit grape = FruitFactory.newInstance(&quot;Grape&quot;); grape.plant(); grape.grow(); grape.harvest(); Fruit strawberry = FruitFactory.newInstance(&quot;strawberry&quot;); strawberry.plant(); strawberry.grow(); strawberry.harvest(); Fruit error = FruitFactory.newInstance(&quot;error&quot;); error.plant(); error.grow(); error.harvest(); } catch (BadFruitException e) { e.printStackTrace(); } } } 运行结果： Apple plant() Apple grow() Apple harvest() Grape plant() Grape grow() Grape harvest() Strawberry plant() Strawberry grow() Strawberry harvest() BadFruitException: Bad fruit request! at FruitFactory.newInstance(FruitFactory.java:17) at Client.main(Client.java:21) 结果说明： Client成功创建了Apple, Grape, Strawberry这3个水果对象，并调用了它们的方法；然后创建error时，由于不存在error对应的水果，因此抛出异常。 (01) Fruit，是抽象产品。Fruit中声明了grow(), harvest(), plant()这3个函数接口，它们是水果共用拥有的行为。 (02) Apple, Grape和Strawberry这三个类是具体产品。Apple – 实现Fruit的函数接口，并且Apple中有私有成员age和私有方法log。Grape – 仅仅只实现Fruit的函数接口。Strawberry – 实现Fruit的函数接口，并且Strawberry中有私有方法log (03) FruitFactory，是工厂类。通过它的newInstance()方法，我们可以获取相应的Fruit对象。若要获取的水果不存在，则抛出BadFruitException异常。BadFruitException是Exception的子类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
</search>
